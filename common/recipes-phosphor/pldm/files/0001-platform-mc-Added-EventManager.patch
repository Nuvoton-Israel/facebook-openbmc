From 340c2dbe076af23c89a913c66cf6f0fa4416fe4b Mon Sep 17 00:00:00 2001
From: Gilbert Chen <gilbertc@nvidia.com>
Date: Tue, 6 Aug 2024 09:23:30 +0000
Subject: [PATCH 01/12] platform-mc: Added EventManager

Added eventManager to handle sensor event class(00h), and OEM CPER event
class(FAh) which are defined in table 11 of DSP0248 v1.2.1. In this
commit, the eventManager supports to receive event asynchronously.

Change-Id: I1b337ccae454067841ffbbd8754631216a995542
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Signed-off-by: Gilbert Chen <gilbertc@nvidia.com>
---
 common/types.hpp                         |   6 +
 libpldmresponder/platform.cpp            |   7 +-
 meson.build                              |   1 +
 platform-mc/event_manager.cpp            | 531 +++++++++++++++++++++++
 platform-mc/event_manager.hpp            | 120 +++++
 platform-mc/manager.hpp                  |  52 ++-
 platform-mc/platform_manager.cpp         |  74 ++++
 platform-mc/platform_manager.hpp         |  10 +
 platform-mc/sensor_manager.cpp           |   5 +-
 platform-mc/sensor_manager.hpp           |   5 +-
 platform-mc/terminus.cpp                 |   4 +-
 platform-mc/terminus.hpp                 |   3 +
 platform-mc/test/event_manager_test.cpp  | 458 +++++++++++++++++++
 platform-mc/test/meson.build             |   2 +
 platform-mc/test/mock_event_manager.hpp  |  31 ++
 platform-mc/test/mock_sensor_manager.hpp |   6 +-
 platform-mc/test/sensor_manager_test.cpp |   2 +-
 pldmd/pldmd.cpp                          |  25 +-
 18 files changed, 1328 insertions(+), 14 deletions(-)
 create mode 100644 platform-mc/event_manager.cpp
 create mode 100644 platform-mc/event_manager.hpp
 create mode 100644 platform-mc/test/event_manager_test.cpp
 create mode 100644 platform-mc/test/mock_event_manager.hpp

diff --git a/common/types.hpp b/common/types.hpp
index a1c1c51..e3b10ee 100644
--- a/common/types.hpp
+++ b/common/types.hpp
@@ -52,6 +52,12 @@ using MctpInfos = std::vector<MctpInfo>;
 constexpr uint8_t BmcMctpEid = 8;
 
 #define PLDM_PLATFORM_GETPDR_MAX_RECORD_BYTES 1024
+/* default the max event message buffer size BMC supported to 4K bytes */
+#define PLDM_PLATFORM_EVENT_MSG_MAX_BUFFER_SIZE 4096
+/* DSP0248 section16.9 EventMessageBufferSize Command, the default message
+ * buffer size is 256 bytes
+ */
+#define PLDM_PLATFORM_DEFAULT_MESSAGE_BUFFER_SIZE 256
 
 namespace dbus
 {
diff --git a/libpldmresponder/platform.cpp b/libpldmresponder/platform.cpp
index d04bb1e..b8ac0f6 100644
--- a/libpldmresponder/platform.cpp
+++ b/libpldmresponder/platform.cpp
@@ -377,15 +377,20 @@ Response Handler::platformEventMessage(const pldm_msg* request,
         try
         {
             const auto& handlers = eventHandlers.at(eventClass);
+            bool oneFailedHandler = false;
             for (const auto& handler : handlers)
             {
                 auto rc =
                     handler(request, payloadLength, formatVersion, tid, offset);
                 if (rc != PLDM_SUCCESS)
                 {
-                    return CmdHandler::ccOnlyResponse(request, rc);
+                    oneFailedHandler = true;
                 }
             }
+            if (oneFailedHandler)
+            {
+                return CmdHandler::ccOnlyResponse(request, rc);
+            }
         }
         catch (const std::out_of_range& e)
         {
diff --git a/meson.build b/meson.build
index 22de2d4..32684b3 100644
--- a/meson.build
+++ b/meson.build
@@ -246,6 +246,7 @@ executable(
     'platform-mc/manager.cpp',
     'platform-mc/sensor_manager.cpp',
     'platform-mc/numeric_sensor.cpp',
+    'platform-mc/event_manager.cpp',
     'requester/mctp_endpoint_discovery.cpp',
     implicit_include_directories: false,
     dependencies: deps,
diff --git a/platform-mc/event_manager.cpp b/platform-mc/event_manager.cpp
new file mode 100644
index 0000000..7cd2cb2
--- /dev/null
+++ b/platform-mc/event_manager.cpp
@@ -0,0 +1,531 @@
+#include "event_manager.hpp"
+
+#include "libpldm/utils.h"
+
+#include "terminus_manager.hpp"
+
+#include <phosphor-logging/lg2.hpp>
+#include <xyz/openbmc_project/Logging/Entry/server.hpp>
+
+#include <cerrno>
+
+PHOSPHOR_LOG2_USING;
+
+namespace pldm
+{
+namespace platform_mc
+{
+namespace fs = std::filesystem;
+
+/** @brief PLDM cperEventClass formatType
+ */
+enum class CperFormatType
+{
+    PLDM_FORMAT_TYPE_CPER = 0x0,
+    PLDM_FORMAT_TYPE_CPER_SECTION = 0x1
+};
+
+/* Minumum length of pldm cper event data */
+#define PLDM_CPER_EVENT_DATA_MIN_LENGTH 4
+
+/** @struct pldm_cper_event
+ *
+ *  structure representing CPEREvent
+ */
+struct pldm_cper_event_data
+{
+    uint8_t format_version;
+    uint8_t format_type;
+    uint16_t event_data_length;
+    uint8_t event_data[1];
+} __attribute__((packed));
+
+/** @brief Decode cperEvent response data
+ *
+ *  @param[in] event_data - event data from the response message
+ *  @param[in] event_data_length - length of the event data
+ *  @param[out] format_version - version of the event format
+ *  @param[out] format_type - 0x00=CPER(full record), 0x01=CPER Section(signal
+ * CPER section)
+ *  @param[out] cper_event_data_length - length in bytes of cper_event_data
+ *  @param[out] cper_event_data - the pointer to where cper data is in
+ * event_data array
+ *  @return pldm_completion_codes
+ *  @note  Caller is responsible for memory alloc and dealloc of param
+ *         'event_data'
+ */
+int decode_pldm_cper_event_data(
+    const uint8_t* event_data, size_t event_data_length,
+    uint8_t* format_version, uint8_t* format_type,
+    uint16_t* cper_event_data_length, uint8_t** cper_event_data)
+{
+    if (!event_data || !format_version || !format_type ||
+        !cper_event_data_length || !cper_event_data)
+    {
+        return PLDM_ERROR_INVALID_DATA;
+    }
+
+    if (event_data_length < PLDM_CPER_EVENT_DATA_MIN_LENGTH)
+    {
+        return PLDM_ERROR_INVALID_LENGTH;
+    }
+
+    struct pldm_cper_event_data* pldm_cper_event =
+        (struct pldm_cper_event_data*)event_data;
+    *format_version = pldm_cper_event->format_version;
+    *format_type = pldm_cper_event->format_type;
+    *cper_event_data_length = le16toh(pldm_cper_event->event_data_length);
+    *cper_event_data = pldm_cper_event->event_data;
+
+    return PLDM_SUCCESS;
+}
+
+int EventManager::handlePlatformEvent(
+    pldm_tid_t tid, uint16_t eventId, uint8_t eventClass,
+    const uint8_t* eventData, size_t eventDataSize)
+{
+    /* EventClass sensorEvent `Table 11 - PLDM Event Types` DSP0248 */
+    if (eventClass == PLDM_SENSOR_EVENT)
+    {
+        uint16_t sensorId = 0;
+        uint8_t sensorEventClassType = 0;
+        size_t eventClassDataOffset = 0;
+        auto rc = decode_sensor_event_data(eventData, eventDataSize, &sensorId,
+                                           &sensorEventClassType,
+                                           &eventClassDataOffset);
+        if (rc)
+        {
+            lg2::error("Failed to decode sensor event data return code {RC}.",
+                       "RC", rc);
+            return rc;
+        }
+        switch (sensorEventClassType)
+        {
+            case PLDM_NUMERIC_SENSOR_STATE:
+            {
+                const uint8_t* sensorData = eventData + eventClassDataOffset;
+                size_t sensorDataLength = eventDataSize - eventClassDataOffset;
+                return processNumericSensorEvent(tid, sensorId, sensorData,
+                                                 sensorDataLength);
+            }
+            case PLDM_STATE_SENSOR_STATE:
+            case PLDM_SENSOR_OP_STATE:
+            default:
+                lg2::info("Unsupported class type {CLASSTYPE}", "CLASSTYPE",
+                          sensorEventClassType);
+                return PLDM_ERROR;
+        }
+    }
+    /* EventClass CPER (0xFA OEM) `Table 11 - PLDM Event Types` DSP0248 */
+    else if (eventClass == PLDM_CPER_EVENT_CLASS)
+    {
+        return processCperEvent(eventId, eventData, eventDataSize);
+    }
+
+    lg2::info("Unsupported class type {CLASSTYPE}", "CLASSTYPE", eventClass);
+
+    return PLDM_ERROR;
+}
+
+int EventManager::processCperEvent([[maybe_unused]] uint16_t eventId,
+                                   const uint8_t* eventData,
+                                   size_t eventDataSize)
+{
+    uint8_t formatVersion;
+    uint8_t formatType = 0;
+    uint16_t cperEventDataLength;
+    uint8_t* cperEventData;
+    auto rc = decode_pldm_cper_event_data(
+        eventData, eventDataSize, &formatVersion, &formatType,
+        &cperEventDataLength, &cperEventData);
+
+    if (rc)
+    {
+        lg2::error("Failed to decode CPER event, error {RC} ", "RC", rc);
+        return rc;
+    }
+
+    // save event data to file
+    std::string dirName{"/var/cper"};
+    auto dirStatus = fs::status(dirName);
+    if (fs::exists(dirStatus))
+    {
+        if (!fs::is_directory(dirStatus))
+        {
+            lg2::error("Failed to create '{DIRNAME}' directory", "DIRNAME",
+                       dirName);
+            return PLDM_ERROR;
+        }
+    }
+    else
+    {
+        fs::create_directory(dirName);
+    }
+
+    std::string fileName{dirName + "/cper-XXXXXX"};
+    auto fd = mkstemp(fileName.data());
+    if (fd < 0)
+    {
+        lg2::error("Failed to generate temp file, error {ERRORNO}", "ERRORNO",
+                   std::strerror(errno));
+        return PLDM_ERROR;
+    }
+    close(fd);
+
+    std::ofstream ofs;
+    ofs.exceptions(std::ofstream::failbit | std::ofstream::badbit |
+                   std::ofstream::eofbit);
+
+    try
+    {
+        ofs.open(fileName);
+        ofs.write(reinterpret_cast<const char*>(eventData), eventDataSize);
+        if (formatType ==
+            static_cast<uint8_t>(CperFormatType::PLDM_FORMAT_TYPE_CPER))
+        {
+            rc = createCperDumpEntry("CPER", fileName);
+        }
+        else
+        {
+            rc = createCperDumpEntry("CPERSection", fileName);
+        }
+        ofs.close();
+    }
+    catch (const std::exception& e)
+    {
+        lg2::error("Failed to save CPER to '{FILENAME}', error - {ERROR}.",
+                   "FILENAME", fileName, "ERROR", e);
+        return PLDM_ERROR;
+    }
+    return rc;
+}
+
+int EventManager::createCperDumpEntry(const std::string& dataType,
+                                      const std::string& dataPath)
+{
+    auto createDump = [](std::map<std::string, std::string>& addData) {
+        static constexpr auto dumpObjPath =
+            "/xyz/openbmc_project/dump/faultlog";
+        static constexpr auto dumpInterface = "xyz.openbmc_project.Dump.Create";
+        auto& bus = pldm::utils::DBusHandler::getBus();
+
+        try
+        {
+            auto service = pldm::utils::DBusHandler().getService(dumpObjPath,
+                                                                 dumpInterface);
+            auto method = bus.new_method_call(service.c_str(), dumpObjPath,
+                                              dumpInterface, "CreateDump");
+            method.append(addData);
+            bus.call_noreply(method);
+        }
+        catch (const std::exception& e)
+        {
+            lg2::error("Failed to create D-Bus Dump entry, error - {ERROR}.",
+                       "ERROR", e);
+        }
+    };
+
+    std::map<std::string, std::string> addData;
+    addData["CPER_TYPE"] = dataType;
+    addData["CPER_PATH"] = dataPath;
+    createDump(addData);
+    return PLDM_SUCCESS;
+}
+
+int EventManager::createSensorThresholdLogEntry(
+    const std::string& messageId, const std::string& sensorName,
+    const double reading, const double threshold)
+{
+    using namespace sdbusplus::xyz::openbmc_project::Logging::server;
+    using Level =
+        sdbusplus::xyz::openbmc_project::Logging::server::Entry::Level;
+
+    auto createLog = [&messageId](std::map<std::string, std::string>& addData,
+                                  Level& level) {
+        static constexpr auto logObjPath = "/xyz/openbmc_project/logging";
+        static constexpr auto logInterface =
+            "xyz.openbmc_project.Logging.Create";
+        auto& bus = pldm::utils::DBusHandler::getBus();
+
+        try
+        {
+            auto service =
+                pldm::utils::DBusHandler().getService(logObjPath, logInterface);
+            auto severity = sdbusplus::xyz::openbmc_project::Logging::server::
+                convertForMessage(level);
+            auto method = bus.new_method_call(service.c_str(), logObjPath,
+                                              logInterface, "Create");
+            method.append(messageId, severity, addData);
+            bus.call_noreply(method);
+        }
+        catch (const std::exception& e)
+        {
+            lg2::error(
+                "Failed to create D-Bus log entry for message registry, error - {ERROR}.",
+                "ERROR", e);
+        }
+    };
+
+    std::map<std::string, std::string> addData;
+    addData["REDFISH_MESSAGE_ID"] = messageId;
+    Level level = Level::Informational;
+
+    addData["REDFISH_MESSAGE_ARGS"] =
+        sensorName + "," + std::to_string(reading) + "," +
+        std::to_string(threshold);
+
+    if (messageId == pldm::platform_mc::SensorThresholdWarningLowGoingHigh ||
+        messageId == pldm::platform_mc::SensorThresholdWarningHighGoingLow)
+    {
+        level = Level::Informational;
+    }
+    else if (messageId ==
+                 pldm::platform_mc::SensorThresholdWarningLowGoingLow ||
+             messageId ==
+                 pldm::platform_mc::SensorThresholdWarningHighGoingHigh ||
+             messageId ==
+                 pldm::platform_mc::SensorThresholdCriticalLowGoingHigh ||
+             messageId ==
+                 pldm::platform_mc::SensorThresholdCriticalHighGoingLow)
+    {
+        level = Level::Warning;
+    }
+    else if (messageId ==
+                 pldm::platform_mc::SensorThresholdCriticalLowGoingLow ||
+             messageId ==
+                 pldm::platform_mc::SensorThresholdCriticalHighGoingHigh)
+    {
+        level = Level::Critical;
+    }
+    else
+    {
+        /* OEM message. Will be handle by OEM */
+        return PLDM_ERROR;
+    }
+
+    createLog(addData, level);
+    return PLDM_SUCCESS;
+}
+
+int EventManager::processNumericSensorEvent(pldm_tid_t tid, uint16_t sensorId,
+                                            const uint8_t* sensorData,
+                                            size_t sensorDataLength)
+{
+    uint8_t eventState = 0;
+    uint8_t previousEventState = 0;
+    uint8_t sensorDataSize = 0;
+    uint32_t presentReading;
+    auto rc = decode_numeric_sensor_data(
+        sensorData, sensorDataLength, &eventState, &previousEventState,
+        &sensorDataSize, &presentReading);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode numericSensorState event for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        return rc;
+    }
+
+    for (auto& [terminusId, terminus] : termini)
+    {
+        if (tid != terminusId)
+        {
+            continue;
+        }
+        for (auto& sensor : terminus->numericSensors)
+        {
+            if (sensorId != sensor->sensorId)
+            {
+                continue;
+            }
+            std::string messageId =
+                getSensorThresholdMessageId(previousEventState, eventState);
+            double threshold = std::numeric_limits<double>::quiet_NaN();
+            double reading = std::numeric_limits<double>::quiet_NaN();
+            switch (eventState)
+            {
+                case PLDM_SENSOR_LOWERFATAL:
+                case PLDM_SENSOR_LOWERCRITICAL:
+                    threshold = sensor->getThresholdLowerCritical();
+                    break;
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    threshold = sensor->getThresholdUpperCritical();
+                    break;
+                case PLDM_SENSOR_LOWERWARNING:
+                    threshold = sensor->getThresholdLowerWarning();
+                    break;
+                case PLDM_SENSOR_UPPERWARNING:
+                    threshold = sensor->getThresholdUpperWarning();
+                    break;
+                default:
+                    break;
+            }
+            switch (sensorDataSize)
+            {
+                case PLDM_SENSOR_DATA_SIZE_UINT8:
+                    reading = static_cast<double>(
+                        static_cast<uint8_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT8:
+                    reading = static_cast<double>(
+                        static_cast<int8_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_UINT16:
+                    reading = static_cast<double>(
+                        static_cast<uint16_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT16:
+                    reading = static_cast<double>(
+                        static_cast<int16_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_UINT32:
+                    reading = static_cast<double>(
+                        static_cast<uint32_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT32:
+                    reading = static_cast<double>(
+                        static_cast<int32_t>(presentReading));
+                    break;
+                default:
+                    break;
+            }
+            rc = createSensorThresholdLogEntry(
+                messageId, sensor->sensorName,
+                sensor->unitModifier(sensor->conversionFormula(reading)),
+                threshold);
+            return rc;
+        }
+    }
+    return PLDM_ERROR;
+}
+
+std::string EventManager::getSensorThresholdMessageId(
+    uint8_t previousEventState, uint8_t eventState)
+{
+    switch (previousEventState)
+    {
+        case PLDM_SENSOR_UPPERFATAL:
+        case PLDM_SENSOR_UPPERCRITICAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingLow;
+                case PLDM_SENSOR_NORMAL:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingLow;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return pldm::platform_mc::SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_UPPERWARNING:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingLow;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return pldm::platform_mc::SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_UNKNOWN:
+        case PLDM_SENSOR_NORMAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    break;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return pldm::platform_mc::SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_LOWERWARNING:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningLowGoingHigh;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return pldm::platform_mc::SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_LOWERCRITICAL:
+        case PLDM_SENSOR_LOWERFATAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return pldm::platform_mc::
+                        SensorThresholdWarningLowGoingHigh;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingHigh;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return pldm::platform_mc::
+                        SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+    }
+    return std::string{};
+}
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/event_manager.hpp b/platform-mc/event_manager.hpp
new file mode 100644
index 0000000..14b12f9
--- /dev/null
+++ b/platform-mc/event_manager.hpp
@@ -0,0 +1,120 @@
+#pragma once
+
+#include "libpldm/platform.h"
+#include "libpldm/pldm.h"
+
+#include "common/types.hpp"
+#include "numeric_sensor.hpp"
+#include "pldmd/dbus_impl_requester.hpp"
+#include "requester/handler.hpp"
+#include "terminus.hpp"
+#include "terminus_manager.hpp"
+
+#define PLDM_CPER_EVENT_CLASS 0xFA
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+const std::string SensorThresholdCriticalHighGoingHigh{
+    "OpenBMC.0.2.SensorThresholdCriticalHighGoingHigh"};
+const std::string SensorThresholdCriticalHighGoingLow{
+    "OpenBMC.0.2.SensorThresholdCriticalHighGoingLow"};
+const std::string SensorThresholdCriticalLowGoingHigh{
+    "OpenBMC.0.2.SensorThresholdCriticalLowGoingHigh"};
+const std::string SensorThresholdCriticalLowGoingLow{
+    "OpenBMC.0.2.SensorThresholdCriticalLowGoingLow"};
+const std::string SensorThresholdWarningHighGoingHigh{
+    "OpenBMC.0.2.SensorThresholdWarningHighGoingHigh"};
+const std::string SensorThresholdWarningHighGoingLow{
+    "OpenBMC.0.2.SensorThresholdWarningHighGoingLow"};
+const std::string SensorThresholdWarningLowGoingHigh{
+    "OpenBMC.0.2.SensorThresholdWarningLowGoingHigh"};
+const std::string SensorThresholdWarningLowGoingLow{
+    "OpenBMC.0.2.SensorThresholdWarningLowGoingLow"};
+
+/**
+ * @brief EventManager
+ *
+ * This class manages PLDM events from terminus. The function includes providing
+ * the API for process event data and using phosphor-logging API to log the
+ * event.
+ *
+ */
+class EventManager
+{
+  public:
+    EventManager() = delete;
+    EventManager(const EventManager&) = delete;
+    EventManager(EventManager&&) = delete;
+    EventManager& operator=(const EventManager&) = delete;
+    EventManager& operator=(EventManager&&) = delete;
+    virtual ~EventManager() = default;
+
+    explicit EventManager(
+        TerminusManager& terminusManager,
+        std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini) :
+        terminusManager(terminusManager), termini(termini) {};
+
+    /** @brief Handle platform event
+     *
+     *  @param[in] tid - tid where the event is from
+     *  @param[in] eventId - event Id
+     *  @param[in] eventClass - event class
+     *  @param[in] eventData - event data
+     *  @param[in] eventDataSize - size of event data
+     *  @return PLDM completion code
+     *
+     */
+    int handlePlatformEvent(pldm_tid_t tid, uint16_t eventId,
+                            uint8_t eventClass, const uint8_t* eventData,
+                            size_t eventDataSize);
+
+    std::string getSensorThresholdMessageId(uint8_t previousEventState,
+                                            uint8_t eventState);
+
+    /** @brief Set available state of terminus for pldm request.
+     */
+    void updateAvailableState(pldm_tid_t tid, Availability state)
+    {
+        availableState[tid] = state;
+    };
+
+    /** @brief Get available state of terminus for pldm request.
+     */
+    bool getAvailableState(pldm_tid_t tid)
+    {
+        if (!availableState.contains(tid))
+        {
+            return false;
+        }
+        return availableState[tid];
+    };
+
+  protected:
+    virtual int processCperEvent(uint16_t eventId, const uint8_t* eventData,
+                                 size_t eventDataSize);
+
+    int createCperDumpEntry(const std::string& dataType,
+                            const std::string& dataPath);
+
+    int processNumericSensorEvent(pldm_tid_t tid, uint16_t sensorId,
+                                  const uint8_t* sensorData,
+                                  size_t sensorDataLength);
+
+    virtual int createSensorThresholdLogEntry(
+        const std::string& messageID, const std::string& sensorName,
+        const double reading, const double threshold);
+
+    /** @brief Reference of terminusManager */
+    TerminusManager& terminusManager;
+
+    /** @brief List of discovered termini */
+    TerminiMapper& termini;
+
+    /** @brief Available state for pldm request of terminus*/
+    std::map<pldm_tid_t, Availability> availableState;
+};
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index efbd1cb..266d267 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -4,6 +4,7 @@
 
 #include "common/instance_id.hpp"
 #include "common/types.hpp"
+#include "event_manager.hpp"
 #include "platform_manager.hpp"
 #include "requester/handler.hpp"
 #include "requester/mctp_endpoint_discovery.hpp"
@@ -36,7 +37,8 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         terminusManager(event, handler, instanceIdDb, termini, this,
                         pldm::BmcMctpEid),
         platformManager(terminusManager, termini),
-        sensorManager(event, terminusManager, termini)
+        sensorManager(event, terminusManager, termini, this),
+        eventManager(terminusManager, termini)
     {}
 
     /** @brief Helper function to do the actions before discovering terminus
@@ -88,6 +90,7 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         if (termini.contains(tid))
         {
             sensorManager.updateAvailableState(tid, state);
+            eventManager.updateAvailableState(tid, state);
         }
     }
 
@@ -98,6 +101,50 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         sensorManager.stopPolling(tid);
     }
 
+    /** @brief CPER event handler funtion
+     *
+     *  @param[in] request - Event message
+     *  @param[in] payloadLength - Event message payload size
+     *  @param[in] tid - Terminus ID
+     *  @param[in] eventDataOffset - Event data offset
+     *
+     *  @return PLDM error code: PLDM_SUCCESS when there is no error in handling
+     *          the event
+     */
+    int handleCperEvent(const pldm_msg* request, size_t payloadLength,
+                        uint8_t /* formatVersion */, uint8_t tid,
+                        size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, 0x00, PLDM_CPER_EVENT_CLASS,
+                                         eventData, eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
+    /** @brief Sensor event handler funtion
+     *
+     *  @param[in] request - Event message
+     *  @param[in] payloadLength - Event message payload size
+     *  @param[in] tid - Terminus ID
+     *  @param[in] eventDataOffset - Event data offset
+     *
+     *  @return PLDM error code: PLDM_SUCCESS when there is no error in handling
+     *          the event
+     */
+    int handleSensorEvent(const pldm_msg* request, size_t payloadLength,
+                          uint8_t /* formatVersion */, uint8_t tid,
+                          size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, 0x00, PLDM_SENSOR_EVENT,
+                                         eventData, eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
   private:
     /** @brief List of discovered termini */
     TerminiMapper termini{};
@@ -110,6 +157,9 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
 
     /** @brief Store platform manager handler */
     SensorManager sensorManager;
+
+    /** @brief Store event manager handler */
+    EventManager eventManager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/platform_manager.cpp b/platform-mc/platform_manager.cpp
index 35526fb..ff6af04 100644
--- a/platform-mc/platform_manager.cpp
+++ b/platform-mc/platform_manager.cpp
@@ -37,6 +37,29 @@ exec::task<int> PlatformManager::initTerminus()
             terminus->parseTerminusPDRs();
         }
 
+        uint16_t terminusMaxBufferSize = terminus->maxBufferSize;
+        if (!terminus->doesSupportCommand(PLDM_PLATFORM,
+                                          PLDM_EVENT_MESSAGE_BUFFER_SIZE))
+        {
+            terminusMaxBufferSize = PLDM_PLATFORM_DEFAULT_MESSAGE_BUFFER_SIZE;
+        }
+        else
+        {
+            /* Get maxBufferSize use PLDM command eventMessageBufferSize */
+            auto rc = co_await eventMessageBufferSize(
+                tid, terminus->maxBufferSize, terminusMaxBufferSize);
+            if (rc != PLDM_SUCCESS)
+            {
+                lg2::error(
+                    "Failed to get message buffer size for terminus with TID: {TID}, error: {ERROR}",
+                    "TID", tid, "ERROR", rc);
+                terminusMaxBufferSize =
+                    PLDM_PLATFORM_DEFAULT_MESSAGE_BUFFER_SIZE;
+            }
+        }
+        terminus->maxBufferSize =
+            std::min(terminus->maxBufferSize, terminusMaxBufferSize);
+
         auto rc = co_await configEventReceiver(tid);
         if (rc)
         {
@@ -369,6 +392,57 @@ exec::task<int> PlatformManager::getPDRRepositoryInfo(
     co_return completionCode;
 }
 
+exec::task<int> PlatformManager::eventMessageBufferSize(
+    pldm_tid_t tid, uint16_t receiverMaxBufferSize,
+    uint16_t& terminusBufferSize)
+{
+    Request request(
+        sizeof(pldm_msg_hdr) + PLDM_EVENT_MESSAGE_BUFFER_SIZE_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_event_message_buffer_size_req(0, receiverMaxBufferSize,
+                                                   requestMsg);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to encode request GetPDRRepositoryInfo for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = nullptr;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.sendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to send EventMessageBufferSize message for terminus {TID}, error {RC}",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    uint8_t completionCode;
+    rc = decode_event_message_buffer_size_resp(
+        responseMsg, responseLen, &completionCode, &terminusBufferSize);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode response EventMessageBufferSize for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    if (completionCode != PLDM_SUCCESS)
+    {
+        lg2::error(
+            "Error : EventMessageBufferSize for terminus ID {TID}, complete code {CC}.",
+            "TID", tid, "CC", completionCode);
+        co_return rc;
+    }
+
+    co_return completionCode;
+}
+
 exec::task<int> PlatformManager::setEventReceiver(
     pldm_tid_t tid, pldm_event_message_global_enable eventMessageGlobalEnable,
     pldm_transport_protocol_type protocolType, uint16_t heartbeatTimer)
diff --git a/platform-mc/platform_manager.hpp b/platform-mc/platform_manager.hpp
index 641f16a..549a4e7 100644
--- a/platform-mc/platform_manager.hpp
+++ b/platform-mc/platform_manager.hpp
@@ -111,6 +111,16 @@ class PlatformManager
         pldm_event_message_global_enable eventMessageGlobalEnable,
         pldm_transport_protocol_type protocolType, uint16_t heartbeatTimer);
 
+    /** @brief  send eventMessageBufferSize
+     *  @param[in] tid - Destination TID
+     *  @param[in] receiverMaxBufferSize
+     *  @param[out] terminusBufferSize
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> eventMessageBufferSize(pldm_tid_t tid,
+                                           uint16_t receiverMaxBufferSize,
+                                           uint16_t& terminusBufferSize);
+
     /** @brief  send eventMessageSupported
      *  @param[in] tid - Destination TID
      *  @param[in] formatVersion - version of the event format
diff --git a/platform-mc/sensor_manager.cpp b/platform-mc/sensor_manager.cpp
index fcfd0a6..74e3043 100644
--- a/platform-mc/sensor_manager.cpp
+++ b/platform-mc/sensor_manager.cpp
@@ -1,5 +1,6 @@
 #include "sensor_manager.hpp"
 
+#include "manager.hpp"
 #include "terminus_manager.hpp"
 
 #include <phosphor-logging/lg2.hpp>
@@ -13,9 +14,9 @@ namespace platform_mc
 
 SensorManager::SensorManager(sdeventplus::Event& event,
                              TerminusManager& terminusManager,
-                             TerminiMapper& termini) :
+                             TerminiMapper& termini, Manager* manager) :
     event(event), terminusManager(terminusManager), termini(termini),
-    pollingTime(SENSOR_POLLING_TIME)
+    pollingTime(SENSOR_POLLING_TIME), manager(manager)
 {}
 
 void SensorManager::startPolling(pldm_tid_t tid)
diff --git a/platform-mc/sensor_manager.hpp b/platform-mc/sensor_manager.hpp
index 1c7c788..29172bb 100644
--- a/platform-mc/sensor_manager.hpp
+++ b/platform-mc/sensor_manager.hpp
@@ -38,7 +38,7 @@ class SensorManager
 
     explicit SensorManager(sdeventplus::Event& event,
                            TerminusManager& terminusManager,
-                           TerminiMapper& termini);
+                           TerminiMapper& termini, Manager* manager);
 
     /** @brief starting sensor polling task
      */
@@ -111,6 +111,9 @@ class SensorManager
     /** @brief round robin sensor list */
     std::map<pldm_tid_t, std::queue<std::shared_ptr<NumericSensor>>>
         roundRobinSensors;
+
+    /** @brief pointer to Manager */
+    Manager* manager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/terminus.cpp b/platform-mc/terminus.cpp
index c8cd91a..0038d04 100644
--- a/platform-mc/terminus.cpp
+++ b/platform-mc/terminus.cpp
@@ -14,8 +14,8 @@ namespace platform_mc
 {
 
 Terminus::Terminus(pldm_tid_t tid, uint64_t supportedTypes) :
-    initialized(false), synchronyConfigurationSupported(0), tid(tid),
-    supportedTypes(supportedTypes)
+    initialized(false), maxBufferSize(PLDM_PLATFORM_EVENT_MSG_MAX_BUFFER_SIZE),
+    synchronyConfigurationSupported(0), tid(tid), supportedTypes(supportedTypes)
 {}
 
 bool Terminus::doesSupportType(uint8_t type)
diff --git a/platform-mc/terminus.hpp b/platform-mc/terminus.hpp
index 26a412b..ca1604d 100644
--- a/platform-mc/terminus.hpp
+++ b/platform-mc/terminus.hpp
@@ -133,6 +133,9 @@ class Terminus
     /** @brief A flag to indicate if terminus has been initialized */
     bool initialized = false;
 
+    /** @brief maximum message buffer size the terminus can send and receive */
+    uint16_t maxBufferSize;
+
     /** @brief This value indicates the event messaging styles supported by the
      *         terminus
      */
diff --git a/platform-mc/test/event_manager_test.cpp b/platform-mc/test/event_manager_test.cpp
new file mode 100644
index 0000000..ee03c5d
--- /dev/null
+++ b/platform-mc/test/event_manager_test.cpp
@@ -0,0 +1,458 @@
+#include "libpldm/base.h"
+#include "libpldm/entity.h"
+#include "libpldm/platform.h"
+
+#include "common/instance_id.hpp"
+#include "common/types.hpp"
+#include "mock_event_manager.hpp"
+#include "mock_terminus_manager.hpp"
+#include "platform-mc/platform_manager.hpp"
+#include "platform-mc/terminus_manager.hpp"
+#include "test/test_instance_id.hpp"
+
+#include <gtest/gtest.h>
+
+using ::testing::_;
+using ::testing::Return;
+
+class EventManagerTest : public testing::Test
+{
+  protected:
+    EventManagerTest() :
+        bus(pldm::utils::DBusHandler::getBus()),
+        event(sdeventplus::Event::get_default()), instanceIdDb(),
+        reqHandler(pldmTransport, event, instanceIdDb, false,
+                   std::chrono::seconds(1), 2, std::chrono::milliseconds(100)),
+        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        eventManager(terminusManager, termini),
+        platformManager(terminusManager, termini)
+    {}
+
+    PldmTransport* pldmTransport = nullptr;
+    sdbusplus::bus::bus& bus;
+    sdeventplus::Event event;
+    TestInstanceIdDb instanceIdDb;
+    pldm::requester::Handler<pldm::requester::Request> reqHandler;
+    pldm::platform_mc::MockTerminusManager terminusManager;
+    pldm::platform_mc::MockEventManager eventManager;
+    pldm::platform_mc::PlatformManager platformManager;
+    pldm::platform_mc::TerminiMapper termini{};
+};
+
+TEST_F(EventManagerTest, processNumericSensorEventTest)
+{
+#define SENSOR_READING 50
+#define WARNING_HIGH 45
+    pldm_tid_t tid = 1;
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(
+        tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                         // record handle
+        0x1,                         // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR,     // PDRType
+        0x0,
+        0x0,                         // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_MIN_LENGTH,
+        0,                           // dataLength
+        0,
+        0,                           // PLDMTerminusHandle
+        0x1,
+        0x0,                         // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                           // entityType=Power Supply(120)
+        1,
+        0,                           // entityInstanceNumber
+        1,
+        0,                           // containerID=1
+        PLDM_NO_INIT,                // sensorInit
+        false,                       // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,  // baseUint(2)=degrees C
+        0,                           // unitModifier = 0
+        0,                           // rateUnit
+        0,                           // baseOEMUnitHandle
+        0,                           // auxUnit
+        0,                           // auxUnitModifier
+        0,                           // auxRateUnit
+        0,                           // rel
+        0,                           // auxOEMUnitHandle
+        true,                        // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8, // sensorDataSize
+        0,
+        0,
+        0x80,
+        0x3f, // resolution=1.0
+        0,
+        0,
+        0,
+        0,    // offset=0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis = 2
+        0x1b, // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0x18,                          // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        WARNING_HIGH,                  // warningHigh
+        20,                            // warningLow
+        60,                            // criticalHigh
+        10,                            // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    std::vector<uint8_t> pdr2{
+        0x1, 0x0, 0x0,
+        0x0,                             // record handle
+        0x1,                             // PDRHeaderVersion
+        PLDM_ENTITY_AUXILIARY_NAMES_PDR, // PDRType
+        0x1,
+        0x0,                             // recordChangeNumber
+        0x11,
+        0,                               // dataLength
+        /* Entity Auxiliary Names PDR Data*/
+        3,
+        0x80, // entityType system software
+        0x1,
+        0x0,  // Entity instance number =1
+        0,
+        0,    // Overal system
+        0,    // shared Name Count one name only
+        01,   // nameStringCount
+        0x65, 0x6e, 0x00,
+        0x00, // Language Tag "en"
+        0x53, 0x00, 0x30, 0x00,
+        0x00  // Entity Name "S0"
+    };
+
+    // add dummy numeric sensor
+    termini[tid]->pdrs.emplace_back(pdr1);
+    termini[tid]->pdrs.emplace_back(pdr2);
+    termini[tid]->parseTerminusPDRs();
+    EXPECT_EQ(1, termini[tid]->numericSensors.size());
+
+    uint8_t platformEventStatus = 0;
+
+    EXPECT_CALL(eventManager,
+                createSensorThresholdLogEntry(
+                    pldm::platform_mc::SensorThresholdWarningHighGoingHigh, _,
+                    SENSOR_READING, WARNING_HIGH))
+        .Times(1)
+        .WillRepeatedly(Return(PLDM_SUCCESS));
+    std::vector<uint8_t> eventData{
+        0x1,
+        0x0, // sensor id
+        PLDM_NUMERIC_SENSOR_STATE,
+        PLDM_SENSOR_UPPERWARNING,
+        PLDM_SENSOR_NORMAL,
+        PLDM_SENSOR_DATA_SIZE_UINT8,
+        SENSOR_READING};
+    auto rc = eventManager.handlePlatformEvent(
+        tid, 0x00, PLDM_SENSOR_EVENT, eventData.data(), eventData.size());
+    EXPECT_EQ(PLDM_SUCCESS, rc);
+    EXPECT_EQ(PLDM_EVENT_NO_LOGGING, platformEventStatus);
+}
+
+TEST_F(EventManagerTest, getSensorThresholdMessageIdTest)
+{
+    std::string messageId{};
+    messageId = eventManager.getSensorThresholdMessageId(PLDM_SENSOR_UNKNOWN,
+                                                         PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, std::string{});
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdWarningLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_LOWERCRITICAL);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdCriticalLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdWarningHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_UPPERCRITICAL);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdCriticalHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_NORMAL, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdWarningLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERWARNING, PLDM_SENSOR_LOWERCRITICAL);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdCriticalLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERCRITICAL, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdCriticalLowGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERWARNING, PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdWarningLowGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_NORMAL, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdWarningHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERWARNING, PLDM_SENSOR_UPPERCRITICAL);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdCriticalHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERCRITICAL, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId,
+              pldm::platform_mc::SensorThresholdCriticalHighGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERWARNING, PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, pldm::platform_mc::SensorThresholdWarningHighGoingLow);
+}
+
+TEST_F(EventManagerTest, SetEventReceiverTest)
+{
+    // Add terminus
+    auto mappedTid = terminusManager.mapTid(pldm::MctpInfo(10, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(
+        tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    /* Set supported command by terminus */
+    auto size = PLDM_MAX_TYPES * (PLDM_MAX_CMDS_PER_TYPE / 8);
+    std::vector<uint8_t> pldmCmds(size);
+    uint8_t type = PLDM_PLATFORM;
+    uint8_t cmd = PLDM_GET_PDR_REPOSITORY_INFO;
+    auto idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    cmd = PLDM_GET_PDR;
+    idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    cmd = PLDM_EVENT_MESSAGE_SUPPORTED;
+    idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    cmd = PLDM_EVENT_MESSAGE_BUFFER_SIZE;
+    idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    cmd = PLDM_SET_EVENT_RECEIVER;
+    idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    termini[tid]->setSupportedCommands(pldmCmds);
+
+    EXPECT_EQ(true, termini[tid]->doesSupportCommand(PLDM_PLATFORM,
+                                                     PLDM_SET_EVENT_RECEIVER));
+    EXPECT_EQ(true, termini[tid]->doesSupportCommand(
+                        PLDM_PLATFORM, PLDM_EVENT_MESSAGE_BUFFER_SIZE));
+    EXPECT_EQ(true, termini[tid]->doesSupportCommand(
+                        PLDM_PLATFORM, PLDM_EVENT_MESSAGE_SUPPORTED));
+    EXPECT_EQ(true,
+              termini[tid]->doesSupportCommand(PLDM_PLATFORM, PLDM_GET_PDR));
+    EXPECT_EQ(true, termini[tid]->doesSupportCommand(
+                        PLDM_PLATFORM, PLDM_GET_PDR_REPOSITORY_INFO));
+
+    // queue getPDRRepositoryInfo response
+    const size_t getPDRRepositoryInfoLen =
+        PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPDRRepositoryInfoLen>
+        getPDRRepositoryInfoResp{
+            0x0, 0x02, 0x50, PLDM_SUCCESS,
+            0x0,                                     // repositoryState
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // updateTime
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // OEMUpdateTime
+            2,   0x0,  0x0,  0x0,                    // recordCount
+            0x0, 0x1,  0x0,  0x0,                    // repositorySize
+            59,  0x0,  0x0,  0x0,                    // largestRecordSize
+            0x0 // dataTransferHandleTimeout
+        };
+    auto rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(getPDRRepositoryInfoResp.data()),
+        sizeof(getPDRRepositoryInfoResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDR responses
+    const size_t getPdrRespLen = 81;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrRespLen> getPdrResp{
+        0x0, 0x02, 0x51, PLDM_SUCCESS, 0x1, 0x0, 0x0, 0x0, // nextRecordHandle
+        0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+        0x5,                // transferFlag
+        69, 0x0,            // responseCount
+        // numeric Sensor PDR
+        0x0, 0x0, 0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        120,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8,   // sensorDataSize
+        0, 0, 0xc0,
+        0x3f,                          // resolution=1.5
+        0, 0, 0x80,
+        0x3f,                          // offset=1.0
+        0,
+        0,                             // accuracy
+        0,                             // plusTolerance
+        0,                             // minusTolerance
+        2,                             // hysteresis
+        0,                             // supportedThresholds
+        0,                             // thresholdAndHysteresisVolatility
+        0, 0, 0x80,
+        0x3f,                          // stateTransistionInterval=1.0
+        0, 0, 0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+    rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(getPdrResp.data()), sizeof(getPdrResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    const size_t getPdrAuxNameRespLen = 39;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrAuxNameRespLen>
+        getPdrAuxNameResp{
+            0x0, 0x02, 0x51, PLDM_SUCCESS, 0x0, 0x0, 0x0,
+            0x0,                // nextRecordHandle
+            0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+            0x5,                // transferFlag
+            0x1b, 0x0,          // responseCount
+            // Common PDR Header
+            0x1, 0x0, 0x0,
+            0x0,                             // record handle
+            0x1,                             // PDRHeaderVersion
+            PLDM_ENTITY_AUXILIARY_NAMES_PDR, // PDRType
+            0x1,
+            0x0,                             // recordChangeNumber
+            0x11,
+            0,                               // dataLength
+            /* Entity Auxiliary Names PDR Data*/
+            3,
+            0x80, // entityType system software
+            0x1,
+            0x0,  // Entity instance number =1
+            0,
+            0,    // Overal system
+            0,    // shared Name Count one name only
+            01,   // nameStringCount
+            0x65, 0x6e, 0x00,
+            0x00, // Language Tag "en"
+            0x53, 0x00, 0x30, 0x00,
+            0x00  // Entity Name "S0"
+        };
+    rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(getPdrAuxNameResp.data()),
+        sizeof(getPdrAuxNameResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue eventMessageBufferSize response(bufferSize=32)
+    const size_t eventMessageBufferSizeRespLen = 3;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageBufferSizeRespLen>
+        eventMessageBufferSizeResp{0x0, 0x02, 0x0d, PLDM_SUCCESS, 32, 0};
+    rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(eventMessageBufferSizeResp.data()),
+        sizeof(eventMessageBufferSizeResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue eventMessageSupported response
+    const size_t eventMessageSupportedLen = 7;
+    PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageSupportedLen>
+        eventMessageSupportedResp{0x0,  0x02, 0x0c, PLDM_SUCCESS,
+                                  0x0,  // synchronyConfiguration
+                                  0x06, // synchronyConfigurationSupported
+                                  3,    // numberEventClassReturned
+                                  0x0,  0x5,  0xfa};
+    rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(eventMessageSupportedResp.data()),
+        sizeof(eventMessageSupportedResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue SetEventReceiver response
+    const size_t SetEventReceiverLen = 1;
+    PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + SetEventReceiverLen>
+        SetEventReceiverResp{0x0, 0x02, 0x04, PLDM_SUCCESS};
+    rc = terminusManager.enqueueResponse(
+        reinterpret_cast<pldm_msg*>(SetEventReceiverResp.data()),
+        sizeof(SetEventReceiverResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // should finish immediately
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(32, terminus->maxBufferSize);
+    EXPECT_EQ(0x06, terminus->synchronyConfigurationSupported.byte);
+    EXPECT_EQ(2, terminus->pdrs.size());
+    EXPECT_EQ(1, terminus->numericSensors.size());
+}
+
+TEST_F(EventManagerTest, updateAvailableState)
+{
+    pldm_tid_t tid = 1;
+    eventManager.updateAvailableState(tid, true);
+    EXPECT_EQ(true, eventManager.getAvailableState(tid));
+    eventManager.updateAvailableState(tid, false);
+    EXPECT_EQ(false, eventManager.getAvailableState(tid));
+    eventManager.updateAvailableState(2, false);
+    EXPECT_EQ(false, eventManager.getAvailableState(tid));
+}
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index ab7b20a..0e8bc87 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -6,6 +6,7 @@ test_src = declare_dependency(
         '../manager.cpp',
         '../sensor_manager.cpp',
         '../numeric_sensor.cpp',
+        '../event_manager.cpp',
         '../../requester/mctp_endpoint_discovery.cpp',
     ],
     include_directories: ['../../requester', '../../pldmd'],
@@ -17,6 +18,7 @@ tests = [
     'platform_manager_test',
     'sensor_manager_test',
     'numeric_sensor_test',
+    'event_manager_test',
 ]
 
 foreach t : tests
diff --git a/platform-mc/test/mock_event_manager.hpp b/platform-mc/test/mock_event_manager.hpp
new file mode 100644
index 0000000..0bda579
--- /dev/null
+++ b/platform-mc/test/mock_event_manager.hpp
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "platform-mc/event_manager.hpp"
+
+#include <gmock/gmock.h>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+class MockEventManager : public EventManager
+{
+  public:
+    MockEventManager(TerminusManager& terminusManager,
+                     std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini) :
+        EventManager(terminusManager, termini) {};
+
+    MOCK_METHOD(int, createSensorThresholdLogEntry,
+                (const std::string& messageID, const std::string& sensorName,
+                 const double reading, const double threshold),
+                (override));
+
+    MOCK_METHOD(int, processCperEvent,
+                (uint16_t eventId, const uint8_t* eventData,
+                 size_t eventDataSize),
+                (override));
+};
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/test/mock_sensor_manager.hpp b/platform-mc/test/mock_sensor_manager.hpp
index a52e4ea..fcb8102 100644
--- a/platform-mc/test/mock_sensor_manager.hpp
+++ b/platform-mc/test/mock_sensor_manager.hpp
@@ -13,9 +13,9 @@ class MockSensorManager : public SensorManager
 {
   public:
     MockSensorManager(sdeventplus::Event& event,
-                      TerminusManager& terminusManager,
-                      TerminiMapper& termini) :
-        SensorManager(event, terminusManager, termini) {};
+                      TerminusManager& terminusManager, TerminiMapper& termini,
+                      Manager* manager) :
+        SensorManager(event, terminusManager, termini, manager) {};
 
     MOCK_METHOD(void, doSensorPolling, (pldm_tid_t tid), (override));
 };
diff --git a/platform-mc/test/sensor_manager_test.cpp b/platform-mc/test/sensor_manager_test.cpp
index 59a120b..4ec9f5b 100644
--- a/platform-mc/test/sensor_manager_test.cpp
+++ b/platform-mc/test/sensor_manager_test.cpp
@@ -19,7 +19,7 @@ class SensorManagerTest : public testing::Test
         reqHandler(pldmTransport, event, instanceIdDb, false),
         terminusManager(event, reqHandler, instanceIdDb, termini, nullptr,
                         pldm::BmcMctpEid),
-        sensorManager(event, terminusManager, termini)
+        sensorManager(event, terminusManager, termini, nullptr)
     {}
 
     void runEventLoopForSeconds(uint64_t sec)
diff --git a/pldmd/pldmd.cpp b/pldmd/pldmd.cpp
index 46c216a..b75e999 100644
--- a/pldmd/pldmd.cpp
+++ b/pldmd/pldmd.cpp
@@ -270,10 +270,31 @@ int main(int argc, char** argv)
     // FRU table is built lazily when a FRU command or Get PDR command is
     // handled. To enable building FRU table, the FRU handler is passed to the
     // Platform handler.
+
+    std::unique_ptr<platform_mc::Manager> platformManager =
+        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb);
+
+    pldm::responder::platform::EventMap addOnEventHandlers{
+        {PLDM_CPER_EVENT_CLASS,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+             return platformManager->handleCperEvent(
+                 request, payloadLength, formatVersion, tid, eventDataOffset);
+         }}},
+        {PLDM_SENSOR_EVENT,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+             return platformManager->handleSensorEvent(
+                 request, payloadLength, formatVersion, tid, eventDataOffset);
+         }}}};
+
     auto platformHandler = std::make_unique<platform::Handler>(
         &dbusHandler, hostEID, &instanceIdDb, PDR_JSONS_DIR, pdrRepo.get(),
         hostPDRHandler.get(), dbusToPLDMEventHandler.get(), fruHandler.get(),
-        platformConfigHandler.get(), &reqHandler, event, true);
+        platformConfigHandler.get(), &reqHandler, event, true,
+        addOnEventHandlers);
 
     auto biosHandler = std::make_unique<bios::Handler>(
         pldmTransport.getEventSource(), hostEID, &instanceIdDb, &reqHandler,
@@ -302,8 +323,6 @@ int main(int argc, char** argv)
 
     std::unique_ptr<fw_update::Manager> fwManager =
         std::make_unique<fw_update::Manager>(event, reqHandler, instanceIdDb);
-    std::unique_ptr<platform_mc::Manager> platformManager =
-        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb);
     std::unique_ptr<MctpDiscovery> mctpDiscoveryHandler =
         std::make_unique<MctpDiscovery>(
             bus, std::initializer_list<MctpDiscoveryHandlerIntf*>{
-- 
2.44.2

