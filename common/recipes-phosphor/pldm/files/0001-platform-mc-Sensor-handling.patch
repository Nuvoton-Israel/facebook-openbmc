From 0fd85adf9816f88fbb1c5cb3b3aba2e7144e0220 Mon Sep 17 00:00:00 2001
From: Gilbert Chen <gilbert.chen@arm.com>
Date: Wed, 23 Feb 2022 20:56:19 +0000
Subject: [PATCH 01/13] platform-mc: Sensor handling

Added sensor_manager and numeric_sensor class. The sensor_manager
class manages the timing of sensor polling. The NumericSensor class
handles sensor status and exports its status to D-Bus interfaces.

tested: Verified on ast2600 EVB which is connected to a PLDM device
over I2C. bmcweb can display the state of numeric sensor.

Signed-off-by: Gilbert Chen <gilbert.chen@arm.com>
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Change-Id: I4257f823ea26d7fdb322cc82d847e94db056258c
---
 meson.build                                |   5 +
 meson.options                              |  14 +-
 platform-mc/examples/pldm_t2_config.json   |  12 +
 platform-mc/manager.hpp                    |  21 +-
 platform-mc/numeric_sensor.cpp             | 146 ++++++++
 platform-mc/numeric_sensor.hpp             | 106 ++++++
 platform-mc/sensor_manager.cpp             | 410 +++++++++++++++++++++
 platform-mc/sensor_manager.hpp             | 117 ++++++
 platform-mc/terminus.cpp                   |  19 +-
 platform-mc/terminus_manager.cpp           |  18 +
 platform-mc/test/meson.build               |   3 +
 platform-mc/test/mock_sensor_manager.hpp   |  24 ++
 platform-mc/test/numeric_sensor_test.cpp   | 272 ++++++++++++++
 platform-mc/test/platform_manager_test.cpp |   3 +
 platform-mc/test/sensor_manager_test.cpp   | 147 ++++++++
 pldmd/pldmd.cpp                            |   2 +-
 16 files changed, 1315 insertions(+), 4 deletions(-)
 create mode 100644 platform-mc/examples/pldm_t2_config.json
 create mode 100644 platform-mc/sensor_manager.cpp
 create mode 100644 platform-mc/sensor_manager.hpp
 create mode 100644 platform-mc/test/mock_sensor_manager.hpp
 create mode 100644 platform-mc/test/numeric_sensor_test.cpp
 create mode 100644 platform-mc/test/sensor_manager_test.cpp

diff --git a/meson.build b/meson.build
index af6bf6e..11ba149 100644
--- a/meson.build
+++ b/meson.build
@@ -73,6 +73,10 @@ elif get_option('transport-implementation') == 'af-mctp'
   conf_data.set('PLDM_TRANSPORT_WITH_AF_MCTP', 1)
 endif
 conf_data.set('DEFAULT_SENSOR_UPDATER_INTERVAL', get_option('default-sensor-update-interval'))
+conf_data.set_quoted('STATIC_EID_TABLE_PATH', join_paths(package_datadir, 'static_eid_table.json'))
+conf_data.set('SENSOR_POLLING_TIME', get_option('sensor-polling-time'))
+conf_data.set('DEFAULT_SENSOR_UPDATER_INTERVAL', get_option('default-sensor-update-interval'))
+conf_data.set_quoted('PLDM_T2_CONFIG_JSON', join_paths(package_datadir, 'pldm_t2_config.json'))
 
 configure_file(output: 'config.h',
   configuration: conf_data
@@ -175,6 +179,7 @@ executable(
   'platform-mc/terminus.cpp',
   'platform-mc/platform_manager.cpp',
   'platform-mc/manager.cpp',
+  'platform-mc/sensor_manager.cpp',
   'platform-mc/numeric_sensor.cpp',
   'requester/mctp_endpoint_discovery.cpp',
   implicit_include_directories: false,
diff --git a/meson.options b/meson.options
index 63726dd..deb6dc6 100644
--- a/meson.options
+++ b/meson.options
@@ -175,6 +175,18 @@ option(
     description: 'OEM-IBM: max DMA size'
 )
 
+# Platform-mc configuration parameters
+
+## Sensor Polling Options
+option(
+    'sensor-polling-time',
+    type: 'integer',
+    min: 1,
+    max: 4294967295,
+    description: 'The interval time of sensor polling in milliseconds',
+    value: 249
+)
+
 ## Default Sensor Update Interval Options
 option(
     'default-sensor-update-interval',
@@ -188,4 +200,4 @@ option(
                     of the monitoring terminus after each configured
                     interval.''',
     value: 999
-)
\ No newline at end of file
+)
diff --git a/platform-mc/examples/pldm_t2_config.json b/platform-mc/examples/pldm_t2_config.json
new file mode 100644
index 0000000..4300fd3
--- /dev/null
+++ b/platform-mc/examples/pldm_t2_config.json
@@ -0,0 +1,12 @@
+{
+    "PrioritySensorNameSpaces": [
+        "/xyz/openbmc_project/sensors/temperature/",
+        "/xyz/openbmc_project/sensors/power/",
+        "/xyz/openbmc_project/sensors/energy/"
+    ],
+    "AggregationSensorNameSpaces": [
+        "/xyz/openbmc_project/sensors/temperature/",
+        "/xyz/openbmc_project/sensors/power/",
+        "/xyz/openbmc_project/sensors/energy/"
+    ]
+}
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index 7636e94..342c028 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -7,6 +7,7 @@
 #include "platform_manager.hpp"
 #include "requester/handler.hpp"
 #include "requester/mctp_endpoint_discovery.hpp"
+#include "sensor_manager.hpp"
 #include "terminus_manager.hpp"
 
 namespace pldm
@@ -33,7 +34,8 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
     explicit Manager(sdeventplus::Event& event, RequesterHandler& handler,
                      pldm::InstanceIdDb& instanceIdDb) :
         terminusManager(event, handler, instanceIdDb, termini, this),
-        platformManager(terminusManager, termini)
+        platformManager(terminusManager, termini),
+        sensorManager(event, terminusManager, termini)
     {}
 
     /** @brief Helper function to do the actions before discovering terminus
@@ -68,6 +70,20 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         terminusManager.removeMctpTerminus(mctpInfos);
     }
 
+    /** @brief Helper function to start sensor polling of the terminus TID
+     */
+    void startSensorPolling(pldm_tid_t tid)
+    {
+        sensorManager.startPolling(tid);
+    }
+
+    /** @brief Helper function to stop sensor polling of the terminus TID
+     */
+    void stopSensorPolling(pldm_tid_t tid)
+    {
+        sensorManager.stopPolling(tid);
+    }
+
   private:
     /** @brief List of discovered termini */
     TerminiMapper termini{};
@@ -77,6 +93,9 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
 
     /** @brief Platform interface for calling the hook functions */
     PlatformManager platformManager;
+
+    /** @brief Store platform manager handler */
+    SensorManager sensorManager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/numeric_sensor.cpp b/platform-mc/numeric_sensor.cpp
index be7ece3..fdda328 100644
--- a/platform-mc/numeric_sensor.cpp
+++ b/platform-mc/numeric_sensor.cpp
@@ -581,5 +581,151 @@ double NumericSensor::unitModifier(double value)
 {
     return std::isnan(value) ? value : value * std::pow(10, baseUnitModifier);
 }
+
+void NumericSensor::updateReading(bool available, bool functional, double value)
+{
+    availabilityIntf->available(available);
+    operationalStatusIntf->functional(functional);
+    double curValue = valueIntf->value();
+    double newValue = std::numeric_limits<double>::quiet_NaN();
+    if (functional && available)
+    {
+        newValue = unitModifier(conversionFormula(value));
+        if (curValue != newValue)
+        {
+            valueIntf->value(unitModifier(conversionFormula(value)));
+            updateThresholds();
+        }
+    }
+    else
+    {
+        if (curValue != newValue)
+        {
+            valueIntf->value(std::numeric_limits<double>::quiet_NaN());
+        }
+    }
+}
+
+void NumericSensor::handleErrGetSensorReading()
+{
+    operationalStatusIntf->functional(false);
+    valueIntf->value(std::numeric_limits<double>::quiet_NaN());
+}
+
+bool NumericSensor::checkThreshold(bool alarm, bool direction, double value,
+                                   double threshold, double hyst)
+{
+    if (direction)
+    {
+        if (value >= threshold)
+        {
+            return true;
+        }
+        else if (value < (threshold - hyst))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        if (value <= threshold)
+        {
+            return true;
+        }
+        else if (value > (threshold + hyst))
+        {
+            return false;
+        }
+    }
+    return alarm;
+}
+
+void NumericSensor::updateThresholds()
+{
+    auto value = valueIntf->value();
+
+    if (thresholdWarningIntf &&
+        !std::isnan(thresholdWarningIntf->warningHigh()))
+    {
+        auto threshold = thresholdWarningIntf->warningHigh();
+        auto alarm = thresholdWarningIntf->warningAlarmHigh();
+        auto newAlarm = checkThreshold(alarm, true, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdWarningIntf->warningAlarmHigh(newAlarm);
+            if (newAlarm)
+            {
+                thresholdWarningIntf->warningHighAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdWarningIntf->warningHighAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdWarningIntf && !std::isnan(thresholdWarningIntf->warningLow()))
+    {
+        auto threshold = thresholdWarningIntf->warningLow();
+        auto alarm = thresholdWarningIntf->warningAlarmLow();
+        auto newAlarm = checkThreshold(alarm, false, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdWarningIntf->warningAlarmLow(newAlarm);
+            if (newAlarm)
+            {
+                thresholdWarningIntf->warningLowAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdWarningIntf->warningLowAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdCriticalIntf &&
+        !std::isnan(thresholdCriticalIntf->criticalHigh()))
+    {
+        auto threshold = thresholdCriticalIntf->criticalHigh();
+        auto alarm = thresholdCriticalIntf->criticalAlarmHigh();
+        auto newAlarm = checkThreshold(alarm, true, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdCriticalIntf->criticalAlarmHigh(newAlarm);
+            if (newAlarm)
+            {
+                thresholdCriticalIntf->criticalHighAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdCriticalIntf->criticalHighAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdCriticalIntf &&
+        !std::isnan(thresholdCriticalIntf->criticalLow()))
+    {
+        auto threshold = thresholdCriticalIntf->criticalLow();
+        auto alarm = thresholdCriticalIntf->criticalAlarmLow();
+        auto newAlarm = checkThreshold(alarm, false, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdCriticalIntf->criticalAlarmLow(newAlarm);
+            if (newAlarm)
+            {
+                thresholdCriticalIntf->criticalLowAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdCriticalIntf->criticalLowAlarmDeasserted(value);
+            }
+        }
+    }
+}
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/numeric_sensor.hpp b/platform-mc/numeric_sensor.hpp
index 315787d..ff9e286 100644
--- a/platform-mc/numeric_sensor.hpp
+++ b/platform-mc/numeric_sensor.hpp
@@ -54,6 +54,15 @@ class NumericSensor
 
     ~NumericSensor(){};
 
+    /** @brief The function called by Sensor Manager to set sensor to
+     * error status.
+     */
+    void handleErrGetSensorReading();
+
+    /** @brief Updating the sensor status to D-Bus interface
+     */
+    void updateReading(bool available, bool functional, double value = 0);
+
     /** @brief ConversionFormula is used to convert raw value to the unit
      * specified in PDR
      *
@@ -69,12 +78,103 @@ class NumericSensor
      */
     double unitModifier(double value);
 
+    /** @brief Check if value is over threshold.
+     *
+     *  @param[in] alarm - previous alarm state
+     *  @param[in] direction - upper or lower threshold checking
+     *  @param[in] value - raw value
+     *  @param[in] threshold - threshold value
+     *  @param[in] hyst - hysteresis value
+     *  @return bool - new alarm state
+     */
+    bool checkThreshold(bool alarm, bool direction, double value,
+                        double threshold, double hyst);
+
+    /** @brief Updating the association to D-Bus interface
+     *  @param[in] inventoryPath - inventory path of the entity
+     */
+    inline void setInventoryPath(const std::string& inventoryPath)
+    {
+        if (associationDefinitionsIntf)
+        {
+            associationDefinitionsIntf->associations(
+                {{"chassis", "all_sensors", inventoryPath.c_str()}});
+        }
+    }
+
+    /** @brief Get Upper Critical threshold
+     *
+     *  @return double - Upper Critical threshold
+     */
+    double getThresholdUpperCritical()
+    {
+        if (thresholdCriticalIntf)
+        {
+            return thresholdCriticalIntf->criticalHigh();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Lower Critical threshold
+     *
+     *  @return double - Lower Critical threshold
+     */
+    double getThresholdLowerCritical()
+    {
+        if (thresholdCriticalIntf)
+        {
+            return thresholdCriticalIntf->criticalLow();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Upper Warning threshold
+     *
+     *  @return double - Upper Warning threshold
+     */
+    double getThresholdUpperWarning()
+    {
+        if (thresholdWarningIntf)
+        {
+            return thresholdWarningIntf->warningHigh();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Lower Warning threshold
+     *
+     *  @return double - Lower Warning threshold
+     */
+    double getThresholdLowerWarning()
+    {
+        if (thresholdWarningIntf)
+        {
+            return thresholdWarningIntf->warningLow();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
     /** @brief Terminus ID which the sensor belongs to */
     pldm_tid_t tid;
 
     /** @brief Sensor ID */
     uint16_t sensorId;
 
+    /** @brief  The time stamp since last getSensorReading command in usec */
+    uint64_t timeStamp;
+
     /** @brief  The time of sensor update interval in usec */
     uint64_t updateTime;
 
@@ -88,6 +188,12 @@ class NumericSensor
     bool isPriority;
 
   private:
+    /**
+     * @brief Check sensor reading if any threshold has been crossed and update
+     * Threshold interfaces accordingly
+     */
+    void updateThresholds();
+
     std::unique_ptr<ValueIntf> valueIntf = nullptr;
     std::unique_ptr<ThresholdWarningIntf> thresholdWarningIntf = nullptr;
     std::unique_ptr<ThresholdCriticalIntf> thresholdCriticalIntf = nullptr;
diff --git a/platform-mc/sensor_manager.cpp b/platform-mc/sensor_manager.cpp
new file mode 100644
index 0000000..97fbf1d
--- /dev/null
+++ b/platform-mc/sensor_manager.cpp
@@ -0,0 +1,410 @@
+#include "sensor_manager.hpp"
+
+#include "terminus_manager.hpp"
+
+#include <phosphor-logging/lg2.hpp>
+
+#include <exception>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+SensorManager::SensorManager(sdeventplus::Event& event,
+                             TerminusManager& terminusManager,
+                             TerminiMapper& termini, bool verbose,
+                             const std::filesystem::path& configJson) :
+    event(event),
+    terminusManager(terminusManager), termini(termini),
+    pollingTime(SENSOR_POLLING_TIME), verbose(verbose)
+{
+    // default priority sensor name spaces
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/temperature/");
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/power/");
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/energy/");
+
+    if (!std::filesystem::exists(configJson))
+    {
+        return;
+    }
+
+    std::ifstream jsonFile(configJson);
+    auto data = nlohmann::json::parse(jsonFile, nullptr, false);
+    if (data.is_discarded())
+    {
+        lg2::error("Parsing json file failed. File path {FILE_PATH}",
+                   "FILE_PATH", std::string(configJson));
+        return;
+    }
+
+    // load priority sensor name spaces
+    const std::vector<std::string> emptyStringArray{};
+    auto nameSpaces = data.value("PrioritySensorNameSpaces", emptyStringArray);
+    if (nameSpaces.size() > 0)
+    {
+        prioritySensorNameSpaces.clear();
+        for (const auto& nameSpace : nameSpaces)
+        {
+            prioritySensorNameSpaces.emplace_back(nameSpace);
+        }
+    }
+}
+
+bool SensorManager::isPriority(std::shared_ptr<NumericSensor> sensor)
+{
+    return (std::find(prioritySensorNameSpaces.begin(),
+                      prioritySensorNameSpaces.end(),
+                      sensor->sensorNameSpace) !=
+            prioritySensorNameSpaces.end());
+}
+
+void SensorManager::startPolling(pldm_tid_t tid)
+{
+    // initialize prioritySensors and roundRobinSensors list
+    if (!termini.contains(tid))
+    {
+        return;
+    }
+    /* tid already initialize prioritySensors and roundRobinSensors list */
+    if (sensorPollTimers.contains(tid))
+    {
+        lg2::info("Terminus ID {TID}: sensor poll timer already exists.", "TID",
+                  tid);
+        return;
+    }
+    // numeric sensor
+    auto terminus = termini[tid];
+    for (auto& sensor : terminus->numericSensors)
+    {
+        if (isPriority(sensor))
+        {
+            sensor->isPriority = true;
+            prioritySensors[tid].emplace_back(sensor);
+        }
+        else
+        {
+            sensor->isPriority = false;
+            roundRobinSensors[tid].push(sensor);
+        }
+    }
+
+    if ((prioritySensors[tid].size() == 0) &&
+        (roundRobinSensors[tid].size() == 0))
+    {
+        lg2::info("Terminus ID {TID}: no sensor to polling.", "TID", tid);
+        return;
+    }
+
+    if (!sensorPollTimers.contains(tid))
+    {
+        sensorPollTimers[tid] = std::make_unique<sdbusplus::Timer>(
+            event.get(),
+            std::bind_front(&SensorManager::doSensorPolling, this, tid));
+    }
+
+    if (!sensorPollTimers[tid]->isRunning())
+    {
+        sensorPollTimers[tid]->start(
+            duration_cast<std::chrono::milliseconds>(
+                std::chrono::milliseconds(pollingTime)),
+            true);
+    }
+}
+
+void SensorManager::stopPolling(pldm_tid_t tid)
+{
+    /* Stop polling timer */
+    if (sensorPollTimers.contains(tid))
+    {
+        sensorPollTimers[tid]->stop();
+        sensorPollTimers.erase(tid);
+    }
+
+    if (prioritySensors.contains(tid))
+    {
+        prioritySensors[tid].clear();
+        prioritySensors.erase(tid);
+    }
+
+    if (roundRobinSensors.contains(tid))
+    {
+        while (!roundRobinSensors[tid].empty())
+        {
+            roundRobinSensors[tid].pop();
+        }
+        roundRobinSensors.erase(tid);
+    }
+
+    if (doSensorPollingTaskHandles.contains(tid))
+    {
+        auto& [scope, rcOpt] = doSensorPollingTaskHandles[tid];
+        scope.request_stop();
+        stdexec::sync_wait(scope.on_empty());
+        doSensorPollingTaskHandles.erase(tid);
+    }
+}
+
+void SensorManager::doSensorPolling(pldm_tid_t tid)
+{
+    if (auto it = doSensorPollingTaskHandles.find(tid);
+        it != doSensorPollingTaskHandles.end())
+    {
+        auto& [scope, rcOpt] = it->second;
+        if (!rcOpt.has_value())
+        {
+            return;
+        }
+        stdexec::sync_wait(scope.on_empty());
+        doSensorPollingTaskHandles.erase(tid);
+    }
+
+    auto& [scope, rcOpt] = doSensorPollingTaskHandles
+                               .emplace(std::piecewise_construct,
+                                        std::forward_as_tuple(tid),
+                                        std::forward_as_tuple())
+                               .first->second;
+    scope.spawn(stdexec::just() |
+                    stdexec::let_value([this, &rcOpt, tid] -> exec::task<void> {
+        auto res =
+            co_await stdexec::stopped_as_optional(doSensorPollingTask(tid));
+        if (res.has_value())
+        {
+            rcOpt = *res;
+        }
+        else
+        {
+            lg2::info("Stopped sensor polling for Terminus ID {TID}", "TID",
+                      tid);
+            rcOpt = PLDM_SUCCESS;
+        }
+    }),
+                exec::default_task_context<void>());
+}
+
+exec::task<int> SensorManager::doSensorPollingTask(pldm_tid_t tid)
+{
+    uint64_t t0 = 0;
+    uint64_t t1 = 0;
+    uint64_t elapsed = 0;
+    uint64_t pollingTimeInUsec = pollingTime * 1000;
+    uint8_t rc = PLDM_SUCCESS;
+
+    do
+    {
+        if ((!sensorPollTimers.contains(tid)) ||
+            (sensorPollTimers[tid] && !sensorPollTimers[tid]->isRunning()))
+        {
+            co_return PLDM_ERROR;
+        }
+
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t0);
+        if (verbose)
+        {
+            lg2::info("Terminus ID {TID}: start sensor polling at {NOW}.",
+                      "TID", tid, "NOW", pldm::utils::getCurrentSystemTime());
+        }
+
+        if (!termini.contains(tid))
+        {
+            co_return PLDM_SUCCESS;
+        }
+
+        // poll priority Sensors
+        for (auto& sensor : prioritySensors[tid])
+        {
+            if (sensor->updateTime == std::numeric_limits<uint64_t>::max())
+            {
+                continue;
+            }
+
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - sensor->timeStamp;
+            if (sensor->updateTime <= elapsed)
+            {
+                rc = co_await getSensorReading(sensor);
+
+                if ((!sensorPollTimers.contains(tid)) ||
+                    (sensorPollTimers[tid] &&
+                     !sensorPollTimers[tid]->isRunning()))
+                {
+                    co_return PLDM_ERROR;
+                }
+                sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+                if (rc == PLDM_SUCCESS)
+                {
+                    sensor->timeStamp = t1;
+                }
+            }
+        }
+
+        // poll roundRobin Sensors
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+        auto toBeUpdated = roundRobinSensors[tid].size();
+        while (((t1 - t0) < pollingTimeInUsec) && (toBeUpdated > 0))
+        {
+            auto sensor = roundRobinSensors[tid].front();
+
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - sensor->timeStamp;
+            if (sensor->updateTime <= elapsed)
+            {
+                rc = co_await getSensorReading(sensor);
+
+                if ((!sensorPollTimers.contains(tid)) ||
+                    (sensorPollTimers[tid] &&
+                     !sensorPollTimers[tid]->isRunning()))
+                {
+                    co_return PLDM_ERROR;
+                }
+                sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+                if (rc == PLDM_SUCCESS)
+                {
+                    sensor->timeStamp = t1;
+                }
+                else
+                {
+                    lg2::error(
+                        "Failed to get sensor value for terminus {TID}, error: {RC}",
+                        "TID", tid, "RC", rc);
+                }
+            }
+
+            toBeUpdated--;
+            if (roundRobinSensors.contains(tid))
+            {
+                roundRobinSensors[tid].pop();
+                roundRobinSensors[tid].push(std::move(sensor));
+            }
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+        }
+
+        if (verbose)
+        {
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            lg2::info("end sensor polling at '{END}'. duration(us):'{DELTA}'",
+                      "END", pldm::utils::getCurrentSystemTime(), "DELTA",
+                      t1 - t0);
+        }
+
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+    } while ((t1 - t0) >= pollingTimeInUsec);
+
+    co_return PLDM_SUCCESS;
+}
+
+exec::task<int>
+    SensorManager::getSensorReading(std::shared_ptr<NumericSensor> sensor)
+{
+    auto tid = sensor->tid;
+    auto sensorId = sensor->sensorId;
+    Request request(sizeof(pldm_msg_hdr) + PLDM_GET_SENSOR_READING_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_get_sensor_reading_req(0, sensorId, false, requestMsg);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to encode request GetSensorReading for terminus ID {TID}, sensor Id {ID}, error {RC}.",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = nullptr;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.sendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to send GetSensorReading message for terminus {TID}, sensor Id {ID}, error {RC}",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        co_return rc;
+    }
+
+    if ((!sensorPollTimers.contains(tid)) ||
+        (sensorPollTimers[tid] && !sensorPollTimers[tid]->isRunning()))
+    {
+        co_return PLDM_ERROR;
+    }
+
+    uint8_t completionCode = PLDM_SUCCESS;
+    uint8_t sensorDataSize = PLDM_SENSOR_DATA_SIZE_SINT32;
+    uint8_t sensorOperationalState = 0;
+    uint8_t sensorEventMessageEnable = 0;
+    uint8_t presentState = 0;
+    uint8_t previousState = 0;
+    uint8_t eventState = 0;
+    union_sensor_data_size presentReading;
+    rc = decode_get_sensor_reading_resp(
+        responseMsg, responseLen, &completionCode, &sensorDataSize,
+        &sensorOperationalState, &sensorEventMessageEnable, &presentState,
+        &previousState, &eventState,
+        reinterpret_cast<uint8_t*>(&presentReading));
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode response GetSensorReading for terminus ID {TID}, sensor Id {ID}, error {RC}.",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        sensor->handleErrGetSensorReading();
+        co_return rc;
+    }
+
+    if (completionCode != PLDM_SUCCESS)
+    {
+        lg2::error(
+            "Error : GetSensorReading for terminus ID {TID}, sensor Id {ID}, complete code {CC}.",
+            "TID", tid, "ID", sensorId, "CC", completionCode);
+        co_return completionCode;
+    }
+
+    double value = std::numeric_limits<double>::quiet_NaN();
+    switch (sensorOperationalState)
+    {
+        case PLDM_SENSOR_ENABLED:
+            break;
+        case PLDM_SENSOR_DISABLED:
+            sensor->updateReading(true, false, value);
+            co_return completionCode;
+        case PLDM_SENSOR_FAILED:
+            sensor->updateReading(false, true, value);
+            co_return completionCode;
+        case PLDM_SENSOR_UNAVAILABLE:
+        default:
+            sensor->updateReading(false, false, value);
+            co_return completionCode;
+    }
+
+    switch (sensorDataSize)
+    {
+        case PLDM_SENSOR_DATA_SIZE_UINT8:
+            value = static_cast<double>(presentReading.value_u8);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT8:
+            value = static_cast<double>(presentReading.value_s8);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT16:
+            value = static_cast<double>(presentReading.value_u16);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT16:
+            value = static_cast<double>(presentReading.value_s16);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT32:
+            value = static_cast<double>(presentReading.value_u32);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT32:
+            value = static_cast<double>(presentReading.value_s32);
+            break;
+        default:
+            value = std::numeric_limits<double>::quiet_NaN();
+            break;
+    }
+
+    sensor->updateReading(true, true, value);
+    co_return completionCode;
+}
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/sensor_manager.hpp b/platform-mc/sensor_manager.hpp
new file mode 100644
index 0000000..861a3d4
--- /dev/null
+++ b/platform-mc/sensor_manager.hpp
@@ -0,0 +1,117 @@
+#pragma once
+
+#include "libpldm/platform.h"
+#include "libpldm/pldm.h"
+
+#include "common/types.hpp"
+#include "requester/handler.hpp"
+#include "terminus.hpp"
+#include "terminus_manager.hpp"
+
+#include <map>
+#include <memory>
+#include <optional>
+#include <utility>
+#include <vector>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+/**
+ * @brief SensorManager
+ *
+ * This class manages the sensors found in terminus and provides
+ * function calls for other classes to start/stop sensor monitoring.
+ *
+ */
+class SensorManager
+{
+  public:
+    SensorManager() = delete;
+    SensorManager(const SensorManager&) = delete;
+    SensorManager(SensorManager&&) = delete;
+    SensorManager& operator=(const SensorManager&) = delete;
+    SensorManager& operator=(SensorManager&&) = delete;
+    virtual ~SensorManager() = default;
+
+    explicit SensorManager(
+        sdeventplus::Event& event, TerminusManager& terminusManager,
+        TerminiMapper& termini, bool verbose = false,
+        const std::filesystem::path& configJson = PLDM_T2_CONFIG_JSON);
+
+    /** @brief starting sensor polling task
+     */
+    void startPolling(pldm_tid_t tid);
+
+    /** @brief stopping sensor polling task
+     */
+    void stopPolling(pldm_tid_t tid);
+
+  protected:
+    /** @brief start a coroutine for polling all sensors.
+     */
+    virtual void doSensorPolling(pldm_tid_t tid);
+
+    /** @brief polling all sensors in each terminus
+     *
+     *  @param[in] tid - Destination TID
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> doSensorPollingTask(pldm_tid_t tid);
+
+    /** @brief Sending getSensorReading command for the sensor
+     *
+     *  @param[in] sensor - the sensor to be updated
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> getSensorReading(std::shared_ptr<NumericSensor> sensor);
+
+    /** @brief check if numeric sensor is in priority name spaces
+     *
+     *  @param[in] sensor - the sensor to be checked
+     *
+     *  @return bool - true:is in priority
+     */
+    bool isPriority(std::shared_ptr<NumericSensor> sensor);
+
+    /** @brief Reference to to PLDM daemon's main event loop.
+     */
+    sdeventplus::Event& event;
+
+    /** @brief reference of terminusManager */
+    TerminusManager& terminusManager;
+
+    /** @brief List of discovered termini */
+    TerminiMapper& termini;
+
+    /** @brief sensor polling interval in ms. */
+    uint32_t pollingTime;
+
+    /** @brief sensor polling timers */
+    std::map<pldm_tid_t, std::unique_ptr<sdbusplus::Timer>> sensorPollTimers;
+
+    /** @brief coroutine handle of doSensorPollingTasks */
+    std::map<pldm_tid_t, std::pair<exec::async_scope, std::optional<int>>>
+        doSensorPollingTaskHandles;
+
+    /** @brief force stop polling sensors*/
+    bool forceStopPolling = false;
+
+    /** @brief verbose tracing flag */
+    bool verbose;
+
+    /** @brief priority SensorNameSpace list */
+    std::vector<std::string> prioritySensorNameSpaces;
+
+    /** @brief priority sensor list */
+    std::map<pldm_tid_t, std::vector<std::shared_ptr<NumericSensor>>>
+        prioritySensors;
+
+    /** @brief round robin sensor list */
+    std::map<pldm_tid_t, std::queue<std::shared_ptr<NumericSensor>>>
+        roundRobinSensors;
+};
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/terminus.cpp b/platform-mc/terminus.cpp
index 5b2ab3c..8be6139 100644
--- a/platform-mc/terminus.cpp
+++ b/platform-mc/terminus.cpp
@@ -15,7 +15,22 @@ namespace platform_mc
 
 Terminus::Terminus(pldm_tid_t tid, uint64_t supportedTypes) :
     initialized(false), tid(tid), supportedTypes(supportedTypes)
-{}
+{
+    inventoryPath = "/xyz/openbmc_project/inventory/Item/Board/PLDM_Device_" +
+                    std::to_string(tid);
+    try
+    {
+        inventoryItemBoardInft = std::make_unique<InventoryItemBoardIntf>(
+            utils::DBusHandler::getBus(), inventoryPath.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Inventory Board interface for device {PATH}",
+            "PATH", inventoryPath);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+}
 
 bool Terminus::doesSupportType(uint8_t type)
 {
@@ -372,6 +387,8 @@ std::shared_ptr<pldm_numeric_sensor_value_pdr>
     auto rc = decode_numeric_sensor_pdr_data(ptr, pdr.size(), parsedPdr.get());
     if (rc)
     {
+        lg2::error("Failed to decode Numeric Sensor PDR data, error {RC} ",
+                   "RC", rc);
         return nullptr;
     }
     return parsedPdr;
diff --git a/platform-mc/terminus_manager.cpp b/platform-mc/terminus_manager.cpp
index 93fdb09..4401bef 100644
--- a/platform-mc/terminus_manager.cpp
+++ b/platform-mc/terminus_manager.cpp
@@ -161,6 +161,7 @@ TerminiMapper::iterator
 
 exec::task<int> TerminusManager::discoverMctpTerminusTask()
 {
+    std::vector<pldm_tid_t> addedTids;
     while (!queuedMctpInfos.empty())
     {
         if (manager)
@@ -176,11 +177,23 @@ exec::task<int> TerminusManager::discoverMctpTerminusTask()
             {
                 co_await initMctpTerminus(mctpInfo);
             }
+
+            /* Get TID of initialized terminus */
+            auto tid = toTid(mctpInfo);
+            if (!tid)
+            {
+                co_return PLDM_ERROR;
+            }
+            addedTids.push_back(tid.value());
         }
 
         if (manager)
         {
             co_await manager->afterDiscoverTerminus();
+            for (auto& tid : addedTids)
+            {
+                manager->startSensorPolling(tid);
+            }
         }
 
         queuedMctpInfos.pop();
@@ -200,6 +213,11 @@ void TerminusManager::removeMctpTerminus(const MctpInfos& mctpInfos)
             continue;
         }
 
+        if (manager)
+        {
+            manager->stopSensorPolling(it->second->getTid());
+        }
+
         unmapTid(it->first);
         termini.erase(it);
     }
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index 6b95f90..64177cc 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -4,6 +4,7 @@ test_src = declare_dependency(
             '../terminus.cpp',
             '../platform_manager.cpp',
             '../manager.cpp',
+            '../sensor_manager.cpp',
             '../numeric_sensor.cpp',
             '../../requester/mctp_endpoint_discovery.cpp'],
             include_directories: ['../../requester', '../../pldmd'])
@@ -12,6 +13,8 @@ tests = [
   'terminus_manager_test',
   'terminus_test',
   'platform_manager_test',
+  'sensor_manager_test',
+  'numeric_sensor_test',
 ]
 
 foreach t : tests
diff --git a/platform-mc/test/mock_sensor_manager.hpp b/platform-mc/test/mock_sensor_manager.hpp
new file mode 100644
index 0000000..2c2ea1b
--- /dev/null
+++ b/platform-mc/test/mock_sensor_manager.hpp
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "platform-mc/sensor_manager.hpp"
+
+#include <gmock/gmock.h>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+class MockSensorManager : public SensorManager
+{
+  public:
+    MockSensorManager(sdeventplus::Event& event,
+                      TerminusManager& terminusManager,
+                      TerminiMapper& termini) :
+        SensorManager(event, terminusManager, termini){};
+
+    MOCK_METHOD(void, doSensorPolling, (pldm_tid_t tid), (override));
+};
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/test/numeric_sensor_test.cpp b/platform-mc/test/numeric_sensor_test.cpp
new file mode 100644
index 0000000..8b59401
--- /dev/null
+++ b/platform-mc/test/numeric_sensor_test.cpp
@@ -0,0 +1,272 @@
+
+#include "libpldm/entity.h"
+#include "libpldm/platform.h"
+
+#include "platform-mc/numeric_sensor.hpp"
+#include "platform-mc/terminus.hpp"
+
+#include <gtest/gtest.h>
+
+TEST(NumericSensor, conversionFormula)
+{
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    auto numericSensorPdr = std::make_shared<pldm_numeric_sensor_value_pdr>();
+    std::printf("pdr size=%ld\n", pdr1.size());
+    auto rc = decode_numeric_sensor_pdr_data(pdr1.data(), pdr1.size(),
+                                             numericSensorPdr.get());
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    std::string sensorName{"test1"};
+    std::string inventoryPath{
+        "/xyz/openbmc_project/inventroy/Item/Board/PLDM_device_1"};
+    pldm::platform_mc::NumericSensor sensor(0x01, true, numericSensorPdr,
+                                            sensorName, inventoryPath);
+    double reading = 40.0;
+    double convertedValue = 0;
+    convertedValue = sensor.conversionFormula(reading);
+    convertedValue = sensor.unitModifier(convertedValue);
+
+    // (40*1.5 + 1.0 ) * 10^1 = 610
+    EXPECT_EQ(610, convertedValue);
+}
+
+TEST(NumericSensor, checkThreshold)
+{
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    auto numericSensorPdr = std::make_shared<pldm_numeric_sensor_value_pdr>();
+    auto rc = decode_numeric_sensor_pdr_data(pdr1.data(), pdr1.size(),
+                                             numericSensorPdr.get());
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+    std::string sensorName{"test1"};
+    std::string inventoryPath{
+        "/xyz/openbmc_project/inventroy/Item/Board/PLDM_device_1"};
+    pldm::platform_mc::NumericSensor sensor(0x01, true, numericSensorPdr,
+                                            sensorName, inventoryPath);
+
+    bool highAlarm = false;
+    bool lowAlarm = false;
+    double highThreshold = 40;
+    double lowThreshold = 30;
+    double hysteresis = 2;
+
+    // reading     35->40->45->38->35->30->25->32->35
+    // highAlarm    F->T ->T ->T ->F ->F ->F -> F-> F
+    // lowAlarm     F->F ->F ->F ->F ->T ->T -> T ->F
+    double reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 40;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 45;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 38;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 30;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 25;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 32;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+}
diff --git a/platform-mc/test/platform_manager_test.cpp b/platform-mc/test/platform_manager_test.cpp
index 8afad35..0b4c1a3 100644
--- a/platform-mc/test/platform_manager_test.cpp
+++ b/platform-mc/test/platform_manager_test.cpp
@@ -150,6 +150,7 @@ TEST_F(PlatformManagerTest, initTerminusTest)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(1, terminus->pdrs.size());
+    EXPECT_EQ(1, terminus->numericSensors.size());
 }
 
 TEST_F(PlatformManagerTest, parseTerminusNameTest)
@@ -440,6 +441,7 @@ TEST_F(PlatformManagerTest, negativeInitTerminusTest1)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(0, terminus->pdrs.size());
+    EXPECT_EQ(0, terminus->numericSensors.size());
 }
 
 TEST_F(PlatformManagerTest, negativeInitTerminusTest2)
@@ -471,4 +473,5 @@ TEST_F(PlatformManagerTest, negativeInitTerminusTest2)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(0, terminus->pdrs.size());
+    EXPECT_EQ(0, terminus->numericSensors.size());
 }
diff --git a/platform-mc/test/sensor_manager_test.cpp b/platform-mc/test/sensor_manager_test.cpp
new file mode 100644
index 0000000..89c147e
--- /dev/null
+++ b/platform-mc/test/sensor_manager_test.cpp
@@ -0,0 +1,147 @@
+#include "common/instance_id.hpp"
+#include "common/types.hpp"
+#include "mock_sensor_manager.hpp"
+#include "platform-mc/terminus_manager.hpp"
+#include "test/test_instance_id.hpp"
+
+#include <sdeventplus/event.hpp>
+
+#include <gtest/gtest.h>
+
+using ::testing::_;
+using ::testing::Between;
+using ::testing::Return;
+
+class SensorManagerTest : public testing::Test
+{
+  protected:
+    SensorManagerTest() :
+        bus(pldm::utils::DBusHandler::getBus()),
+        event(sdeventplus::Event::get_default()), instanceIdDb(),
+        reqHandler(pldmTransport, event, instanceIdDb, false),
+        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        sensorManager(event, terminusManager, termini)
+    {}
+
+    void runEventLoopForSeconds(uint64_t sec)
+    {
+        uint64_t t0 = 0;
+        uint64_t t1 = 0;
+        uint64_t usec = sec * 1000000;
+        uint64_t elapsed = 0;
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t0);
+        do
+        {
+            if (!sd_event_run(event.get(), usec - elapsed))
+            {
+                break;
+            }
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - t0;
+        } while (elapsed < usec);
+    }
+
+    PldmTransport* pldmTransport = nullptr;
+    sdbusplus::bus::bus& bus;
+    sdeventplus::Event event;
+    TestInstanceIdDb instanceIdDb;
+    pldm::requester::Handler<pldm::requester::Request> reqHandler;
+    pldm::platform_mc::TerminusManager terminusManager;
+    pldm::platform_mc::MockSensorManager sensorManager;
+    std::map<pldm_tid_t, std::shared_ptr<pldm::platform_mc::Terminus>> termini;
+
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+};
+
+TEST_F(SensorManagerTest, sensorPollingTest)
+{
+    uint64_t seconds = 10;
+    uint64_t expectedTimes = (seconds * 1000) / SENSOR_POLLING_TIME;
+
+    pldm_tid_t tid = 1;
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(tid, 0);
+    termini[tid]->pdrs.push_back(pdr1);
+    termini[tid]->parseTerminusPDRs();
+
+    EXPECT_CALL(sensorManager, doSensorPolling(tid))
+        .Times(Between(expectedTimes - 3, expectedTimes + 3))
+        .WillRepeatedly(Return());
+
+    sensorManager.startPolling(tid);
+
+    runEventLoopForSeconds(seconds);
+
+    sensorManager.stopPolling(tid);
+}
diff --git a/pldmd/pldmd.cpp b/pldmd/pldmd.cpp
index 39e1213..e5cc47c 100644
--- a/pldmd/pldmd.cpp
+++ b/pldmd/pldmd.cpp
@@ -195,7 +195,7 @@ int main(int argc, char** argv)
     auto event = Event::get_default();
     auto& bus = pldm::utils::DBusHandler::getBus();
     sdbusplus::server::manager_t objManager(bus,
-                                            "/xyz/openbmc_project/software");
+                                            "/xyz/openbmc_project/sensors");
 
     InstanceIdDb instanceIdDb;
     dbus_api::Requester dbusImplReq(bus, "/xyz/openbmc_project/pldm",
-- 
2.43.5

