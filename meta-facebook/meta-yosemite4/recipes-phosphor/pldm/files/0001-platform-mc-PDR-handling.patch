From 98eb03497e23d28a27b7d97df876837de1a66dde Mon Sep 17 00:00:00 2001
From: Gilbert Chen <gilbert.chen@arm.com>
Date: Tue, 24 May 2022 15:35:21 +0100
Subject: [PATCH 1/8] platform-mc: PDR handling

Get PDRs of new terminus if it supports GetPDR PLDM command. It doesn't
handle the event receiver related initialization steps, and either
doesn't support primary PDR repository to maintain terminus locator PDR
information yet.
Added parse PDR member functions to terminus class for parsing Numeric
sensor PDR and sensor auxiliary names PDR.
Added sensor auxiliary names PDR and numeric sensor PDR struct in
libpldm/platform.h

Signed-off-by: Gilbert Chen <gilbert.chen@arm.com>
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Change-Id: I30a0cc594a3c08fc17f2dad861b5c5d41c80ebdd
---
 platform-mc/platform_manager.cpp           | 241 ++++++++++++++++
 platform-mc/platform_manager.hpp           |  49 ++++
 platform-mc/terminus.cpp                   | 198 +++++++++++++
 platform-mc/terminus.hpp                   |  61 ++++
 platform-mc/test/meson.build               |   1 +
 platform-mc/test/platform_manager_test.cpp | 316 +++++++++++++++++++++
 platform-mc/test/terminus_test.cpp         |  59 ++++
 7 files changed, 925 insertions(+)
 create mode 100644 platform-mc/test/platform_manager_test.cpp

diff --git a/platform-mc/platform_manager.cpp b/platform-mc/platform_manager.cpp
index e1d7f96..9ff3bdf 100644
--- a/platform-mc/platform_manager.cpp
+++ b/platform-mc/platform_manager.cpp
@@ -20,9 +20,250 @@ exec::task<int> PlatformManager::initTerminus()
             continue;
         }
         terminus->initialized = true;
+
+        if (terminus->doesSupportCommand(PLDM_PLATFORM, PLDM_GET_PDR))
+        {
+            auto rc = co_await getPDRs(terminus);
+            if (rc)
+            {
+                lg2::error(
+                    "Failed to fetch PDRs for terminus with TID: {TID}, error: {ERROR}",
+                    "TID", tid, "ERROR", rc);
+                continue; // Continue to next terminus
+            }
+            // Continue to next steps event the parsing PDR is failed at some
+            // records
+            if (!terminus->parsePDRs())
+            {
+                lg2::error(
+                    "Failed to parse PDRs for terminus with TID: {TID}, error: {ERROR}",
+                    "TID", tid, "ERROR", rc);
+            }
+        }
     }
     co_return PLDM_SUCCESS;
 }
 
+exec::task<int> PlatformManager::getPDRs(std::shared_ptr<Terminus> terminus)
+{
+    pldm_tid_t tid = terminus->getTid();
+
+    uint8_t repositoryState = 0;
+    uint32_t recordCount = 0;
+    uint32_t repositorySize = 0;
+    uint32_t largestRecordSize = 0;
+    auto rc = co_await getPDRRepositoryInfo(tid, repositoryState, recordCount,
+                                            repositorySize, largestRecordSize);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to get PDR Repository Info for terminus with TID: {TID}, error: {ERROR}",
+            "TID", tid, "ERROR", rc);
+        repositoryState = PLDM_AVAILABLE;
+        recordCount = std::numeric_limits<uint32_t>::max();
+        largestRecordSize = std::numeric_limits<uint32_t>::max();
+    }
+    else
+    {
+        recordCount = std::min(recordCount + 1,
+                               std::numeric_limits<uint32_t>::max());
+        largestRecordSize = std::min(largestRecordSize + 1,
+                                     std::numeric_limits<uint32_t>::max());
+    }
+
+    if (repositoryState != PLDM_AVAILABLE)
+    {
+        co_return PLDM_ERROR_NOT_READY;
+    }
+
+    uint32_t recordHndl = 0;
+    uint32_t nextRecordHndl = 0;
+    uint32_t nextDataTransferHndl = 0;
+    uint8_t transferFlag = 0;
+    uint16_t responseCnt = 0;
+    constexpr uint16_t recvBufSize = 1024;
+    std::vector<uint8_t> recvBuf(recvBufSize);
+    uint8_t transferCrc = 0;
+
+    terminus->pdrs.clear();
+    uint32_t receivedRecordCount = 0;
+
+    do
+    {
+        rc = co_await getPDR(tid, recordHndl, 0, PLDM_GET_FIRSTPART,
+                             recvBufSize, 0, nextRecordHndl,
+                             nextDataTransferHndl, transferFlag, responseCnt,
+                             recvBuf, transferCrc);
+
+        if (rc)
+        {
+            lg2::error(
+                "Failed to get PDRs for terminus {TID}, error: {RC}, first part of record handle {RECORD}",
+                "TID", tid, "RC", rc, "RECORD", recordHndl);
+            terminus->pdrs.clear();
+            co_return rc;
+        }
+
+        if (transferFlag == PLDM_START_AND_END)
+        {
+            // single-part
+            terminus->pdrs.emplace_back(std::vector<uint8_t>(
+                recvBuf.begin(), recvBuf.begin() + responseCnt));
+            recordHndl = nextRecordHndl;
+        }
+        else
+        {
+            // multipart transfer
+            uint32_t receivedRecordSize = responseCnt;
+            auto pdrHdr = reinterpret_cast<pldm_pdr_hdr*>(recvBuf.data());
+            uint16_t recordChgNum = le16toh(pdrHdr->record_change_num);
+            std::vector<uint8_t> receivedPdr(recvBuf.begin(),
+                                             recvBuf.begin() + responseCnt);
+            do
+            {
+                rc = co_await getPDR(tid, recordHndl, nextDataTransferHndl,
+                                     PLDM_GET_NEXTPART, recvBufSize,
+                                     recordChgNum, nextRecordHndl,
+                                     nextDataTransferHndl, transferFlag,
+                                     responseCnt, recvBuf, transferCrc);
+                if (rc)
+                {
+                    lg2::error(
+                        "Failed to get PDRs for terminus {TID}, error: {RC}, get middle part of record handle {RECORD}",
+                        "TID", tid, "RC", rc, "RECORD", recordHndl);
+                    terminus->pdrs.clear();
+                    co_return rc;
+                }
+
+                receivedPdr.insert(receivedPdr.end(), recvBuf.begin(),
+                                   recvBuf.begin() + responseCnt);
+                receivedRecordSize += responseCnt;
+
+                if (transferFlag == PLDM_END)
+                {
+                    terminus->pdrs.emplace_back(std::move(receivedPdr));
+                    recordHndl = nextRecordHndl;
+                }
+            } while (nextDataTransferHndl != 0 &&
+                     receivedRecordSize < largestRecordSize);
+        }
+        receivedRecordCount++;
+    } while (nextRecordHndl != 0 && receivedRecordCount < recordCount);
+
+    co_return PLDM_SUCCESS;
+}
+
+exec::task<int> PlatformManager::getPDR(
+    const pldm_tid_t tid, const uint32_t recordHndl,
+    const uint32_t dataTransferHndl, const uint8_t transferOpFlag,
+    const uint16_t requestCnt, const uint16_t recordChgNum,
+    uint32_t& nextRecordHndl, uint32_t& nextDataTransferHndl,
+    uint8_t& transferFlag, uint16_t& responseCnt,
+    std::vector<uint8_t>& recordData, uint8_t& transferCrc)
+{
+    Request request(sizeof(pldm_msg_hdr) + PLDM_GET_PDR_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_get_pdr_req(0, recordHndl, dataTransferHndl,
+                                 transferOpFlag, requestCnt, recordChgNum,
+                                 requestMsg, PLDM_GET_PDR_REQ_BYTES);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to encode request GetPDR for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = nullptr;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.sendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to send GetPDR message for terminus {TID}, error {RC}",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    uint8_t completionCode;
+    rc = decode_get_pdr_resp(responseMsg, responseLen, &completionCode,
+                             &nextRecordHndl, &nextDataTransferHndl,
+                             &transferFlag, &responseCnt, recordData.data(),
+                             recordData.size(), &transferCrc);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode response GetPDR for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    if (completionCode != PLDM_SUCCESS)
+    {
+        lg2::error("Error : GetPDR for terminus ID {TID}, complete code {CC}.",
+                   "TID", tid, "CC", completionCode);
+        co_return rc;
+    }
+
+    co_return completionCode;
+}
+
+exec::task<int> PlatformManager::getPDRRepositoryInfo(
+    const pldm_tid_t tid, uint8_t& repositoryState, uint32_t& recordCount,
+    uint32_t& repositorySize, uint32_t& largestRecordSize)
+{
+    Request request(sizeof(pldm_msg_hdr) + sizeof(uint8_t));
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_pldm_header_only(PLDM_REQUEST, 0, PLDM_PLATFORM,
+                                      PLDM_GET_PDR_REPOSITORY_INFO, requestMsg);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to encode request GetPDRRepositoryInfo for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = nullptr;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.sendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to send GetPDRRepositoryInfo message for terminus {TID}, error {RC}",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    uint8_t completionCode = 0;
+    uint8_t updateTime[PLDM_TIMESTAMP104_SIZE] = {0};
+    uint8_t oemUpdateTime[PLDM_TIMESTAMP104_SIZE] = {0};
+    uint8_t dataTransferHandleTimeout = 0;
+
+    rc = decode_get_pdr_repository_info_resp(
+        responseMsg, responseLen, &completionCode, &repositoryState, updateTime,
+        oemUpdateTime, &recordCount, &repositorySize, &largestRecordSize,
+        &dataTransferHandleTimeout);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode response GetPDRRepositoryInfo for terminus ID {TID}, error {RC} ",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    if (completionCode != PLDM_SUCCESS)
+    {
+        lg2::error(
+            "Error : GetPDRRepositoryInfo for terminus ID {TID}, complete code {CC}.",
+            "TID", tid, "CC", completionCode);
+        co_return rc;
+    }
+
+    co_return completionCode;
+}
+
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/platform_manager.hpp b/platform-mc/platform_manager.hpp
index a7fd412..8187ca1 100644
--- a/platform-mc/platform_manager.hpp
+++ b/platform-mc/platform_manager.hpp
@@ -6,6 +6,8 @@
 #include "terminus.hpp"
 #include "terminus_manager.hpp"
 
+#include <vector>
+
 namespace pldm
 {
 
@@ -40,6 +42,53 @@ class PlatformManager
     exec::task<int> initTerminus();
 
   private:
+    /** @brief Fetch all PDRs from terminus.
+     *
+     *  @param[in] terminus - The terminus object to store fetched PDRs
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> getPDRs(std::shared_ptr<Terminus> terminus);
+
+    /** @brief Fetch PDR from terminus
+     *
+     *  @param[in] tid - Destination TID
+     *  @param[in] recordHndl - Record handle
+     *  @param[in] dataTransferHndl - Data transfer handle
+     *  @param[in] transferOpFlag - Transfer Operation Flag
+     *  @param[in] requstCnt - Request Count of data
+     *  @param[in] recordChgNum - Record change number
+     *  @param[out] nextRecordHndl - Next record handle
+     *  @param[out] nextDataTransferHndl - Next data transfer handle
+     *  @param[out] transferFlag - Transfer flag
+     *  @param[out] responseCnt - Response count of record data
+     *  @param[out] recordData - Returned record data
+     *  @param[out] transferCrc - CRC value when record data is last part of PDR
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int>
+        getPDR(const pldm_tid_t tid, const uint32_t recordHndl,
+               const uint32_t dataTransferHndl, const uint8_t transferOpFlag,
+               const uint16_t requestCnt, const uint16_t recordChgNum,
+               uint32_t& nextRecordHndl, uint32_t& nextDataTransferHndl,
+               uint8_t& transferFlag, uint16_t& responseCnt,
+               std::vector<uint8_t>& recordData, uint8_t& transferCrc);
+
+    /** @brief get PDR repository information.
+     *
+     *  @param[in] tid - Destination TID
+     *  @param[out] repositoryState - the state of repository
+     *  @param[out] recordCount - number of records
+     *  @param[out] repositorySize - repository size
+     *  @param[out] largestRecordSize - largest record size
+     * *
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> getPDRRepositoryInfo(const pldm_tid_t tid,
+                                         uint8_t& repositoryState,
+                                         uint32_t& recordCount,
+                                         uint32_t& repositorySize,
+                                         uint32_t& largestRecordSize);
+
     /** reference of TerminusManager for sending PLDM request to terminus*/
     TerminusManager& terminusManager;
 
diff --git a/platform-mc/terminus.cpp b/platform-mc/terminus.cpp
index 947571b..333813e 100644
--- a/platform-mc/terminus.cpp
+++ b/platform-mc/terminus.cpp
@@ -49,5 +49,203 @@ bool Terminus::doesSupportCommand(uint8_t type, uint8_t command)
     return false;
 }
 
+bool Terminus::parsePDRs()
+{
+    bool rc = true;
+    std::vector<std::shared_ptr<pldm_numeric_sensor_value_pdr>>
+        numericSensorPdrs{};
+    std::vector<std::shared_ptr<pldm_compact_numeric_sensor_pdr>>
+        compactNumericSensorPdrs{};
+
+    for (auto& pdr : pdrs)
+    {
+        auto pdrHdr = reinterpret_cast<pldm_pdr_hdr*>(pdr.data());
+        if (pdrHdr->type == PLDM_SENSOR_AUXILIARY_NAMES_PDR)
+        {
+            auto sensorAuxiliaryNames = parseSensorAuxiliaryNamesPDR(pdr);
+            sensorAuxiliaryNamesTbl.emplace_back(
+                std::move(sensorAuxiliaryNames));
+        }
+        else if (pdrHdr->type == PLDM_NUMERIC_SENSOR_PDR)
+        {
+            auto parsedPdr = parseNumericSensorPDR(pdr);
+            if (parsedPdr != nullptr)
+            {
+                numericSensorPdrs.emplace_back(std::move(parsedPdr));
+            }
+        }
+        else if (pdrHdr->type == PLDM_COMPACT_NUMERIC_SENSOR_PDR)
+        {
+            auto parsedPdr = parseCompactNumericSensorPDR(pdr);
+            if (parsedPdr != nullptr)
+            {
+                compactNumericSensorPdrs.emplace_back(std::move(parsedPdr));
+                auto sensorAuxiliaryNames = parseCompactNumericSensorNames(pdr);
+                if (sensorAuxiliaryNames != nullptr)
+                {
+                    sensorAuxiliaryNamesTbl.emplace_back(
+                        std::move(sensorAuxiliaryNames));
+                }
+            }
+        }
+        else
+        {
+            lg2::error("parsePDRs() Unsupported PDR with type {TYPE}", "TYPE",
+                       pdrHdr->type);
+            rc = false;
+        }
+    }
+    return rc;
+}
+
+std::shared_ptr<SensorAuxiliaryNames>
+    Terminus::getSensorAuxiliaryNames(SensorId id)
+{
+    for (auto sensorAuxiliaryNames : sensorAuxiliaryNamesTbl)
+    {
+        const auto& [sensorId, sensorCnt, sensorNames] = *sensorAuxiliaryNames;
+        if (sensorId == id)
+        {
+            return sensorAuxiliaryNames;
+        }
+    }
+    return nullptr;
+}
+
+std::shared_ptr<SensorAuxiliaryNames>
+    Terminus::parseSensorAuxiliaryNamesPDR(const std::vector<uint8_t>& pdrData)
+{
+    constexpr uint8_t nullTerminator = 0;
+    auto pdr = reinterpret_cast<const struct pldm_sensor_auxiliary_names_pdr*>(
+        pdrData.data());
+    const uint8_t* ptr = pdr->names;
+    std::vector<std::vector<std::pair<NameLanguageTag, SensorName>>>
+        sensorAuxNames{};
+    char16_t alignedBuffer[PLDM_STR_UTF_16_MAX_LEN];
+    for (int i = 0; i < pdr->sensor_count; i++)
+    {
+        const uint8_t nameStringCount = static_cast<uint8_t>(*ptr);
+        ptr += sizeof(uint8_t);
+        std::vector<std::pair<NameLanguageTag, SensorName>> nameStrings{};
+        for (int j = 0; j < nameStringCount; j++)
+        {
+            std::string nameLanguageTag(reinterpret_cast<const char*>(ptr), 0,
+                                        PLDM_STR_UTF_8_MAX_LEN);
+            ptr += nameLanguageTag.size() + sizeof(nullTerminator);
+
+            int u16NameStringLen = 0;
+            for (int i = 0; ptr[i] != 0 || ptr[i + 1] != 0; i += 2)
+            {
+                u16NameStringLen++;
+            }
+            memset(alignedBuffer, 0,
+                   PLDM_STR_UTF_16_MAX_LEN * sizeof(uint16_t));
+            memcpy(alignedBuffer, ptr, u16NameStringLen * sizeof(uint16_t));
+            std::u16string u16NameString(alignedBuffer, 0,
+                                         PLDM_STR_UTF_16_MAX_LEN);
+            ptr += (u16NameString.size() + sizeof(nullTerminator)) *
+                   sizeof(uint16_t);
+            std::transform(u16NameString.cbegin(), u16NameString.cend(),
+                           u16NameString.begin(),
+                           [](uint16_t utf16) { return be16toh(utf16); });
+            std::string nameString =
+                std::wstring_convert<std::codecvt_utf8_utf16<char16_t>,
+                                     char16_t>{}
+                    .to_bytes(u16NameString);
+            nameStrings.emplace_back(
+                std::make_pair(nameLanguageTag, nameString));
+        }
+        sensorAuxNames.emplace_back(nameStrings);
+    }
+    return std::make_shared<SensorAuxiliaryNames>(
+        pdr->sensor_id, pdr->sensor_count, sensorAuxNames);
+}
+
+std::shared_ptr<pldm_numeric_sensor_value_pdr>
+    Terminus::parseNumericSensorPDR(const std::vector<uint8_t>& pdr)
+{
+    const uint8_t* ptr = pdr.data();
+    auto parsedPdr = std::make_shared<pldm_numeric_sensor_value_pdr>();
+    auto rc = decode_numeric_sensor_pdr_data(ptr, pdr.size(), parsedPdr.get());
+    if (rc)
+    {
+        return nullptr;
+    }
+    return parsedPdr;
+}
+
+std::shared_ptr<SensorAuxiliaryNames>
+    Terminus::parseCompactNumericSensorNames(const std::vector<uint8_t>& sPdr)
+{
+    std::string nameString;
+    std::vector<std::vector<std::pair<NameLanguageTag, SensorName>>>
+        sensorAuxNames{};
+    std::vector<std::pair<NameLanguageTag, SensorName>> nameStrings{};
+    auto pdr =
+        reinterpret_cast<const pldm_compact_numeric_sensor_pdr*>(sPdr.data());
+
+    if (sPdr.size() <
+        (sizeof(pldm_compact_numeric_sensor_pdr) - sizeof(uint8_t)))
+    {
+        return nullptr;
+    }
+
+    if (pdr->sensor_name_length == 0)
+    {
+        return nullptr;
+    }
+
+    if (sPdr.size() < (sizeof(pldm_compact_numeric_sensor_pdr) -
+                       sizeof(uint8_t) + pdr->sensor_name_length))
+    {
+        return nullptr;
+    }
+
+    std::string sTemp(reinterpret_cast<const char*>(pdr->sensor_name),
+                      pdr->sensor_name_length);
+    size_t pos = 0;
+    while ((pos = sTemp.find(" ")) != std::string::npos)
+    {
+        sTemp.replace(pos, 1, "_");
+    }
+    nameString = sTemp;
+
+    nameString.erase(nameString.find('\0'));
+    nameStrings.emplace_back(std::make_pair("en", nameString));
+    sensorAuxNames.emplace_back(nameStrings);
+
+    return std::make_shared<SensorAuxiliaryNames>(pdr->sensor_id, 1,
+                                                  sensorAuxNames);
+}
+
+std::shared_ptr<pldm_compact_numeric_sensor_pdr>
+    Terminus::parseCompactNumericSensorPDR(const std::vector<uint8_t>& sPdr)
+{
+    std::string nameString;
+    std::vector<std::pair<NameLanguageTag, SensorName>> nameStrings{};
+    auto pdr =
+        reinterpret_cast<const pldm_compact_numeric_sensor_pdr*>(sPdr.data());
+    auto parsedPdr = std::make_shared<pldm_compact_numeric_sensor_pdr>();
+
+    parsedPdr->hdr = pdr->hdr;
+    parsedPdr->terminus_handle = pdr->terminus_handle;
+    parsedPdr->sensor_id = pdr->sensor_id;
+    parsedPdr->entity_type = pdr->entity_type;
+    parsedPdr->entity_instance = pdr->entity_instance;
+    parsedPdr->container_id = pdr->container_id;
+    parsedPdr->sensor_name_length = pdr->sensor_name_length;
+    parsedPdr->base_unit = pdr->base_unit;
+    parsedPdr->unit_modifier = pdr->unit_modifier;
+    parsedPdr->occurrence_rate = pdr->occurrence_rate;
+    parsedPdr->range_field_support = pdr->range_field_support;
+    parsedPdr->warning_high = pdr->warning_high;
+    parsedPdr->warning_low = pdr->warning_low;
+    parsedPdr->critical_high = pdr->critical_high;
+    parsedPdr->critical_low = pdr->critical_low;
+    parsedPdr->fatal_high = pdr->fatal_high;
+    parsedPdr->fatal_low = pdr->fatal_low;
+    return parsedPdr;
+}
+
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/terminus.hpp b/platform-mc/terminus.hpp
index 6957fb3..8fa4ea0 100644
--- a/platform-mc/terminus.hpp
+++ b/platform-mc/terminus.hpp
@@ -11,6 +11,9 @@
 
 #include <algorithm>
 #include <bitset>
+#include <string>
+#include <tuple>
+#include <utility>
 #include <vector>
 
 namespace pldm
@@ -18,6 +21,14 @@ namespace pldm
 namespace platform_mc
 {
 
+using SensorId = uint16_t;
+using SensorCnt = uint8_t;
+using NameLanguageTag = std::string;
+using SensorName = std::string;
+using SensorAuxiliaryNames = std::tuple<
+    SensorId, SensorCnt,
+    std::vector<std::vector<std::pair<NameLanguageTag, SensorName>>>>;
+
 /**
  * @brief Terminus
  *
@@ -68,6 +79,13 @@ class Terminus
 
         return true;
     }
+
+    /** @brief Parse the PDRs stored in the member variable, pdrs.
+     *
+     *  @return False if any unsupported PDR is detected.
+     */
+    bool parsePDRs();
+
     /** @brief The getter to return terminus's TID */
     pldm_tid_t getTid()
     {
@@ -80,7 +98,46 @@ class Terminus
     /** @brief A flag to indicate if terminus has been initialized */
     bool initialized = false;
 
+    /** @brief Get Sensor Auxiliary Names by sensorID
+     *
+     *  @param[in] id - sensor ID
+     *  @return sensor auxiliary names
+     */
+    std::shared_ptr<SensorAuxiliaryNames> getSensorAuxiliaryNames(SensorId id);
+
   private:
+    /** @brief Parse the numeric sensor PDRs
+     *
+     *  @param[in] pdrData - the response PDRs from GetPDR command
+     *  @return pointer to numeric sensor info struct
+     */
+    std::shared_ptr<pldm_numeric_sensor_value_pdr>
+        parseNumericSensorPDR(const std::vector<uint8_t>& pdrData);
+
+    /** @brief Parse the sensor Auxiliary name PDRs
+     *
+     *  @param[in] pdrData - the response PDRs from GetPDR command
+     *  @return pointer to sensor Auxiliary name info struct
+     */
+    std::shared_ptr<SensorAuxiliaryNames>
+        parseSensorAuxiliaryNamesPDR(const std::vector<uint8_t>& pdrData);
+
+    /** @brief Parse the compact numeric sensor PDRs
+     *
+     *  @param[in] pdrData - the response PDRs from GetPDR command
+     *  @return pointer to compact numeric sensor info struct
+     */
+    std::shared_ptr<pldm_compact_numeric_sensor_pdr>
+        parseCompactNumericSensorPDR(const std::vector<uint8_t>& pdrData);
+
+    /** @brief Parse the sensor Auxiliary name from compact numeric sensor PDRs
+     *
+     *  @param[in] pdrData - the response PDRs from GetPDR command
+     *  @return pointer to sensor Auxiliary name info struct
+     */
+    std::shared_ptr<SensorAuxiliaryNames>
+        parseCompactNumericSensorNames(const std::vector<uint8_t>& pdrData);
+
     /* @brief The terminus's TID */
     pldm_tid_t tid;
 
@@ -96,6 +153,10 @@ class Terminus
      *         PLDM_MAX_TYPES * (PLDM_MAX_CMDS_PER_TYPE / 8).
      */
     std::vector<uint8_t> supportedCmds;
+
+    /* @brief Sensor Auxiliary Name list */
+    std::vector<std::shared_ptr<SensorAuxiliaryNames>>
+        sensorAuxiliaryNamesTbl{};
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index f4e4f46..8c4f570 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -10,6 +10,7 @@ test_src = declare_dependency(
 tests = [
   'terminus_manager_test',
   'terminus_test',
+  'platform_manager_test',
 ]
 
 foreach t : tests
diff --git a/platform-mc/test/platform_manager_test.cpp b/platform-mc/test/platform_manager_test.cpp
new file mode 100644
index 0000000..2df2b48
--- /dev/null
+++ b/platform-mc/test/platform_manager_test.cpp
@@ -0,0 +1,316 @@
+#include "common/instance_id.hpp"
+#include "mock_terminus_manager.hpp"
+#include "platform-mc/platform_manager.hpp"
+#include "test/test_instance_id.hpp"
+
+#include <sdeventplus/event.hpp>
+
+#include <bitset>
+
+#include <gtest/gtest.h>
+
+class PlatformManagerTest : public testing::Test
+{
+  protected:
+    PlatformManagerTest() :
+        bus(pldm::utils::DBusHandler::getBus()),
+        event(sdeventplus::Event::get_default()), instanceIdDb(),
+        reqHandler(pldmTransport, event, instanceIdDb, false,
+                   std::chrono::seconds(1), 2, std::chrono::milliseconds(100)),
+        mockTerminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        platformManager(mockTerminusManager, termini)
+    {}
+
+    PldmTransport* pldmTransport = nullptr;
+    sdbusplus::bus_t& bus;
+    sdeventplus::Event event;
+    TestInstanceIdDb instanceIdDb;
+    pldm::requester::Handler<pldm::requester::Request> reqHandler;
+    pldm::platform_mc::MockTerminusManager mockTerminusManager;
+    pldm::platform_mc::PlatformManager platformManager;
+    std::map<pldm_tid_t, std::shared_ptr<pldm::platform_mc::Terminus>> termini;
+};
+
+TEST_F(PlatformManagerTest, initTerminusTest)
+{
+    // Add terminus
+    auto mappedTid = mockTerminusManager.mapTid(pldm::MctpInfo(10, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(
+        tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    /* Set supported command by terminus */
+    auto size = PLDM_MAX_TYPES * (PLDM_MAX_CMDS_PER_TYPE / 8);
+    std::vector<uint8_t> pldmCmds(size);
+    uint8_t type = PLDM_PLATFORM;
+    uint8_t cmd = PLDM_GET_PDR;
+    auto idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    cmd = PLDM_GET_PDR_REPOSITORY_INFO;
+    idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    termini[tid]->setSupportedCommands(pldmCmds);
+
+    // queue getPDRRepositoryInfo response
+    const size_t getPDRRepositoryInfoLen =
+        PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPDRRepositoryInfoLen>
+        getPDRRepositoryInfoResp{
+            0x0, 0x02, 0x50, PLDM_SUCCESS,
+            0x0,                                     // repositoryState
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // updateTime
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // OEMUpdateTime
+            1,   0x0,  0x0,  0x0,                    // recordCount
+            0x0, 0x1,  0x0,  0x0,                    // repositorySize
+            59,  0x0,  0x0,  0x0,                    // largestRecordSize
+            0x0 // dataTransferHandleTimeout
+        };
+    auto rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)getPDRRepositoryInfoResp.data(),
+        sizeof(getPDRRepositoryInfoResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDR responses
+    const size_t getPdrRespLen = 81;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrRespLen> getPdrResp{
+        0x0, 0x02, 0x51, PLDM_SUCCESS, 0x0, 0x0, 0x0, 0x0, // nextRecordHandle
+        0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+        0x5,                // transferFlag
+        69, 0x0,            // responseCount
+        // numeric Sensor PDR
+        0x1, 0x0, 0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        120,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8,   // sensorDataSize
+        0, 0, 0xc0,
+        0x3f,                          // resolution=1.5
+        0, 0, 0x80,
+        0x3f,                          // offset=1.0
+        0,
+        0,                             // accuracy
+        0,                             // plusTolerance
+        0,                             // minusTolerance
+        2,                             // hysteresis
+        0,                             // supportedThresholds
+        0,                             // thresholdAndHysteresisVolatility
+        0, 0, 0x80,
+        0x3f,                          // stateTransistionInterval=1.0
+        0, 0, 0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+    rc = mockTerminusManager.enqueueResponse((pldm_msg*)getPdrResp.data(),
+                                             sizeof(getPdrResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(1, terminus->pdrs.size());
+}
+
+TEST_F(PlatformManagerTest, initTerminusDontSupportGetPDRTest)
+{
+    // Add terminus
+    auto mappedTid = mockTerminusManager.mapTid(pldm::MctpInfo(10, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(
+        tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    /* Set supported command by terminus */
+    auto size = PLDM_MAX_TYPES * (PLDM_MAX_CMDS_PER_TYPE / 8);
+    std::vector<uint8_t> pldmCmds(size);
+    uint8_t type = PLDM_PLATFORM;
+    uint8_t cmd = PLDM_GET_PDR_REPOSITORY_INFO;
+    auto idx = type * (PLDM_MAX_CMDS_PER_TYPE / 8) + (cmd / 8);
+    pldmCmds[idx] = pldmCmds[idx] | (1 << (cmd % 8));
+    termini[tid]->setSupportedCommands(pldmCmds);
+
+    // queue getPDRRepositoryInfo response
+    const size_t getPDRRepositoryInfoLen =
+        PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPDRRepositoryInfoLen>
+        getPDRRepositoryInfoResp{
+            0x0, 0x02, 0x50, PLDM_SUCCESS,
+            0x0,                                     // repositoryState
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // updateTime
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // OEMUpdateTime
+            1,   0x0,  0x0,  0x0,                    // recordCount
+            0x0, 0x1,  0x0,  0x0,                    // repositorySize
+            59,  0x0,  0x0,  0x0,                    // largestRecordSize
+            0x0 // dataTransferHandleTimeout
+        };
+    auto rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)getPDRRepositoryInfoResp.data(),
+        sizeof(getPDRRepositoryInfoResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDR responses
+    const size_t getPdrRespLen = 81;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrRespLen> getPdrResp{
+        0x0, 0x02, 0x51, PLDM_SUCCESS, 0x0, 0x0, 0x0, 0x0, // nextRecordHandle
+        0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+        0x5,                // transferFlag
+        69, 0x0,            // responseCount
+        // numeric Sensor PDR
+        0x1, 0x0, 0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        120,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8,   // sensorDataSize
+        0, 0, 0xc0,
+        0x3f,                          // resolution=1.5
+        0, 0, 0x80,
+        0x3f,                          // offset=1.0
+        0,
+        0,                             // accuracy
+        0,                             // plusTolerance
+        0,                             // minusTolerance
+        2,                             // hysteresis
+        0,                             // supportedThresholds
+        0,                             // thresholdAndHysteresisVolatility
+        0, 0, 0x80,
+        0x3f,                          // stateTransistionInterval=1.0
+        0, 0, 0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+    rc = mockTerminusManager.enqueueResponse((pldm_msg*)getPdrResp.data(),
+                                             sizeof(getPdrResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(0, terminus->pdrs.size());
+}
+
+TEST_F(PlatformManagerTest, negativeInitTerminusTest1)
+{
+    // terminus doesn't Type2 support
+    auto mappedTid = mockTerminusManager.mapTid(pldm::MctpInfo(10, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] =
+        std::make_shared<pldm::platform_mc::Terminus>(tid, 1 << PLDM_BASE);
+    auto terminus = termini[tid];
+
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(0, terminus->pdrs.size());
+}
+
+TEST_F(PlatformManagerTest, negativeInitTerminusTest2)
+{
+    // terminus responses error
+    auto mappedTid = mockTerminusManager.mapTid(pldm::MctpInfo(10, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(
+        tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    // queue getPDRRepositoryInfo response cc=PLDM_ERROR
+    const size_t getPDRRepositoryInfoLen = 1;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPDRRepositoryInfoLen>
+        getPDRRepositoryInfoResp{0x0, 0x02, 0x50, PLDM_ERROR};
+    auto rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)getPDRRepositoryInfoResp.data(),
+        sizeof(getPDRRepositoryInfoResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDR responses cc=PLDM_ERROR
+    const size_t getPdrRespLen = 1;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrRespLen> getPdrResp{
+        0x0, 0x02, 0x51, PLDM_ERROR};
+    rc = mockTerminusManager.enqueueResponse((pldm_msg*)getPdrResp.data(),
+                                             sizeof(getPdrResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(0, terminus->pdrs.size());
+}
diff --git a/platform-mc/test/terminus_test.cpp b/platform-mc/test/terminus_test.cpp
index 32fd7b7..2f88829 100644
--- a/platform-mc/test/terminus_test.cpp
+++ b/platform-mc/test/terminus_test.cpp
@@ -1,3 +1,5 @@
+#include "libpldm/entity.h"
+
 #include "platform-mc/terminus.hpp"
 
 #include <gtest/gtest.h>
@@ -21,3 +23,60 @@ TEST(TerminusTest, getTidTest)
 
     EXPECT_EQ(tid, t1.getTid());
 }
+
+TEST(TerminusTest, parseSensorAuxiliaryNamesPDRTest)
+{
+    auto t1 = pldm::platform_mc::Terminus(1,
+                                          1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    std::vector<uint8_t> pdr1{
+        0x0,
+        0x0,
+        0x0,
+        0x1,                             // record handle
+        0x1,                             // PDRHeaderVersion
+        PLDM_SENSOR_AUXILIARY_NAMES_PDR, // PDRType
+        0x0,
+        0x0,                             // recordChangeNumber
+        0x0,
+        21,                              // dataLength
+        0,
+        0x0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                             // sensorID
+        0x1,                             // sensorCount
+        0x1,                             // nameStringCount
+        'e',
+        'n',
+        0x0, // nameLanguageTag
+        0x0,
+        'T',
+        0x0,
+        'E',
+        0x0,
+        'M',
+        0x0,
+        'P',
+        0x0,
+        '1',
+        0x0,
+        0x0 // sensorName
+    };
+
+    t1.pdrs.emplace_back(pdr1);
+    auto rc = t1.parsePDRs();
+    EXPECT_EQ(true, rc);
+
+    auto sensorAuxNames = t1.getSensorAuxiliaryNames(0);
+    EXPECT_EQ(nullptr, sensorAuxNames);
+
+    sensorAuxNames = t1.getSensorAuxiliaryNames(1);
+    EXPECT_NE(nullptr, sensorAuxNames);
+
+    const auto& [sensorId, sensorCnt, names] = *sensorAuxNames;
+    EXPECT_EQ(1, sensorId);
+    EXPECT_EQ(1, sensorCnt);
+    EXPECT_EQ(1, names.size());
+    EXPECT_EQ(1, names[0].size());
+    EXPECT_EQ("en", names[0][0].first);
+    EXPECT_EQ("TEMP1", names[0][0].second);
+}
-- 
2.43.0

