From 231ab1f86a5c14b400fcdbdc5b6e940ef6dbab5b Mon Sep 17 00:00:00 2001
From: Joseph Liu <kwliu@nuvoton.com>
Date: Wed, 23 Nov 2022 16:43:10 +0800
Subject: [PATCH] update i3c driver

Signed-off-by: Joseph Liu <kwliu@nuvoton.com>
---
 drivers/i3c/Kconfig                     |   63 +
 drivers/i3c/Makefile                    |    6 +
 drivers/i3c/device.c                    |  197 ++
 drivers/i3c/i3c-hub.c                   |  699 +++++++
 drivers/i3c/i3c-ibi-mqueue.c            |  231 +++
 drivers/i3c/i3c-mux-imx3102.c           |  227 +++
 drivers/i3c/i3c-slave-eeprom.c          |  175 ++
 drivers/i3c/i3c-slave-mqueue.c          |  206 ++
 drivers/i3c/i3cdev.c                    |  128 +-
 drivers/i3c/internals.h                 |   11 +
 drivers/i3c/master.c                    |  864 ++++++--
 drivers/i3c/master/Kconfig              |   28 +
 drivers/i3c/master/Makefile             |    1 +
 drivers/i3c/master/ast2600-i3c-global.c |  141 ++
 drivers/i3c/master/ast2600-i3c-master.c | 2496 +++++++++++++++++++++++
 drivers/i3c/master/mipi-i3c-hci/core.c  |    9 +-
 drivers/i3c/master/mipi-i3c-hci/dma.c   |    2 +-
 drivers/i3c/master/mipi-i3c-hci/hci.h   |    2 +-
 drivers/i3c/mctp/Kconfig                |   14 +
 drivers/i3c/mctp/Makefile               |    3 +
 drivers/i3c/mctp/i3c-mctp.c             |  627 ++++++
 drivers/i3c/mctp/i3c-target-mctp.c      |  389 ++++
 include/linux/i3c/ccc.h                 |    5 +
 include/linux/i3c/device.h              |   54 +
 include/linux/i3c/master.h              |   86 +-
 include/linux/i3c/mctp/i3c-mctp.h       |   50 +
 include/linux/i3c/target.h              |   23 +
 27 files changed, 6535 insertions(+), 202 deletions(-)
 create mode 100644 drivers/i3c/i3c-hub.c
 create mode 100644 drivers/i3c/i3c-ibi-mqueue.c
 create mode 100644 drivers/i3c/i3c-mux-imx3102.c
 create mode 100644 drivers/i3c/i3c-slave-eeprom.c
 create mode 100644 drivers/i3c/i3c-slave-mqueue.c
 create mode 100644 drivers/i3c/master/ast2600-i3c-global.c
 create mode 100644 drivers/i3c/master/ast2600-i3c-master.c
 create mode 100644 drivers/i3c/mctp/Kconfig
 create mode 100644 drivers/i3c/mctp/Makefile
 create mode 100644 drivers/i3c/mctp/i3c-mctp.c
 create mode 100644 drivers/i3c/mctp/i3c-target-mctp.c
 create mode 100644 include/linux/i3c/mctp/i3c-mctp.h
 create mode 100644 include/linux/i3c/target.h

diff --git a/drivers/i3c/Kconfig b/drivers/i3c/Kconfig
index 01642768ab5f..c2b26c5d735e 100644
--- a/drivers/i3c/Kconfig
+++ b/drivers/i3c/Kconfig
@@ -21,6 +21,8 @@ menuconfig I3C
 
 if I3C
 
+source "drivers/i3c/mctp/Kconfig"
+
 config I3CDEV
 	tristate "I3C device interface"
 	depends on I3C
@@ -35,5 +37,66 @@ config I3CDEV
 	  Note that this application programming interface is EXPERIMENTAL
 	  and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes.
 
+config I3C_HUB
+	tristate "I3C HUB support"
+	depends on I3C
+	select REGMAP_I3C
+	help
+	  This enables support for I3C HUB. Say Y here to use I3C HUB driver to
+	  configure I3C HUB device.
+
+	  I3C HUB drivers will be loaded automatically when I3C device with BCR
+	  equals to 0xC2 (HUB device) is detected on the bus.
+
+
+if I3CDEV
+config I3CDEV_FORCE_CREATE
+	bool "force create I3C device interface"
+	default y
+	help
+	  Say 'y' to force create I3C devices under /dev/bus/i3c/ regardless of
+	  driver binding.  This option is to help development so it shall be
+	  turned off in production.
+endif # I3CDEV
+
+config I3C_IBI_MQUEUE
+	bool "I3C mqueue (message queue) master ibi driver"
+	default y
+	help
+	  Some protocols over I3C are designed for bi-directional transferring
+	  messages by using I3C IBI protocol. This driver is used to receive and
+	  queue messages from the remote I3C slave device.
+
+	  Userspace can get the messages by reading sysfs file that this driver
+	  exposes.
+
+config I3C_MUX_IMX3102
+	bool "IMX/IML3102 I3C multiplexer driver"
+	default y
+	select REGMAP_I3C
+	help
+	  Say y to enable Renesas IMX3102 I3C 2:1 multiplexer.
+
+choice
+	prompt "I3C secondary master / slave mode driver selection"
+	default I3C_SLAVE_MQUEUE
+
+config I3C_SLAVE_MQUEUE
+	bool "I3C mqueue (message queue) secondary master and slave driver"
+	help
+	  Some protocols over I3C are designed for bi-directional transferring
+	  messages by using I3C Master Write protocol. This driver is used to
+	  receive and queue messages from the remote I3C main master device.
+
+	  Userspace can get the messages by reading sysfs file that this driver
+	  exposes.
+
+config I3C_SLAVE_EEPROM
+	bool "I3C EEPROM secondary master and slave driver"
+	help
+	  This driver makes the slave mode I3C controller simulate the EEPROM.
+endchoice
+
 source "drivers/i3c/master/Kconfig"
+
 endif # I3C
diff --git a/drivers/i3c/Makefile b/drivers/i3c/Makefile
index 606d422841b2..149b64b43795 100644
--- a/drivers/i3c/Makefile
+++ b/drivers/i3c/Makefile
@@ -3,3 +3,9 @@ i3c-y				:= device.o master.o
 obj-$(CONFIG_I3C)		+= i3c.o
 obj-$(CONFIG_I3CDEV)		+= i3cdev.o
 obj-$(CONFIG_I3C)		+= master/
+obj-$(CONFIG_I3C_IBI_MQUEUE) 	+= i3c-ibi-mqueue.o
+obj-$(CONFIG_I3C_SLAVE_MQUEUE) 	+= i3c-slave-mqueue.o
+obj-$(CONFIG_I3C_SLAVE_EEPROM) 	+= i3c-slave-eeprom.o
+obj-$(CONFIG_I3C_MUX_IMX3102) 	+= i3c-mux-imx3102.o
+obj-$(CONFIG_I3C)		+= mctp/
+obj-$(CONFIG_I3C_HUB)		+= i3c-hub.o
diff --git a/drivers/i3c/device.c b/drivers/i3c/device.c
index e92d3e9a52bd..0c9405761021 100644
--- a/drivers/i3c/device.c
+++ b/drivers/i3c/device.c
@@ -50,6 +50,29 @@ int i3c_device_do_priv_xfers(struct i3c_device *dev,
 }
 EXPORT_SYMBOL_GPL(i3c_device_do_priv_xfers);
 
+/**
+ * i3c_device_generate_ibi() - request In-Band Interrupt
+ *
+ * @dev: target device
+ * @data: IBI payload
+ * @len: payload length in bytes
+ *
+ * Request In-Band Interrupt with or without data payload.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_generate_ibi(struct i3c_device *dev, const u8 *data, int len)
+{
+	int ret;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	ret = i3c_dev_generate_ibi_locked(dev->desc, data, len);
+	i3c_bus_normaluse_unlock(dev->bus);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_generate_ibi);
+
 /**
  * i3c_device_get_info() - get I3C device information
  *
@@ -176,6 +199,33 @@ void i3c_device_free_ibi(struct i3c_device *dev)
 }
 EXPORT_SYMBOL_GPL(i3c_device_free_ibi);
 
+/**
+ * i3c_device_send_ccc_cmd() - send ccc to the target device
+ * @dev: device on which you want to release IBI resources
+ * @ccc_id: CCC ID you want to send.  Only support SETAASA, RSTDAA for now.
+ *
+ * This function provides a interface to send CCC from high layer driver.
+ * This is needed for the bus topologic with I3C MUX or switch devices.
+ * The I3C MUX may not enable the local/slave port by default.  The master
+ * controller needs to attach the I3C MUX device, and program the mode
+ * registers to enable the local/slave port.  Then the devices hehind
+ * the MUX may need for CCC for initialization (e.g. SETAASA to bring them
+ * from I2C mode to I3C mode)
+ */
+int i3c_device_send_ccc_cmd(struct i3c_device *dev, u8 ccc_id)
+{
+	int ret;
+
+	if (dev->desc) {
+		i3c_bus_normaluse_lock(dev->bus);
+		ret = i3c_dev_send_ccc_cmd_locked(dev->desc, ccc_id);
+		i3c_bus_normaluse_unlock(dev->bus);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_send_ccc_cmd);
+
 /**
  * i3cdev_to_dev() - Returns the device embedded in @i3cdev
  * @i3cdev: I3C device
@@ -283,3 +333,150 @@ void i3c_driver_unregister(struct i3c_driver *drv)
 	driver_unregister(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(i3c_driver_unregister);
+
+/**
+ * i3c_device_getstatus_ccc() - receive device status
+ *
+ * @dev: I3C device to get the status for
+ * @info: I3C device info to fill the status in
+ *
+ * Receive I3C device status from I3C master device via corresponding CCC
+ * command
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_getstatus_ccc(struct i3c_device *dev, struct i3c_device_info *info)
+{
+	int ret = -EINVAL;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	if (dev->desc)
+		ret = i3c_dev_getstatus_locked(dev->desc, &dev->desc->info);
+	i3c_bus_normaluse_unlock(dev->bus);
+	i3c_device_get_info(dev, info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_getstatus_ccc);
+
+/**
+ * i3c_device_control_pec() - enable or disable PEC support in HW
+ *
+ * @dev: I3C device to get the status for
+ * @pec: flag telling whether PEC support shall be enabled or disabled
+ *
+ * Try to enable or disable HW support for PEC (Packet Error Check).
+ * In case no HW support for PEC, software implementation could be used.
+ *
+ * Return: 0 in case of success, -EOPNOTSUPP in case PEC is not supported by HW,
+ *         other negative error codes when PEC enabling failed.
+ */
+int i3c_device_control_pec(struct i3c_device *dev, bool pec)
+{
+	return i3c_dev_control_pec(dev->desc, pec);
+}
+EXPORT_SYMBOL_GPL(i3c_device_control_pec);
+
+/**
+ * i3c_device_setmrl_ccc() - set maximum read length
+ *
+ * @dev: I3C device to set the length for
+ * @info: I3C device info to fill the length in
+ * @read_len: maximum read length value to be set
+ * @ibi_len: maximum ibi payload length to be set
+ *
+ * Set I3C device maximum read length from I3C master device via corresponding CCC command
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_setmrl_ccc(struct i3c_device *dev, struct i3c_device_info *info, u16 read_len,
+			  u8 ibi_len)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev->desc);
+	int ret = -EINVAL;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	if (master)
+		ret = i3c_master_setmrl_locked(master, &dev->desc->info, read_len, ibi_len);
+	i3c_bus_normaluse_unlock(dev->bus);
+	i3c_device_get_info(dev, info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_setmrl_ccc);
+
+/**
+ * i3c_device_setmwl_ccc() - set maximum write length
+ *
+ * @dev: I3C device to set the length for
+ * @info: I3C device info to fill the length in
+ * @write_len: maximum write length value to be set
+ *
+ * Set I3C device maximum write length from I3C master device via corresponding CCC command
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_setmwl_ccc(struct i3c_device *dev, struct i3c_device_info *info, u16 write_len)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev->desc);
+	int ret = -EINVAL;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	if (master)
+		ret = i3c_master_setmwl_locked(master, &dev->desc->info, write_len);
+	i3c_bus_normaluse_unlock(dev->bus);
+	i3c_device_get_info(dev, info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_setmwl_ccc);
+
+/**
+ * i3c_device_getmrl_ccc() - get maximum read length
+ *
+ * @dev: I3C device to get the length for
+ * @info: I3C device info to fill the length in
+ *
+ * Receive I3C device maximum read length from I3C master device via corresponding CCC command
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_getmrl_ccc(struct i3c_device *dev, struct i3c_device_info *info)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev->desc);
+	int ret = -EINVAL;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	if (master)
+		ret = i3c_master_getmrl_locked(master, &dev->desc->info);
+	i3c_bus_normaluse_unlock(dev->bus);
+	i3c_device_get_info(dev, info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_getmrl_ccc);
+
+/**
+ * i3c_device_getmwl_ccc() - get maximum write length
+ *
+ * @dev: I3C device to get the length for
+ * @info: I3C device info to fill the length in
+ *
+ * Receive I3C device maximum write length from I3C master device via corresponding CCC command
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_getmwl_ccc(struct i3c_device *dev, struct i3c_device_info *info)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev->desc);
+	int ret = -EINVAL;
+
+	i3c_bus_normaluse_lock(dev->bus);
+	if (master)
+		ret = i3c_master_getmwl_locked(master, &dev->desc->info);
+	i3c_bus_normaluse_unlock(dev->bus);
+	i3c_device_get_info(dev, info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_getmwl_ccc);
diff --git a/drivers/i3c/i3c-hub.c b/drivers/i3c/i3c-hub.c
new file mode 100644
index 000000000000..59576b244531
--- /dev/null
+++ b/drivers/i3c/i3c-hub.c
@@ -0,0 +1,699 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2021 Intel Corporation.*/
+
+#include <linux/bitfield.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+
+#include <linux/i3c/device.h>
+#include <linux/i3c/master.h>
+
+#define I3C_HUB_TP_MAX_COUNT				0x08
+
+/* I3C HUB REGISTERS */
+
+/*
+ * In this driver Controller - Target convention is used. All the abbreviations are
+ * based on this convention. For instance: CP - Controller Port, TP - Target Port.
+ */
+
+/* Device Information Registers */
+#define I3C_HUB_DEV_INFO_0				0x00
+#define I3C_HUB_DEV_INFO_1				0x01
+#define I3C_HUB_PID_5					0x02
+#define I3C_HUB_PID_4					0x03
+#define I3C_HUB_PID_3					0x04
+#define I3C_HUB_PID_2					0x05
+#define I3C_HUB_PID_1					0x06
+#define I3C_HUB_PID_0					0x07
+#define I3C_HUB_BCR					0x08
+#define I3C_HUB_DCR					0x09
+#define I3C_HUB_DEV_CAPAB				0x0A
+#define I3C_HUB_DEV_REV					0x0B
+
+/* Device Configuration Registers */
+#define I3C_HUB_PROTECTION_CODE				0x10
+#define  REGISTERS_LOCK_CODE				0x00
+#define  REGISTERS_UNLOCK_CODE				0x69
+#define  CP1_REGISTERS_UNLOCK_CODE			0x6A
+
+#define I3C_HUB_CP_CONF					0x11
+#define I3C_HUB_TP_ENABLE				0x12
+#define  TPn_ENABLE(n)					BIT(n)
+
+#define I3C_HUB_DEV_CONF				0x13
+#define I3C_HUB_IO_STRENGTH				0x14
+#define I3C_HUB_NET_OPER_MODE_CONF			0x15
+#define I3C_HUB_LDO_CONF				0x16
+#define  CP0_LDO_VOLTAGE_MASK				GENMASK(1, 0)
+#define  CP0_LDO_VOLTAGE(x)				(((x) << 0) & CP0_LDO_VOLTAGE_MASK)
+#define  CP1_LDO_VOLTAGE_MASK				GENMASK(3, 2)
+#define  CP1_LDO_VOLTAGE(x)				(((x) << 2) & CP1_LDO_VOLTAGE_MASK)
+#define  TP0145_LDO_VOLTAGE_MASK			GENMASK(5, 4)
+#define  TP0145_LDO_VOLTAGE(x)				(((x) << 4) & TP0145_LDO_VOLTAGE_MASK)
+#define  TP2367_LDO_VOLTAGE_MASK			GENMASK(7, 6)
+#define  TP2367_LDO_VOLTAGE(x)				(((x) << 6) & TP2367_LDO_VOLTAGE_MASK)
+#define  LDO_VOLTAGE_1_0V				0x00
+#define  LDO_VOLTAGE_1_1V				0x01
+#define  LDO_VOLTAGE_1_2V				0x02
+#define  LDO_VOLTAGE_1_8V				0x03
+
+#define I3C_HUB_TP_IO_MODE_CONF				0x17
+#define I3C_HUB_TP_SMBUS_AGNT_EN			0x18
+#define  TPn_SMBUS_MODE_EN(n)				BIT(n)
+
+#define I3C_HUB_LDO_AND_PULLUP_CONF			0x19
+#define  CP0_LDO_EN					BIT(0)
+#define  CP1_LDO_EN					BIT(1)
+/*
+ * I3C HUB does not provide a way to control LDO or pull-up for individual ports. It is possible
+ * for group of ports TP0/TP1/TP4/TP5 and TP2/TP3/TP6/TP7.
+ */
+#define  TP0145_LDO_EN					BIT(2)
+#define  TP2367_LDO_EN					BIT(3)
+#define  TP0145_PULLUP_CONF_MASK			GENMASK(7, 6)
+#define  TP0145_PULLUP_CONF(x)				(((x) << 6) & TP0145_PULLUP_CONF_MASK)
+#define  TP2367_PULLUP_CONF_MASK			GENMASK(5, 4)
+#define  TP2367_PULLUP_CONF(x)				(((x) << 4) & TP2367_PULLUP_CONF_MASK)
+#define  PULLUP_250R					0x00
+#define  PULLUP_500R					0x01
+#define  PULLUP_1K					0x02
+#define  PULLUP_2K					0x03
+
+#define I3C_HUB_CP_IBI_CONF				0x1A
+#define I3C_HUB_TP_IBI_CONF				0x1B
+#define I3C_HUB_IBI_MDB_CUSTOM				0x1C
+#define I3C_HUB_JEDEC_CONTEXT_ID			0x1D
+#define I3C_HUB_TP_GPIO_MODE_EN				0x1E
+#define  TPn_GPIO_MODE_EN(n)				BIT(n)
+
+/* Device Status and IBI Registers */
+#define I3C_HUB_DEV_AND_IBI_STS				0x20
+#define I3C_HUB_TP_SMBUS_AGNT_IBI_STS			0x21
+
+/* Controller Port Control/Status Registers */
+#define I3C_HUB_CP_MUX_SET				0x38
+#define I3C_HUB_CP_MUX_STS				0x39
+
+/* Target Ports Control Registers */
+#define I3C_HUB_TP_SMBUS_AGNT_TRANS_START		0x50
+#define I3C_HUB_TP_NET_CON_CONF				0x51
+#define  TPn_NET_CON(n)					BIT(n)
+
+#define I3C_HUB_TP_PULLUP_EN				0x53
+#define  TPn_PULLUP_EN(n)				BIT(n)
+
+#define I3C_HUB_TP_SCL_OUT_EN				0x54
+#define I3C_HUB_TP_SDA_OUT_EN				0x55
+#define I3C_HUB_TP_SCL_OUT_LEVEL			0x56
+#define I3C_HUB_TP_SDA_OUT_LEVEL			0x57
+#define I3C_HUB_TP_IN_DETECT_MODE_CONF			0x58
+#define I3C_HUB_TP_SCL_IN_DETECT_IBI_EN			0x59
+#define I3C_HUB_TP_SDA_IN_DETECT_IBI_EN			0x5A
+
+/* Target Ports Status Registers */
+#define I3C_HUB_TP_SCL_IN_LEVEL_STS			0x60
+#define I3C_HUB_TP_SDA_IN_LEVEL_STS			0x61
+#define I3C_HUB_TP_SCL_IN_DETECT_FLG			0x62
+#define I3C_HUB_TP_SDA_IN_DETECT_FLG			0x63
+
+/* SMBus Agent Configuration and Status Registers */
+#define I3C_HUB_TP0_SMBUS_AGNT_STS			0x64
+#define I3C_HUB_TP1_SMBUS_AGNT_STS			0x65
+#define I3C_HUB_TP2_SMBUS_AGNT_STS			0x66
+#define I3C_HUB_TP3_SMBUS_AGNT_STS			0x67
+#define I3C_HUB_TP4_SMBUS_AGNT_STS			0x68
+#define I3C_HUB_TP5_SMBUS_AGNT_STS			0x69
+#define I3C_HUB_TP6_SMBUS_AGNT_STS			0x6A
+#define I3C_HUB_TP7_SMBUS_AGNT_STS			0x6B
+#define I3C_HUB_ONCHIP_TD_AND_SMBUS_AGNT_CONF		0x6C
+
+/* Special Function Registers */
+#define I3C_HUB_LDO_AND_CPSEL_STS			0x79
+#define I3C_HUB_BUS_RESET_SCL_TIMEOUT			0x7A
+#define I3C_HUB_ONCHIP_TD_PROTO_ERR_FLG			0x7B
+#define I3C_HUB_DEV_CMD					0x7C
+#define I3C_HUB_ONCHIP_TD_STS				0x7D
+#define I3C_HUB_ONCHIP_TD_ADDR_CONF			0x7E
+#define I3C_HUB_PAGE_PTR				0x7F
+
+/* LDO DT settings */
+#define I3C_HUB_DT_LDO_DISABLED				0x00
+#define I3C_HUB_DT_LDO_1_0V				0x01
+#define I3C_HUB_DT_LDO_1_1V				0x02
+#define I3C_HUB_DT_LDO_1_2V				0x03
+#define I3C_HUB_DT_LDO_1_8V				0x04
+#define I3C_HUB_DT_LDO_NOT_DEFINED			0xFF
+
+/* Pull-up DT settings */
+#define I3C_HUB_DT_PULLUP_DISABLED			0x00
+#define I3C_HUB_DT_PULLUP_250R				0x01
+#define I3C_HUB_DT_PULLUP_500R				0x02
+#define I3C_HUB_DT_PULLUP_1K				0x03
+#define I3C_HUB_DT_PULLUP_2K				0x04
+#define I3C_HUB_DT_PULLUP_NOT_DEFINED			0xFF
+
+/* TP DT setting */
+#define I3C_HUB_DT_TP_MODE_DISABLED			0x00
+#define I3C_HUB_DT_TP_MODE_I3C				0x01
+#define I3C_HUB_DT_TP_MODE_I3C_PERF			0x02
+#define I3C_HUB_DT_TP_MODE_SMBUS			0x03
+#define I3C_HUB_DT_TP_MODE_GPIO				0x04
+#define I3C_HUB_DT_TP_MODE_NOT_DEFINED			0xFF
+
+/* TP pull-up status */
+#define I3C_HUB_DT_TP_PULLUP_DISABLED			0x00
+#define I3C_HUB_DT_TP_PULLUP_ENABLED			0x01
+#define I3C_HUB_DT_TP_PULLUP_NOT_DEFINED		0xFF
+
+struct tp_setting {
+	u8 mode;
+	u8 pullup_en;
+};
+
+struct dt_settings {
+	u8 cp0_ldo;
+	u8 cp1_ldo;
+	u8 tp0145_ldo;
+	u8 tp2367_ldo;
+	u8 tp0145_pullup;
+	u8 tp2367_pullup;
+	struct tp_setting tp[I3C_HUB_TP_MAX_COUNT];
+};
+
+struct i3c_hub {
+	struct i3c_device *i3cdev;
+	struct regmap *regmap;
+	struct dt_settings settings;
+
+	/* Offset for reading HUB's register. */
+	u8 reg_addr;
+	struct dentry *debug_dir;
+};
+
+struct hub_setting {
+	const char * const name;
+	const u8 value;
+};
+
+static const struct hub_setting ldo_settings[] = {
+	{"disabled",	I3C_HUB_DT_LDO_DISABLED},
+	{"1.0V",	I3C_HUB_DT_LDO_1_0V},
+	{"1.1V",	I3C_HUB_DT_LDO_1_1V},
+	{"1.2V",	I3C_HUB_DT_LDO_1_2V},
+	{"1.8V",	I3C_HUB_DT_LDO_1_8V},
+};
+
+static const struct hub_setting pullup_settings[] = {
+	{"disabled",	I3C_HUB_DT_PULLUP_DISABLED},
+	{"250R",	I3C_HUB_DT_PULLUP_250R},
+	{"500R",	I3C_HUB_DT_PULLUP_500R},
+	{"1k",		I3C_HUB_DT_PULLUP_1K},
+	{"2k",		I3C_HUB_DT_PULLUP_2K},
+};
+
+static const struct hub_setting tp_mode_settings[] = {
+	{"disabled",	I3C_HUB_DT_TP_MODE_DISABLED},
+	{"i3c",		I3C_HUB_DT_TP_MODE_I3C},
+	{"i3c-perf",	I3C_HUB_DT_TP_MODE_I3C_PERF},
+	{"smbus",	I3C_HUB_DT_TP_MODE_SMBUS},
+	{"gpio",	I3C_HUB_DT_TP_MODE_GPIO},
+};
+
+static const struct hub_setting tp_pullup_settings[] = {
+	{"disabled",	I3C_HUB_DT_TP_PULLUP_DISABLED},
+	{"enabled",	I3C_HUB_DT_TP_PULLUP_ENABLED},
+};
+
+static u8 i3c_hub_ldo_dt_to_reg(u8 dt_value)
+{
+	switch (dt_value) {
+	case I3C_HUB_DT_LDO_1_1V:
+		return LDO_VOLTAGE_1_1V;
+	case I3C_HUB_DT_LDO_1_2V:
+		return LDO_VOLTAGE_1_2V;
+	case I3C_HUB_DT_LDO_1_8V:
+		return LDO_VOLTAGE_1_8V;
+	default:
+		return LDO_VOLTAGE_1_0V;
+	}
+}
+
+static u8 i3c_hub_pullup_dt_to_reg(u8 dt_value)
+{
+	switch (dt_value) {
+	case I3C_HUB_DT_PULLUP_250R:
+		return PULLUP_250R;
+	case I3C_HUB_DT_PULLUP_500R:
+		return PULLUP_500R;
+	case I3C_HUB_DT_PULLUP_1K:
+		return PULLUP_1K;
+	default:
+		return PULLUP_2K;
+	}
+}
+
+static int i3c_hub_of_get_setting(const struct device_node *node, const char *setting_name,
+				  const struct hub_setting settings[], const u8 settings_count,
+				  u8 *setting_value)
+{
+	const char *sval;
+	int ret;
+	int i;
+
+	ret = of_property_read_string(node, setting_name, &sval);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < settings_count; ++i) {
+		const struct hub_setting * const setting = &settings[i];
+
+		if (!strcmp(setting->name, sval)) {
+			*setting_value = setting->value;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static void i3c_hub_tp_of_get_setting(struct device *dev, const struct device_node *node,
+				      struct tp_setting tp_setting[])
+{
+	struct device_node *tp_node;
+	int id;
+
+	for_each_available_child_of_node(node, tp_node) {
+		int ret;
+
+		if (!tp_node->name || of_node_cmp(tp_node->name, "target-port"))
+			continue;
+
+		if (!tp_node->full_name ||
+		    (sscanf(tp_node->full_name, "target-port@%i", &id) != 1)) {
+			dev_warn(dev, "Invalid target port node found in DT - %s\n",
+				 tp_node->full_name);
+			continue;
+		}
+
+		if (id >= I3C_HUB_TP_MAX_COUNT) {
+			dev_warn(dev, "Invalid target port index found in DT - %i\n", id);
+			continue;
+		}
+		ret = i3c_hub_of_get_setting(tp_node, "mode", tp_mode_settings,
+					     ARRAY_SIZE(tp_mode_settings), &tp_setting[id].mode);
+		if (ret)
+			dev_warn(dev, "Invalid or not specified setting for target port[%i].mode\n",
+				 id);
+
+		ret = i3c_hub_of_get_setting(tp_node, "pullup", tp_pullup_settings,
+					     ARRAY_SIZE(tp_pullup_settings),
+					     &tp_setting[id].pullup_en);
+		if (ret)
+			dev_warn(dev,
+				 "Invalid or not specified setting for target port[%i].pullup\n",
+				 id);
+	}
+}
+
+static void i3c_hub_of_get_configuration(struct device *dev, const struct device_node *node)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = i3c_hub_of_get_setting(node, "cp0-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+				     &priv->settings.cp0_ldo);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for cp0-ldo\n");
+
+	ret = i3c_hub_of_get_setting(node, "cp1-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+				     &priv->settings.cp1_ldo);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for cp1-ldo\n");
+
+	ret = i3c_hub_of_get_setting(node, "tp0145-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+				     &priv->settings.tp0145_ldo);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for tp0145-ldo\n");
+
+	ret = i3c_hub_of_get_setting(node, "tp2367-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+				     &priv->settings.tp2367_ldo);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for tp2367-ldo\n");
+
+	ret = i3c_hub_of_get_setting(node, "tp0145-pullup", pullup_settings,
+				     ARRAY_SIZE(pullup_settings), &priv->settings.tp0145_pullup);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for tp0145-pullup\n");
+
+	ret = i3c_hub_of_get_setting(node, "tp2367-pullup", pullup_settings,
+				     ARRAY_SIZE(pullup_settings), &priv->settings.tp2367_pullup);
+	if (ret)
+		dev_warn(dev, "Invalid or not specified setting for tp2367-pullup\n");
+
+	i3c_hub_tp_of_get_setting(dev, node, priv->settings.tp);
+}
+
+static void i3c_hub_of_default_configuration(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	int id;
+
+	priv->settings.cp0_ldo = I3C_HUB_DT_LDO_NOT_DEFINED;
+	priv->settings.cp1_ldo = I3C_HUB_DT_LDO_NOT_DEFINED;
+	priv->settings.tp0145_ldo = I3C_HUB_DT_LDO_NOT_DEFINED;
+	priv->settings.tp2367_ldo = I3C_HUB_DT_LDO_NOT_DEFINED;
+	priv->settings.tp0145_pullup = I3C_HUB_DT_PULLUP_NOT_DEFINED;
+	priv->settings.tp2367_pullup = I3C_HUB_DT_PULLUP_NOT_DEFINED;
+
+	for (id = 0; id < I3C_HUB_TP_MAX_COUNT; ++id) {
+		priv->settings.tp[id].mode = I3C_HUB_DT_TP_MODE_NOT_DEFINED;
+		priv->settings.tp[id].pullup_en = I3C_HUB_DT_TP_PULLUP_NOT_DEFINED;
+	}
+}
+
+static int i3c_hub_hw_configure_pullup(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	u8 mask = 0, value = 0;
+
+	if (priv->settings.tp0145_pullup != I3C_HUB_DT_PULLUP_NOT_DEFINED) {
+		mask |= TP0145_PULLUP_CONF_MASK;
+		value |= TP0145_PULLUP_CONF(i3c_hub_pullup_dt_to_reg(priv->settings.tp0145_pullup));
+	}
+
+	if (priv->settings.tp2367_pullup != I3C_HUB_DT_PULLUP_NOT_DEFINED) {
+		mask |= TP2367_PULLUP_CONF_MASK;
+		value |= TP2367_PULLUP_CONF(i3c_hub_pullup_dt_to_reg(priv->settings.tp2367_pullup));
+	}
+
+	return regmap_update_bits(priv->regmap, I3C_HUB_LDO_AND_PULLUP_CONF, mask, value);
+}
+
+static int i3c_hub_hw_configure_ldo(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	u8 mask_all = 0, val_all = 0;
+	u8 ldo_dis = 0, ldo_en = 0;
+	u32 reg_val;
+	u8 val;
+	int ret;
+
+	/* Get LDOs configuration to figure out what is going to be changed */
+	ret = regmap_read(priv->regmap, I3C_HUB_LDO_CONF, &reg_val);
+	if (ret)
+		return ret;
+
+	if (priv->settings.cp0_ldo != I3C_HUB_DT_LDO_NOT_DEFINED) {
+		val = CP0_LDO_VOLTAGE(i3c_hub_ldo_dt_to_reg(priv->settings.cp0_ldo));
+		if ((reg_val & CP0_LDO_VOLTAGE_MASK) != val)
+			ldo_dis |= CP0_LDO_EN;
+		if (priv->settings.cp0_ldo != I3C_HUB_DT_LDO_DISABLED)
+			ldo_en |= CP0_LDO_EN;
+		mask_all |= CP0_LDO_VOLTAGE_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.cp1_ldo != I3C_HUB_DT_LDO_NOT_DEFINED) {
+		val = CP1_LDO_VOLTAGE(i3c_hub_ldo_dt_to_reg(priv->settings.cp1_ldo));
+		if ((reg_val & CP1_LDO_VOLTAGE_MASK) != val)
+			ldo_dis |= CP1_LDO_EN;
+		if (priv->settings.cp1_ldo != I3C_HUB_DT_LDO_DISABLED)
+			ldo_en |= CP1_LDO_EN;
+		mask_all |= CP1_LDO_VOLTAGE_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.tp0145_ldo != I3C_HUB_DT_LDO_NOT_DEFINED) {
+		val = TP0145_LDO_VOLTAGE(i3c_hub_ldo_dt_to_reg(priv->settings.tp0145_ldo));
+		if ((reg_val & TP0145_LDO_VOLTAGE_MASK) != val)
+			ldo_dis |= TP0145_LDO_EN;
+		if (priv->settings.tp0145_ldo != I3C_HUB_DT_LDO_DISABLED)
+			ldo_en |= TP0145_LDO_EN;
+		mask_all |= TP0145_LDO_VOLTAGE_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.tp2367_ldo != I3C_HUB_DT_LDO_NOT_DEFINED) {
+		val = TP2367_LDO_VOLTAGE(i3c_hub_ldo_dt_to_reg(priv->settings.tp2367_ldo));
+		if ((reg_val & TP2367_LDO_VOLTAGE_MASK) != val)
+			ldo_dis |= TP2367_LDO_EN;
+		if (priv->settings.tp2367_ldo != I3C_HUB_DT_LDO_DISABLED)
+			ldo_en |= TP2367_LDO_EN;
+		mask_all |= TP2367_LDO_VOLTAGE_MASK;
+		val_all |= val;
+	}
+
+	/* Disable all LDOs if LDO configuration is going to be changed. */
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_LDO_AND_PULLUP_CONF, ldo_dis, 0);
+	if (ret)
+		return ret;
+
+	/* Set LDOs configuration */
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_LDO_CONF, mask_all, val_all);
+	if (ret)
+		return ret;
+
+	/* Re-enable LDOs if needed */
+	return regmap_update_bits(priv->regmap, I3C_HUB_LDO_AND_PULLUP_CONF, ldo_en, ldo_en);
+}
+
+static int i3c_hub_hw_configure_tp(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	u8 pullup_mask = 0, pullup_val = 0;
+	u8 smbus_mask = 0, smbus_val = 0;
+	u8 gpio_mask = 0, gpio_val = 0;
+	u8 i3c_mask = 0, i3c_val = 0;
+	int ret;
+	int i;
+
+	/* TBD: Read type of HUB from register I3C_HUB_DEV_INFO_0 to learn target ports count. */
+	for (i = 0; i < I3C_HUB_TP_MAX_COUNT; ++i) {
+		if (priv->settings.tp[i].mode != I3C_HUB_DT_TP_MODE_NOT_DEFINED) {
+			i3c_mask |= TPn_NET_CON(i);
+			smbus_mask |= TPn_SMBUS_MODE_EN(i);
+			gpio_mask |= TPn_GPIO_MODE_EN(i);
+
+			if (priv->settings.tp[i].mode == I3C_HUB_DT_TP_MODE_I3C)
+				i3c_val |= TPn_NET_CON(i);
+			else if (priv->settings.tp[i].mode == I3C_HUB_DT_TP_MODE_SMBUS)
+				smbus_val |= TPn_SMBUS_MODE_EN(i);
+			else if (priv->settings.tp[i].mode == I3C_HUB_DT_TP_MODE_GPIO)
+				gpio_val |= TPn_GPIO_MODE_EN(i);
+		}
+		if (priv->settings.tp[i].pullup_en != I3C_HUB_DT_TP_PULLUP_NOT_DEFINED) {
+			pullup_mask |= TPn_PULLUP_EN(i);
+			if (priv->settings.tp[i].pullup_en == I3C_HUB_DT_TP_PULLUP_ENABLED)
+				pullup_val |= TPn_PULLUP_EN(i);
+		}
+	}
+
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_NET_CON_CONF, i3c_mask, i3c_val);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_SMBUS_AGNT_EN, smbus_mask, smbus_val);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_GPIO_MODE_EN, gpio_mask, gpio_val);
+	if (ret)
+		return ret;
+
+	/* Enable TP here in case TP was configured */
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_ENABLE, i3c_mask | smbus_mask | gpio_mask,
+				 i3c_val | smbus_val | gpio_val);
+	if (ret)
+		return ret;
+
+	return regmap_update_bits(priv->regmap, I3C_HUB_TP_PULLUP_EN, pullup_mask, pullup_val);
+}
+
+static int i3c_hub_configure_hw(struct device *dev)
+{
+	int ret;
+
+	ret = i3c_hub_hw_configure_pullup(dev);
+	if (ret)
+		return ret;
+
+	ret = i3c_hub_hw_configure_ldo(dev);
+	if (ret)
+		return ret;
+
+	return i3c_hub_hw_configure_tp(dev);
+}
+
+static const struct i3c_device_id i3c_hub_ids[] = {
+	I3C_CLASS(I3C_DCR_HUB, NULL),
+	{ },
+};
+
+static int fops_access_reg_get(void *ctx, u64 *val)
+{
+	struct i3c_hub *priv = ctx;
+	u32 reg_val;
+	int ret;
+
+	ret = regmap_read(priv->regmap, priv->reg_addr, &reg_val);
+	if (ret)
+		return ret;
+
+	*val = reg_val & 0xFF;
+	return 0;
+}
+
+static int fops_access_reg_set(void *ctx, u64 val)
+{
+	struct i3c_hub *priv = ctx;
+
+	return regmap_write(priv->regmap, priv->reg_addr, val & 0xFF);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_access_reg, fops_access_reg_get, fops_access_reg_set, "0x%llX\n");
+
+static int i3c_hub_debugfs_init(struct i3c_hub *priv, const char *hub_id)
+{
+	struct dentry  *entry, *dt_conf_dir, *reg_dir;
+	int i;
+
+	entry = debugfs_create_dir(hub_id, NULL);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	priv->debug_dir = entry;
+
+	entry = debugfs_create_dir("dt-conf", priv->debug_dir);
+	if (IS_ERR(entry))
+		goto err_remove;
+
+	dt_conf_dir = entry;
+
+	debugfs_create_u8("cp0-ldo", 0400, dt_conf_dir, &priv->settings.cp0_ldo);
+	debugfs_create_u8("cp1-ldo", 0400, dt_conf_dir, &priv->settings.cp1_ldo);
+	debugfs_create_u8("tp0145-ldo", 0400, dt_conf_dir, &priv->settings.tp0145_ldo);
+	debugfs_create_u8("tp2367-ldo", 0400, dt_conf_dir, &priv->settings.tp2367_ldo);
+	debugfs_create_u8("tp0145-pullup", 0400, dt_conf_dir, &priv->settings.tp0145_pullup);
+	debugfs_create_u8("tp2367-pullup", 0400, dt_conf_dir, &priv->settings.tp2367_pullup);
+
+	for (i = 0; i < I3C_HUB_TP_MAX_COUNT; ++i) {
+		char file_name[32];
+
+		sprintf(file_name, "tp%i.mode", i);
+		debugfs_create_u8(file_name, 0400, dt_conf_dir, &priv->settings.tp[i].mode);
+		sprintf(file_name, "tp%i.pullup_en", i);
+		debugfs_create_u8(file_name, 0400, dt_conf_dir, &priv->settings.tp[i].pullup_en);
+	}
+
+	entry = debugfs_create_dir("reg", priv->debug_dir);
+	if (IS_ERR(entry))
+		goto err_remove;
+
+	reg_dir = entry;
+
+	entry = debugfs_create_file_unsafe("access", 0600, reg_dir, priv, &fops_access_reg);
+	if (IS_ERR(entry))
+		goto err_remove;
+
+	debugfs_create_u8("offset", 0600, reg_dir, &priv->reg_addr);
+
+	return 0;
+
+err_remove:
+	debugfs_remove_recursive(priv->debug_dir);
+	return PTR_ERR(entry);
+}
+
+static int i3c_hub_probe(struct i3c_device *i3cdev)
+{
+	struct regmap_config i3c_hub_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	struct device *dev = &i3cdev->dev;
+	struct device_node *node;
+	struct regmap *regmap;
+	struct i3c_hub *priv;
+	char hub_id[32];
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->i3cdev = i3cdev;
+	i3cdev_set_drvdata(i3cdev, priv);
+
+	sprintf(hub_id, "i3c-hub-%d-%llx", i3cdev->bus->id, i3cdev->desc->info.pid);
+	ret = i3c_hub_debugfs_init(priv, hub_id);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to initialized DebugFS.\n");
+
+	i3c_hub_of_default_configuration(dev);
+
+	/* TBD: Support for multiple HUBs. */
+	/* Just get first hub node from DT */
+	node = of_get_child_by_name(dev->parent->of_node, "hub");
+	if (!node) {
+		dev_warn(dev, "Failed to find DT entry for the driver. Running with defaults.\n");
+	} else {
+		i3c_hub_of_get_configuration(dev, node);
+		of_node_put(node);
+	}
+
+	regmap = devm_regmap_init_i3c(i3cdev, &i3c_hub_regmap_config);
+	if (IS_ERR(regmap)) {
+		ret = PTR_ERR(regmap);
+		dev_err(dev, "Failed to register I3C HUB regmap\n");
+		goto error;
+	}
+
+	priv->regmap = regmap;
+
+	/* Unlock access to protected registers */
+	ret = regmap_write(priv->regmap, I3C_HUB_PROTECTION_CODE, REGISTERS_UNLOCK_CODE);
+	if (ret) {
+		dev_err(dev, "Failed to unlock HUB's protected registers\n");
+		goto error;
+	}
+
+	ret = i3c_hub_configure_hw(dev);
+	if (ret) {
+		dev_err(dev, "Failed to configure the HUB\n");
+		goto error;
+	}
+
+	/* Lock access to protected registers */
+	ret = regmap_write(priv->regmap, I3C_HUB_PROTECTION_CODE, REGISTERS_LOCK_CODE);
+	if (ret) {
+		dev_err(dev, "Failed to lock HUB's protected registers\n");
+		goto error;
+	}
+
+	/* TBD: Apply special/security lock here using DEV_CMD register */
+
+	return 0;
+
+error:
+	debugfs_remove_recursive(priv->debug_dir);
+	return ret;
+}
+
+static void i3c_hub_remove(struct i3c_device *i3cdev)
+{
+	struct i3c_hub *priv = i3cdev_get_drvdata(i3cdev);
+
+	debugfs_remove_recursive(priv->debug_dir);
+}
+
+static struct i3c_driver i3c_hub = {
+	.driver.name = "i3c-hub",
+	.id_table = i3c_hub_ids,
+	.probe = i3c_hub_probe,
+	.remove = i3c_hub_remove,
+};
+
+module_i3c_driver(i3c_hub);
+
+MODULE_AUTHOR("Zbigniew Lukwinski <zbigniew.lukwinski@linux.intel.com>");
+MODULE_DESCRIPTION("I3C HUB driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i3c/i3c-ibi-mqueue.c b/drivers/i3c/i3c-ibi-mqueue.c
new file mode 100644
index 000000000000..8250147415c8
--- /dev/null
+++ b/drivers/i3c/i3c-ibi-mqueue.c
@@ -0,0 +1,231 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 Aspeed Technology Inc.
+ */
+
+#include <linux/i3c/device.h>
+#include <linux/i3c/master.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include "internals.h"
+
+#define MQ_MSGBUF_SIZE		256
+#define MQ_QUEUE_SIZE		4
+#define MQ_QUEUE_NEXT(x)	(((x) + 1) & (MQ_QUEUE_SIZE - 1))
+
+#define IBI_STATUS_LAST_FRAG	BIT(24)
+#define PID_MANUF_ID_ASPEED	0x03f6
+
+struct mq_msg {
+	int len;
+	u8 *buf;
+};
+
+struct mq_queue {
+	struct bin_attribute bin;
+	struct kernfs_node *kn;
+
+	spinlock_t lock;
+	int in;
+	int out;
+
+	struct mq_msg *curr;
+	int truncated;
+	struct mq_msg queue[MQ_QUEUE_SIZE];
+};
+
+static void i3c_ibi_mqueue_callback(struct i3c_device *dev,
+				    const struct i3c_ibi_payload *payload)
+{
+	struct mq_queue *mq = dev_get_drvdata(&dev->dev);
+	struct mq_msg *msg = mq->curr;
+	u8 *buf = (u8 *)payload->data;
+	struct i3c_device_info info;
+	u32 status;
+
+	i3c_device_get_info(dev, &info);
+	/* first DW is IBI status */
+	status = *(u32 *)buf;
+
+	/* then the raw data */
+	buf += sizeof(status);
+	memcpy(&msg->buf[msg->len], buf, payload->len - sizeof(status));
+	msg->len += payload->len - sizeof(status);
+
+	/* if last fragment, notify and update pointers */
+	if (status & IBI_STATUS_LAST_FRAG) {
+		/* check pending-read-notification */
+		if (IS_MDB_PENDING_READ_NOTIFY(msg->buf[0])) {
+			struct i3c_priv_xfer xfers[1] = {
+				{
+					.rnw = true,
+					.len = info.max_read_len,
+					.data.in = msg->buf,
+				},
+			};
+
+			i3c_device_do_priv_xfers(dev, xfers, 1);
+
+			msg->len = xfers[0].len;
+		}
+
+		spin_lock(&mq->lock);
+		mq->in = MQ_QUEUE_NEXT(mq->in);
+		mq->curr = &mq->queue[mq->in];
+		mq->curr->len = 0;
+
+		if (mq->out == mq->in)
+			mq->out = MQ_QUEUE_NEXT(mq->out);
+		spin_unlock(&mq->lock);
+		kernfs_notify(mq->kn);
+	}
+}
+
+static ssize_t i3c_ibi_mqueue_bin_read(struct file *filp, struct kobject *kobj,
+				       struct bin_attribute *attr, char *buf,
+				       loff_t pos, size_t count)
+{
+	struct mq_queue *mq;
+	struct mq_msg *msg;
+	unsigned long flags;
+	bool more = false;
+	ssize_t ret = 0;
+
+	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&mq->lock, flags);
+	if (mq->out != mq->in) {
+		msg = &mq->queue[mq->out];
+
+		if (msg->len <= count) {
+			ret = msg->len;
+			memcpy(buf, msg->buf, ret);
+		} else {
+			ret = -EOVERFLOW; /* Drop this HUGE one. */
+		}
+
+		mq->out = MQ_QUEUE_NEXT(mq->out);
+		if (mq->out != mq->in)
+			more = true;
+	}
+	spin_unlock_irqrestore(&mq->lock, flags);
+
+	if (more)
+		kernfs_notify(mq->kn);
+
+	return ret;
+}
+
+static int i3c_ibi_mqueue_probe(struct i3c_device *i3cdev)
+{
+	struct device *dev = &i3cdev->dev;
+	struct mq_queue *mq;
+	struct i3c_ibi_setup ibireq = {};
+	int ret, i;
+	struct i3c_device_info info;
+	void *buf;
+
+	if (dev->type == &i3c_masterdev_type)
+		return -ENOTSUPP;
+
+	mq = devm_kzalloc(dev, sizeof(*mq), GFP_KERNEL);
+	if (!mq)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(!is_power_of_2(MQ_QUEUE_SIZE));
+
+	buf = devm_kmalloc_array(dev, MQ_QUEUE_SIZE, MQ_MSGBUF_SIZE,
+				 GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	for (i = 0; i < MQ_QUEUE_SIZE; i++) {
+		mq->queue[i].buf = buf + i * MQ_MSGBUF_SIZE;
+		mq->queue[i].len = 0;
+	}
+
+	i3c_device_get_info(i3cdev, &info);
+
+	ret = i3c_device_setmrl_ccc(i3cdev, &info, MQ_MSGBUF_SIZE,
+					    min(MQ_MSGBUF_SIZE, __UINT8_MAX__));
+	if (ret) {
+		ret = i3c_device_getmrl_ccc(i3cdev, &info);
+		if (ret)
+			return ret;
+	}
+
+	dev_set_drvdata(dev, mq);
+
+	spin_lock_init(&mq->lock);
+	mq->curr = &mq->queue[0];
+
+	sysfs_bin_attr_init(&mq->bin);
+	mq->bin.attr.name = "ibi-mqueue";
+	mq->bin.attr.mode = 0400;
+	mq->bin.read = i3c_ibi_mqueue_bin_read;
+	mq->bin.size = MQ_MSGBUF_SIZE * MQ_QUEUE_SIZE;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &mq->bin);
+	if (ret)
+		return ret;
+
+	mq->kn = kernfs_find_and_get(dev->kobj.sd, mq->bin.attr.name);
+	if (!mq->kn) {
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return -EFAULT;
+	}
+
+	ibireq.handler = i3c_ibi_mqueue_callback;
+	ibireq.max_payload_len = MQ_MSGBUF_SIZE;
+	ibireq.num_slots = MQ_QUEUE_SIZE;
+
+	ret = i3c_device_request_ibi(i3cdev, &ibireq);
+	ret |= i3c_device_enable_ibi(i3cdev);
+
+	if (ret) {
+		kernfs_put(mq->kn);
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void i3c_ibi_mqueue_remove(struct i3c_device *i3cdev)
+{
+	struct mq_queue *mq = dev_get_drvdata(&i3cdev->dev);
+
+	i3c_device_disable_ibi(i3cdev);
+	i3c_device_free_ibi(i3cdev);
+
+	kernfs_put(mq->kn);
+	sysfs_remove_bin_file(&i3cdev->dev.kobj, &mq->bin);
+}
+
+static const struct i3c_device_id i3c_ibi_mqueue_ids[] = {
+	I3C_DEVICE(0x3f6, 0x8000, (void *)0),
+	I3C_DEVICE(0x3f6, 0x8001, (void *)0),
+	I3C_DEVICE(0x3f6, 0x0503, (void *)0),
+	I3C_DEVICE(0x3f6, 0xA001, (void *)0),
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i3c, i3c_ibi_mqueue_ids);
+
+static struct i3c_driver ibi_mqueue_driver = {
+	.driver = {
+		.name = "i3c-ibi-mqueue",
+	},
+	.probe = i3c_ibi_mqueue_probe,
+	.remove = i3c_ibi_mqueue_remove,
+	.id_table = i3c_ibi_mqueue_ids,
+};
+module_i3c_driver(ibi_mqueue_driver);
+
+MODULE_AUTHOR("Dylan Hung <dylan_hung@aspeedtech.com>");
+MODULE_DESCRIPTION("I3C IBI mqueue driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i3c/i3c-mux-imx3102.c b/drivers/i3c/i3c-mux-imx3102.c
new file mode 100644
index 000000000000..b6972893cbd6
--- /dev/null
+++ b/drivers/i3c/i3c-mux-imx3102.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 Aspeed Technology Inc.
+ *
+ * IMX3102: 2-to-1 multiplexier
+ *
+ * +------------------   +
+ * | SoC                 |
+ * |                     |
+ * | I3C controller #0 - | --+
+ * |                     |    \                  dev   dev
+ * |                     |     +---------+       |     |
+ * |                     |     | IMX3102 | ---+--+--+--+--- i3c bus
+ * |                     |     +---------+    |     |
+ * |                     |    /               dev   dev
+ * | I3C controller #1 - | --+
+ * |                     |
+ * +---------------------+
+ */
+
+#include <linux/i3c/device.h>
+#include <linux/i3c/master.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include <linux/regmap.h>
+#include "internals.h"
+
+#define IMX3102_DEVICE_TYPE_HI		0x0
+#define IMX3102_DEVICE_TYPE_LO		0x1
+
+#define IMX3102_PORT_CONF		0x40
+#define   IMX3102_PORT_CONF_M1_EN	BIT(7)
+#define   IMX3102_PORT_CONF_S_EN	BIT(6)
+#define IMX3102_PORT_SEL		0x41
+#define   IMX3102_PORT_SEL_M1		BIT(7)
+#define   IMX3102_PORT_SEL_S_EN		BIT(6)
+
+struct imx3102 {
+	struct regmap *regmap;
+
+	struct bin_attribute ownership;
+	struct bin_attribute reinit;
+	struct kernfs_node *kn;
+
+	struct i3c_device *i3cdev;
+};
+
+static ssize_t i3c_mux_imx3102_query(struct file *filp, struct kobject *kobj,
+				     struct bin_attribute *attr, char *buf,
+				     loff_t pos, size_t count)
+{
+	struct imx3102 *imx3102;
+	struct device *dev;
+	int ret;
+	u8 data[2];
+
+	imx3102 = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	if (!imx3102)
+		return -1;
+
+	dev = &imx3102->i3cdev->dev;
+
+	ret = regmap_raw_read(imx3102->regmap, IMX3102_DEVICE_TYPE_HI, data, 2);
+	if (ret)
+		sprintf(buf, "N\n");
+	else
+		sprintf(buf, "Y\n");
+
+	return 2;
+}
+
+/* write whatever value to imx3102-mux to release the ownership */
+static ssize_t i3c_mux_imx3102_release_chan(struct file *filp,
+					    struct kobject *kobj,
+					    struct bin_attribute *attr,
+					    char *buf, loff_t pos, size_t count)
+{
+	struct imx3102 *imx3102;
+	struct device *dev;
+	struct regmap *regmap;
+	int ret;
+	u8 select;
+
+	imx3102 = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	if (!imx3102) {
+		count = -1;
+		goto out;
+	}
+
+	dev = &imx3102->i3cdev->dev;
+	regmap = imx3102->regmap;
+	ret = regmap_raw_read(regmap, IMX3102_PORT_SEL, &select, 1);
+	if (ret)
+		goto out;
+
+	/* invert the bit to change the ownership */
+	select ^= IMX3102_PORT_SEL_M1;
+	regmap_raw_write(regmap, IMX3102_PORT_SEL, &select, 1);
+
+out:
+	return count;
+}
+
+static ssize_t i3c_mux_imx3102_bus_reinit(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr, char *buf,
+					  loff_t pos, size_t count)
+{
+	struct imx3102 *imx3102;
+	int ret;
+
+	imx3102 = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	if (!imx3102) {
+		count = -1;
+		return count;
+	}
+
+	ret = i3c_device_send_ccc_cmd(imx3102->i3cdev, I3C_CCC_SETHID);
+	ret = i3c_device_send_ccc_cmd(imx3102->i3cdev, I3C_CCC_SETAASA);
+
+	return count;
+}
+
+static int i3c_mux_imx3102_probe(struct i3c_device *i3cdev)
+{
+	struct device *dev = &i3cdev->dev;
+	struct imx3102 *imx3102;
+	struct regmap *regmap;
+	struct regmap_config imx3102_i3c_regmap_config = {
+		.reg_bits = 8,
+		.pad_bits = 8,
+		.val_bits = 8,
+	};
+	int ret;
+	u8 data[2];
+
+	if (dev->type == &i3c_masterdev_type)
+		return -ENOTSUPP;
+
+	imx3102 = devm_kzalloc(dev, sizeof(*imx3102), GFP_KERNEL);
+	if (!imx3102)
+		return -ENOMEM;
+
+	imx3102->i3cdev = i3cdev;
+
+	/* register regmap */
+	regmap = devm_regmap_init_i3c(i3cdev, &imx3102_i3c_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "Failed to register i3c regmap %d\n",
+			(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+	imx3102->regmap = regmap;
+
+	sysfs_bin_attr_init(&imx3102->ownership);
+	imx3102->ownership.attr.name = "imx3102.ownership";
+	imx3102->ownership.attr.mode = 0600;
+	imx3102->ownership.read = i3c_mux_imx3102_query;
+	imx3102->ownership.write = i3c_mux_imx3102_release_chan;
+	imx3102->ownership.size = 2;
+	ret = sysfs_create_bin_file(&dev->kobj, &imx3102->ownership);
+
+	sysfs_bin_attr_init(&imx3102->reinit);
+	imx3102->reinit.attr.name = "imx3102.reinit";
+	imx3102->reinit.attr.mode = 0200;
+	imx3102->reinit.write = i3c_mux_imx3102_bus_reinit;
+	imx3102->reinit.size = 2;
+	ret = sysfs_create_bin_file(&dev->kobj, &imx3102->reinit);
+
+	imx3102->kn = kernfs_find_and_get(dev->kobj.sd, imx3102->ownership.attr.name);
+	dev_set_drvdata(dev, imx3102);
+
+	ret = regmap_raw_read(regmap, IMX3102_DEVICE_TYPE_HI, data, 2);
+	if (ret) {
+		dev_info(dev, "No ownership\n");
+		return 0;
+	}
+	dev_dbg(dev, "device ID %02x %02x\n", data[0], data[1]);
+
+	/* enable the slave port */
+	regmap_raw_read(regmap, IMX3102_PORT_CONF, &data[0], 2);
+	data[0] |= IMX3102_PORT_CONF_S_EN | IMX3102_PORT_CONF_M1_EN;
+	data[1] |= IMX3102_PORT_SEL_S_EN;
+	regmap_raw_write(regmap, IMX3102_PORT_CONF, data, 2);
+
+	/* send SETAASA to bring the devices behind the mux to I3C mode */
+	i3c_device_send_ccc_cmd(i3cdev, I3C_CCC_SETAASA);
+
+	return 0;
+}
+
+static void i3c_mux_imx3102_remove(struct i3c_device *i3cdev)
+{
+	struct device *dev = &i3cdev->dev;
+	struct imx3102 *imx3102;
+
+	imx3102 = dev_get_drvdata(dev);
+
+	kernfs_put(imx3102->kn);
+	sysfs_remove_bin_file(&dev->kobj, &imx3102->ownership);
+	devm_kfree(dev, imx3102);
+}
+
+static const struct i3c_device_id i3c_mux_imx3102_ids[] = {
+	I3C_DEVICE(0x266, 0x3102, (void *)0),
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i3c, i3c_mux_imx3102_ids);
+
+static struct i3c_driver imx3102_driver = {
+	.driver = {
+		.name = "i3c-mux-imx3102",
+	},
+	.probe = i3c_mux_imx3102_probe,
+	.remove = i3c_mux_imx3102_remove,
+	.id_table = i3c_mux_imx3102_ids,
+};
+module_i3c_driver(imx3102_driver);
+
+MODULE_AUTHOR("Dylan Hung <dylan_hung@aspeedtech.com>");
+MODULE_DESCRIPTION("I3C IMX3102 multiplexer driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i3c/i3c-slave-eeprom.c b/drivers/i3c/i3c-slave-eeprom.c
new file mode 100644
index 000000000000..abc1d693adb4
--- /dev/null
+++ b/drivers/i3c/i3c-slave-eeprom.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022 Aspeed Technology Inc.
+ */
+
+#include <linux/i3c/master.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+struct eeprom_data {
+	struct bin_attribute bin;
+	struct work_struct prep_rdata;
+	spinlock_t buffer_lock;
+	u16 buffer_idx;
+	u16 address_mask;
+	u8 num_address_bytes;
+
+	struct i3c_master_controller *i3c_controller;
+	u8 buffer[];
+};
+
+static void i3c_slave_eeprom_prep_rdata(struct work_struct *work)
+{
+	struct eeprom_data *eeprom = container_of(work, struct eeprom_data, prep_rdata);
+	struct i3c_slave_payload read_data, notify;
+	u32 mdb = IBI_MDB_ID(0b101, 0x1f);
+
+	notify.len = 1;
+	notify.data = &mdb;
+
+	read_data.len = eeprom->address_mask - eeprom->buffer_idx + 1;
+	read_data.data = &eeprom->buffer[eeprom->buffer_idx];
+	i3c_master_put_read_data(eeprom->i3c_controller, &read_data, &notify);
+}
+
+static void i3c_slave_eeprom_callback(struct i3c_master_controller *master,
+				      const struct i3c_slave_payload *payload)
+{
+	struct eeprom_data *eeprom = dev_get_drvdata(&master->dev);
+	int wr_len;
+	u8 *buf = (u8 *)payload->data;
+
+	if (!payload->len)
+		return;
+
+	if (eeprom->num_address_bytes == 2)
+		eeprom->buffer_idx = ((u16)buf[0] << 8) | buf[1];
+	else
+		eeprom->buffer_idx = (u16)buf[0];
+
+	wr_len = payload->len - eeprom->num_address_bytes;
+
+	pr_debug("len = %d, index=%d, wr_len=%d\n", payload->len,
+		 eeprom->buffer_idx, wr_len);
+
+	if (wr_len > 0) {
+		if (eeprom->buffer_idx + wr_len > eeprom->address_mask) {
+			u16 len = eeprom->address_mask - eeprom->buffer_idx + 1;
+
+			memcpy(&eeprom->buffer[eeprom->buffer_idx],
+			       &buf[eeprom->num_address_bytes], len);
+			memcpy(&eeprom->buffer[0],
+			       &buf[eeprom->num_address_bytes + len],
+			       wr_len - len);
+		} else {
+			memcpy(&eeprom->buffer[eeprom->buffer_idx],
+			       &buf[eeprom->num_address_bytes], wr_len);
+		}
+
+		eeprom->buffer_idx += wr_len;
+		eeprom->buffer_idx &= eeprom->address_mask;
+	}
+
+	/* prepare the read data outside of interrupt context */
+	schedule_work(&eeprom->prep_rdata);
+}
+
+static ssize_t i3c_slave_eeprom_bin_read(struct file *filp,
+					 struct kobject *kobj,
+					 struct bin_attribute *attr, char *buf,
+					 loff_t off, size_t count)
+{
+	struct eeprom_data *eeprom;
+	unsigned long flags;
+
+	eeprom = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&eeprom->buffer_lock, flags);
+	memcpy(buf, &eeprom->buffer[off], count);
+	spin_unlock_irqrestore(&eeprom->buffer_lock, flags);
+
+	return count;
+}
+
+static ssize_t i3c_slave_eeprom_bin_write(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr, char *buf,
+					  loff_t off, size_t count)
+{
+	struct eeprom_data *eeprom;
+	unsigned long flags;
+
+	eeprom = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&eeprom->buffer_lock, flags);
+	memcpy(&eeprom->buffer[off], buf, count);
+	spin_unlock_irqrestore(&eeprom->buffer_lock, flags);
+
+	return count;
+}
+
+int i3c_slave_eeprom_probe(struct i3c_master_controller *master)
+{
+	struct eeprom_data *eeprom;
+	int ret;
+	struct i3c_slave_setup req = {};
+	struct device *dev = &master->dev;
+
+	/* fixed parameters for testing: size 64 bytes, address size is 1 byte */
+	unsigned int size = 64;
+	unsigned int flag_addr16 = 0;
+
+	eeprom = devm_kzalloc(dev, sizeof(struct eeprom_data) + size, GFP_KERNEL);
+	if (!eeprom)
+		return -ENOMEM;
+
+	eeprom->num_address_bytes = flag_addr16 ? 2 : 1;
+	eeprom->address_mask = size - 1;
+	spin_lock_init(&eeprom->buffer_lock);
+	dev_set_drvdata(dev, eeprom);
+
+	memset(eeprom->buffer, 0xff, size);
+
+	sysfs_bin_attr_init(&eeprom->bin);
+	eeprom->bin.attr.name = "slave-eeprom";
+	eeprom->bin.attr.mode = 0600;
+	eeprom->bin.read = i3c_slave_eeprom_bin_read;
+	eeprom->bin.write = i3c_slave_eeprom_bin_write;
+	eeprom->bin.size = size;
+
+	eeprom->i3c_controller = master;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &eeprom->bin);
+	if (ret)
+		return ret;
+
+	INIT_WORK(&eeprom->prep_rdata, i3c_slave_eeprom_prep_rdata);
+
+	req.handler = i3c_slave_eeprom_callback;
+	req.max_payload_len = size;
+	req.num_slots = 1;
+
+	ret = i3c_master_register_slave(master, &req);
+	if (ret) {
+		sysfs_remove_bin_file(&dev->kobj, &eeprom->bin);
+		return ret;
+	}
+
+	return 0;
+}
+
+int i3c_slave_eeprom_remove(struct i3c_master_controller *master)
+{
+	struct device *dev = &master->dev;
+	struct eeprom_data *eeprom = dev_get_drvdata(dev);
+
+	i3c_master_unregister_slave(master);
+	sysfs_remove_bin_file(&dev->kobj, &eeprom->bin);
+
+	return 0;
+}
diff --git a/drivers/i3c/i3c-slave-mqueue.c b/drivers/i3c/i3c-slave-mqueue.c
new file mode 100644
index 000000000000..ff05ee4e7de8
--- /dev/null
+++ b/drivers/i3c/i3c-slave-mqueue.c
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 Aspeed Technology Inc.
+ */
+
+#include <linux/i3c/master.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+#define MQ_MSGBUF_SIZE		256
+#define MQ_QUEUE_SIZE		4
+#define MQ_QUEUE_NEXT(x)	(((x) + 1) & (MQ_QUEUE_SIZE - 1))
+
+#define IBI_STATUS_LAST_FRAG	BIT(24)
+#define MQ_MDB			IBI_MDB_ID(0b101, 0x1f)
+
+struct mq_msg {
+	int len;
+	u8 *buf;
+};
+
+struct mq_queue {
+	struct bin_attribute bin;
+	struct kernfs_node *kn;
+
+	spinlock_t lock;
+	int in;
+	int out;
+
+	struct mq_msg *curr;
+	int truncated;
+	struct mq_msg queue[MQ_QUEUE_SIZE];
+
+	struct i3c_master_controller *i3c_controller;
+	u8 mdb;
+};
+
+static void i3c_slave_mqueue_callback(struct i3c_master_controller *master,
+				      const struct i3c_slave_payload *payload)
+{
+	struct mq_queue *mq = dev_get_drvdata(&master->dev);
+	struct mq_msg *msg = mq->curr;
+
+	memcpy(msg->buf, (u8 *)payload->data, payload->len);
+	msg->len = payload->len;
+
+	spin_lock(&mq->lock);
+	mq->in = MQ_QUEUE_NEXT(mq->in);
+	mq->curr = &mq->queue[mq->in];
+	mq->curr->len = 0;
+
+	if (mq->out == mq->in)
+		mq->out = MQ_QUEUE_NEXT(mq->out);
+	spin_unlock(&mq->lock);
+	kernfs_notify(mq->kn);
+}
+
+static ssize_t i3c_slave_mqueue_bin_read(struct file *filp, struct kobject *kobj,
+				       struct bin_attribute *attr, char *buf,
+				       loff_t pos, size_t count)
+{
+	struct mq_queue *mq;
+	struct mq_msg *msg;
+	unsigned long flags;
+	bool more = false;
+	ssize_t ret = 0;
+
+	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&mq->lock, flags);
+	if (mq->out != mq->in) {
+		msg = &mq->queue[mq->out];
+
+		if (msg->len <= count) {
+			ret = msg->len;
+			memcpy(buf, msg->buf, ret);
+		} else {
+			ret = -EOVERFLOW; /* Drop this HUGE one. */
+		}
+
+		mq->out = MQ_QUEUE_NEXT(mq->out);
+		if (mq->out != mq->in)
+			more = true;
+	}
+	spin_unlock_irqrestore(&mq->lock, flags);
+
+	if (more)
+		kernfs_notify(mq->kn);
+
+	return ret;
+}
+
+static ssize_t i3c_slave_mqueue_bin_write(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr, char *buf,
+					  loff_t pos, size_t count)
+{
+	struct mq_queue *mq;
+	struct i3c_slave_payload payload, ibi;
+	u8 *data;
+
+	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	if (IS_MDB_PENDING_READ_NOTIFY(mq->mdb)) {
+		ibi.data = &mq->mdb;
+		ibi.len = 1;
+		payload.data = buf;
+		payload.len = count;
+		i3c_master_put_read_data(mq->i3c_controller, &payload, &ibi);
+	} else {
+		data = kmalloc(count + 1, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		data[0] = mq->mdb;
+		memcpy(&data[1], buf, count);
+
+		payload.data = data;
+		payload.len = count + 1;
+		i3c_master_send_sir(mq->i3c_controller, &payload);
+		kfree(data);
+	}
+
+	return count;
+}
+
+int i3c_slave_mqueue_probe(struct i3c_master_controller *master)
+{
+	struct mq_queue *mq;
+	int ret, i;
+	void *buf;
+	struct i3c_slave_setup req = {};
+	struct device *dev = &master->dev;
+
+	mq = devm_kzalloc(dev, sizeof(*mq), GFP_KERNEL);
+	if (!mq)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(!is_power_of_2(MQ_QUEUE_SIZE));
+
+	buf = devm_kmalloc_array(dev, MQ_QUEUE_SIZE, MQ_MSGBUF_SIZE,
+				 GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	for (i = 0; i < MQ_QUEUE_SIZE; i++) {
+		mq->queue[i].buf = buf + i * MQ_MSGBUF_SIZE;
+		mq->queue[i].len = 0;
+	}
+
+	dev_set_drvdata(dev, mq);
+
+	spin_lock_init(&mq->lock);
+	mq->curr = &mq->queue[0];
+
+	sysfs_bin_attr_init(&mq->bin);
+	mq->bin.attr.name = "slave-mqueue";
+	mq->bin.attr.mode = 0600;
+	mq->bin.read = i3c_slave_mqueue_bin_read;
+	mq->bin.write = i3c_slave_mqueue_bin_write;
+	mq->bin.size = MQ_MSGBUF_SIZE * MQ_QUEUE_SIZE;
+
+	mq->i3c_controller = master;
+	mq->mdb = MQ_MDB;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &mq->bin);
+	if (ret)
+		return ret;
+
+	mq->kn = kernfs_find_and_get(dev->kobj.sd, mq->bin.attr.name);
+	if (!mq->kn) {
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return -EFAULT;
+	}
+
+	req.handler = i3c_slave_mqueue_callback;
+	req.max_payload_len = MQ_MSGBUF_SIZE;
+	req.num_slots = MQ_QUEUE_SIZE;
+
+	ret = i3c_master_register_slave(master, &req);
+
+	if (ret) {
+		kernfs_put(mq->kn);
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return ret;
+	}
+
+	return 0;
+}
+
+int i3c_slave_mqueue_remove(struct i3c_master_controller *master)
+{
+	struct device *dev = &master->dev;
+	struct mq_queue *mq = dev_get_drvdata(dev);
+
+	i3c_master_unregister_slave(master);
+
+	kernfs_put(mq->kn);
+	sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+
+	return 0;
+}
diff --git a/drivers/i3c/i3cdev.c b/drivers/i3c/i3cdev.c
index fd8f2695d775..f1eeb24a5e74 100644
--- a/drivers/i3c/i3cdev.c
+++ b/drivers/i3c/i3cdev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2019 Synopsys, Inc. and/or its affiliates.
+ * Copyright (c) 2020 Synopsys, Inc. and/or its affiliates.
  *
  * Author: Vitor Soares <soares@synopsys.com>
  */
@@ -12,7 +12,6 @@
 #include <linux/init.h>
 #include <linux/jiffies.h>
 #include <linux/kernel.h>
-#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/notifier.h>
 #include <linux/slab.h>
@@ -23,36 +22,16 @@
 #include "internals.h"
 
 struct i3cdev_data {
-	struct list_head list;
 	struct i3c_device *i3c;
-	struct cdev cdev;
 	struct device *dev;
+	struct mutex xfer_lock; /* prevent detach while transferring */
+	struct cdev cdev;
 	int id;
 };
 
 static DEFINE_IDA(i3cdev_ida);
 static dev_t i3cdev_number;
-#define I3C_MINORS 32 /* 32 I3C devices supported for now */
-
-static LIST_HEAD(i3cdev_list);
-static DEFINE_SPINLOCK(i3cdev_list_lock);
-
-static struct i3cdev_data *i3cdev_get_by_i3c(struct i3c_device *i3c)
-{
-	struct i3cdev_data *i3cdev;
-
-	spin_lock(&i3cdev_list_lock);
-	list_for_each_entry(i3cdev, &i3cdev_list, list) {
-		if (i3cdev->i3c == i3c)
-			goto found;
-	}
-
-	i3cdev = NULL;
-
-found:
-	spin_unlock(&i3cdev_list_lock);
-	return i3cdev;
-}
+#define I3C_MINORS (MINORMASK + 1)
 
 static struct i3cdev_data *get_free_i3cdev(struct i3c_device *i3c)
 {
@@ -73,32 +52,32 @@ static struct i3cdev_data *get_free_i3cdev(struct i3c_device *i3c)
 
 	i3cdev->i3c = i3c;
 	i3cdev->id = id;
-
-	spin_lock(&i3cdev_list_lock);
-	list_add_tail(&i3cdev->list, &i3cdev_list);
-	spin_unlock(&i3cdev_list_lock);
+	i3cdev_set_drvdata(i3c, i3cdev);
 
 	return i3cdev;
 }
 
 static void put_i3cdev(struct i3cdev_data *i3cdev)
 {
-	spin_lock(&i3cdev_list_lock);
-	list_del(&i3cdev->list);
-	spin_unlock(&i3cdev_list_lock);
+	i3cdev_set_drvdata(i3cdev->i3c, NULL);
 	kfree(i3cdev);
 }
 
 static ssize_t
 i3cdev_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
 {
-	struct i3c_device *i3c = file->private_data;
+	struct i3cdev_data *i3cdev = file->private_data;
+	struct i3c_device *i3c = i3cdev->i3c;
 	struct i3c_priv_xfer xfers = {
 		.rnw = true,
 		.len = count,
 	};
+	int ret = -EACCES;
 	char *tmp;
-	int ret;
+
+	mutex_lock(&i3cdev->xfer_lock);
+	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
+		goto err_out;
 
 	tmp = kzalloc(count, GFP_KERNEL);
 	if (!tmp)
@@ -110,9 +89,12 @@ i3cdev_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
 
 	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
 	if (!ret)
-		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;
+		ret = copy_to_user(buf, tmp, xfers.len) ? -EFAULT : xfers.len;
 
 	kfree(tmp);
+
+err_out:
+	mutex_unlock(&i3cdev->xfer_lock);
 	return ret;
 }
 
@@ -120,13 +102,18 @@ static ssize_t
 i3cdev_write(struct file *file, const char __user *buf, size_t count,
 	     loff_t *f_pos)
 {
-	struct i3c_device *i3c = file->private_data;
+	struct i3cdev_data *i3cdev = file->private_data;
+	struct i3c_device *i3c = i3cdev->i3c;
 	struct i3c_priv_xfer xfers = {
 		.rnw = false,
 		.len = count,
 	};
+	int ret = -EACCES;
 	char *tmp;
-	int ret;
+
+	mutex_lock(&i3cdev->xfer_lock);
+	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
+		goto err_out;
 
 	tmp = memdup_user(buf, count);
 	if (IS_ERR(tmp))
@@ -138,6 +125,9 @@ i3cdev_write(struct file *file, const char __user *buf, size_t count,
 
 	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
 	kfree(tmp);
+
+err_out:
+	mutex_unlock(&i3cdev->xfer_lock);
 	return (!ret) ? count : ret;
 }
 
@@ -149,15 +139,14 @@ i3cdev_do_priv_xfer(struct i3c_device *dev, struct i3c_ioc_priv_xfer *xfers,
 	u8 **data_ptrs;
 	int i, ret = 0;
 
-	k_xfers = kcalloc(nxfers, sizeof(*k_xfers), GFP_KERNEL);
+	/* Since we have nxfers we may allocate k_xfer + *data_ptrs together */
+	k_xfers = kcalloc(nxfers, sizeof(*k_xfers) + sizeof(*data_ptrs),
+			  GFP_KERNEL);
 	if (!k_xfers)
 		return -ENOMEM;
 
-	data_ptrs = kcalloc(nxfers, sizeof(*data_ptrs), GFP_KERNEL);
-	if (!data_ptrs) {
-		ret = -ENOMEM;
-		goto err_free_k_xfer;
-	}
+	/* set data_ptrs to be after nxfers * i3c_priv_xfer */
+	data_ptrs = (void *)k_xfers + (nxfers * sizeof(*k_xfers));
 
 	for (i = 0; i < nxfers; i++) {
 		data_ptrs[i] = memdup_user((const u8 __user *)
@@ -189,7 +178,7 @@ i3cdev_do_priv_xfer(struct i3c_device *dev, struct i3c_ioc_priv_xfer *xfers,
 
 	for (i = 0; i < nxfers; i++) {
 		if (xfers[i].rnw) {
-			if (copy_to_user((void __user *)(uintptr_t)xfers[i].data,
+			if (copy_to_user(u64_to_user_ptr(xfers[i].data),
 					 data_ptrs[i], xfers[i].len))
 				ret = -EFAULT;
 		}
@@ -198,8 +187,6 @@ i3cdev_do_priv_xfer(struct i3c_device *dev, struct i3c_ioc_priv_xfer *xfers,
 err_free_mem:
 	for (; i >= 0; i--)
 		kfree(data_ptrs[i]);
-	kfree(data_ptrs);
-err_free_k_xfer:
 	kfree(k_xfers);
 	return ret;
 }
@@ -215,7 +202,7 @@ i3cdev_get_ioc_priv_xfer(unsigned int cmd, struct i3c_ioc_priv_xfer *u_xfers,
 
 	*nxfers = tmp / sizeof(struct i3c_ioc_priv_xfer);
 	if (*nxfers == 0)
-		return NULL;
+		return ERR_PTR(-EINVAL);
 
 	return memdup_user(u_xfers, tmp);
 }
@@ -229,7 +216,7 @@ i3cdev_ioc_priv_xfer(struct i3c_device *i3c, unsigned int cmd,
 	int ret;
 
 	k_xfers = i3cdev_get_ioc_priv_xfer(cmd, u_xfers, &nxfers);
-	if (IS_ERR_OR_NULL(k_xfers))
+	if (IS_ERR(k_xfers))
 		return PTR_ERR(k_xfers);
 
 	ret = i3cdev_do_priv_xfer(i3c, k_xfers, nxfers);
@@ -242,20 +229,29 @@ i3cdev_ioc_priv_xfer(struct i3c_device *i3c, unsigned int cmd,
 static long
 i3cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct i3c_device *i3c = file->private_data;
+	struct i3cdev_data *i3cdev = file->private_data;
+	struct i3c_device *i3c = i3cdev->i3c;
+	int ret = -EACCES;
 
 	dev_dbg(&i3c->dev, "ioctl, cmd=0x%02x, arg=0x%02lx\n", cmd, arg);
 
 	if (_IOC_TYPE(cmd) != I3C_DEV_IOC_MAGIC)
 		return -ENOTTY;
 
+	/* Use the xfer_lock to prevent device detach during ioctl call */
+	mutex_lock(&i3cdev->xfer_lock);
+	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
+		goto err_no_dev;
+
 	/* Check command number and direction */
 	if (_IOC_NR(cmd) == _IOC_NR(I3C_IOC_PRIV_XFER(0)) &&
 	    _IOC_DIR(cmd) == (_IOC_READ | _IOC_WRITE))
-		return i3cdev_ioc_priv_xfer(i3c, cmd,
+		ret = i3cdev_ioc_priv_xfer(i3c, cmd,
 					(struct i3c_ioc_priv_xfer __user *)arg);
 
-	return 0;
+err_no_dev:
+	mutex_unlock(&i3cdev->xfer_lock);
+	return ret;
 }
 
 static int i3cdev_open(struct inode *inode, struct file *file)
@@ -263,8 +259,7 @@ static int i3cdev_open(struct inode *inode, struct file *file)
 	struct i3cdev_data *i3cdev = container_of(inode->i_cdev,
 						  struct i3cdev_data,
 						  cdev);
-
-	file->private_data = i3cdev->i3c;
+	file->private_data = i3cdev;
 
 	return 0;
 }
@@ -281,6 +276,7 @@ static const struct file_operations i3cdev_fops = {
 	.read		= i3cdev_read,
 	.write		= i3cdev_write,
 	.unlocked_ioctl	= i3cdev_ioctl,
+	.compat_ioctl	= compat_ptr_ioctl,
 	.open		= i3cdev_open,
 	.release	= i3cdev_release,
 };
@@ -295,7 +291,10 @@ static int i3cdev_attach(struct device *dev, void *dummy)
 	struct i3c_device *i3c;
 	int res;
 
-	if (dev->type == &i3c_masterdev_type || dev->driver)
+	if (dev->type == &i3c_masterdev_type)
+		return 0;
+
+	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && dev->driver)
 		return 0;
 
 	i3c = dev_to_i3cdev(dev);
@@ -305,6 +304,7 @@ static int i3cdev_attach(struct device *dev, void *dummy)
 	if (IS_ERR(i3cdev))
 		return PTR_ERR(i3cdev);
 
+	mutex_init(&i3cdev->xfer_lock);
 	cdev_init(&i3cdev->cdev, &i3cdev_fops);
 	i3cdev->cdev.owner = THIS_MODULE;
 	res = cdev_add(&i3cdev->cdev,
@@ -315,7 +315,7 @@ static int i3cdev_attach(struct device *dev, void *dummy)
 	/* register this i3c device with the driver core */
 	i3cdev->dev = device_create(i3cdev_class, &i3c->dev,
 				    MKDEV(MAJOR(i3cdev_number), i3cdev->id),
-				    NULL, "i3c-%s", dev_name(&i3c->dev));
+				    NULL, "bus!i3c!%s", dev_name(&i3c->dev));
 	if (IS_ERR(i3cdev->dev)) {
 		res = PTR_ERR(i3cdev->dev);
 		goto error;
@@ -341,12 +341,16 @@ static int i3cdev_detach(struct device *dev, void *dummy)
 
 	i3c = dev_to_i3cdev(dev);
 
-	i3cdev = i3cdev_get_by_i3c(i3c);
+	i3cdev = i3cdev_get_drvdata(i3c);
 	if (!i3cdev)
 		return 0;
 
+	/* Prevent transfers while cdev removal */
+	mutex_lock(&i3cdev->xfer_lock);
 	cdev_del(&i3cdev->cdev);
 	device_destroy(i3cdev_class, MKDEV(MAJOR(i3cdev_number), i3cdev->id));
+	mutex_unlock(&i3cdev->xfer_lock);
+
 	ida_simple_remove(&i3cdev_ida, i3cdev->id);
 	put_i3cdev(i3cdev);
 
@@ -365,8 +369,12 @@ static int i3cdev_notifier_call(struct notifier_block *nb,
 	case BUS_NOTIFY_ADD_DEVICE:
 	case BUS_NOTIFY_UNBOUND_DRIVER:
 		return i3cdev_attach(dev, NULL);
+	case BUS_NOTIFY_BIND_DRIVER:
+		if (IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE))
+			break;
+
+		fallthrough;
 	case BUS_NOTIFY_DEL_DEVICE:
-	case BUS_NOTIFY_BOUND_DRIVER:
 	case BUS_NOTIFY_REMOVED_DEVICE:
 		return i3cdev_detach(dev, NULL);
 	}
@@ -374,7 +382,7 @@ static int i3cdev_notifier_call(struct notifier_block *nb,
 	return 0;
 }
 
-static struct notifier_block i3c_notifier = {
+static struct notifier_block i3cdev_notifier = {
 	.notifier_call = i3cdev_notifier_call,
 };
 
@@ -395,7 +403,7 @@ static int __init i3cdev_init(void)
 	}
 
 	/* Keep track of busses which have devices to add or remove later */
-	res = bus_register_notifier(&i3c_bus_type, &i3c_notifier);
+	res = bus_register_notifier(&i3c_bus_type, &i3cdev_notifier);
 	if (res)
 		goto out_unreg_class;
 
@@ -415,7 +423,7 @@ static int __init i3cdev_init(void)
 
 static void __exit i3cdev_exit(void)
 {
-	bus_unregister_notifier(&i3c_bus_type, &i3c_notifier);
+	bus_unregister_notifier(&i3c_bus_type, &i3cdev_notifier);
 	i3c_for_each_dev(NULL, i3cdev_detach);
 	class_destroy(i3cdev_class);
 	unregister_chrdev_region(i3cdev_number, I3C_MINORS);
diff --git a/drivers/i3c/internals.h b/drivers/i3c/internals.h
index a6deedf5ce06..dcba885ecc4e 100644
--- a/drivers/i3c/internals.h
+++ b/drivers/i3c/internals.h
@@ -9,6 +9,7 @@
 #define I3C_INTERNALS_H
 
 #include <linux/i3c/master.h>
+#include <linux/i3c/target.h>
 
 extern struct bus_type i3c_bus_type;
 extern const struct device_type i3c_masterdev_type;
@@ -24,5 +25,15 @@ int i3c_dev_enable_ibi_locked(struct i3c_dev_desc *dev);
 int i3c_dev_request_ibi_locked(struct i3c_dev_desc *dev,
 			       const struct i3c_ibi_setup *req);
 void i3c_dev_free_ibi_locked(struct i3c_dev_desc *dev);
+int i3c_dev_send_ccc_cmd_locked(struct i3c_dev_desc *dev, u8 ccc_id);
+int i3c_dev_getstatus_locked(struct i3c_dev_desc *dev, struct i3c_device_info *info);
+int i3c_master_getmrl_locked(struct i3c_master_controller *master, struct i3c_device_info *info);
+int i3c_master_getmwl_locked(struct i3c_master_controller *master, struct i3c_device_info *info);
+int i3c_master_setmrl_locked(struct i3c_master_controller *master,
+			     struct i3c_device_info *info, u16 read_len, u8 ibi_len);
+int i3c_master_setmwl_locked(struct i3c_master_controller *master,
+			     struct i3c_device_info *info, u16 write_len);
 int i3c_for_each_dev(void *data, int (*fn)(struct device *, void *));
+int i3c_dev_generate_ibi_locked(struct i3c_dev_desc *dev, const u8 *data, int len);
+int i3c_dev_control_pec(struct i3c_dev_desc *dev, bool pec);
 #endif /* I3C_INTERNAL_H */
diff --git a/drivers/i3c/master.c b/drivers/i3c/master.c
index 2002fa667542..3b6e02bebd3b 100644
--- a/drivers/i3c/master.c
+++ b/drivers/i3c/master.c
@@ -262,6 +262,24 @@ static ssize_t modalias_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(modalias);
 
+static ssize_t bus_reset_store(struct device *dev, struct device_attribute *da,
+			       const char *buf, size_t count)
+{
+	struct i3c_master_controller *master;
+	ssize_t ret = count;
+
+	master = dev_to_i3cmaster(dev);
+	dev_dbg(&master->dev, "Reset bus to return to i2c_mode...\n");
+	i3c_bus_maintenance_lock(&master->bus);
+	if (master->ops->bus_reset)
+		master->ops->bus_reset(master);
+
+	i3c_bus_maintenance_unlock(&master->bus);
+
+	return ret;
+}
+static DEVICE_ATTR_WO(bus_reset);
+
 static struct attribute *i3c_device_attrs[] = {
 	&dev_attr_bcr.attr,
 	&dev_attr_dcr.attr,
@@ -298,19 +316,24 @@ static const struct device_type i3c_device_type = {
 	.uevent = i3c_device_uevent,
 };
 
+const struct device_type i3c_target_device_type = {
+};
+
 static int i3c_device_match(struct device *dev, struct device_driver *drv)
 {
 	struct i3c_device *i3cdev;
 	struct i3c_driver *i3cdrv;
 
-	if (dev->type != &i3c_device_type)
+	if (dev->type != &i3c_device_type && dev->type != &i3c_target_device_type)
 		return 0;
 
 	i3cdev = dev_to_i3cdev(dev);
 	i3cdrv = drv_to_i3cdrv(drv);
-	if (i3c_device_match_id(i3cdev, i3cdrv->id_table))
-		return 1;
 
+	if ((dev->type == &i3c_device_type && !i3cdrv->target) ||
+	    (dev->type == &i3c_target_device_type && i3cdrv->target))
+		if (i3c_device_match_id(i3cdev, i3cdrv->id_table))
+			return 1;
 	return 0;
 }
 
@@ -330,7 +353,8 @@ static void i3c_device_remove(struct device *dev)
 	if (driver->remove)
 		driver->remove(i3cdev);
 
-	i3c_device_free_ibi(i3cdev);
+	if (!driver->target)
+		i3c_device_free_ibi(i3cdev);
 }
 
 struct bus_type i3c_bus_type = {
@@ -339,6 +363,7 @@ struct bus_type i3c_bus_type = {
 	.probe = i3c_device_probe,
 	.remove = i3c_device_remove,
 };
+EXPORT_SYMBOL_GPL(i3c_bus_type);
 
 static enum i3c_addr_slot_status
 i3c_bus_get_addr_slot_status(struct i3c_bus *bus, u16 addr)
@@ -524,6 +549,7 @@ static struct attribute *i3c_masterdev_attrs[] = {
 	&dev_attr_pid.attr,
 	&dev_attr_dynamic_address.attr,
 	&dev_attr_hdrcap.attr,
+	&dev_attr_bus_reset.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(i3c_masterdev);
@@ -545,6 +571,7 @@ static void i3c_masterdev_release(struct device *dev)
 const struct device_type i3c_masterdev_type = {
 	.groups	= i3c_masterdev_groups,
 };
+EXPORT_SYMBOL_GPL(i3c_masterdev_type);
 
 static int i3c_bus_set_mode(struct i3c_bus *i3cbus, enum i3c_bus_mode mode,
 			    unsigned long max_i2c_scl_rate)
@@ -609,7 +636,7 @@ static void i3c_master_free_i2c_dev(struct i2c_dev_desc *dev)
 
 static struct i2c_dev_desc *
 i3c_master_alloc_i2c_dev(struct i3c_master_controller *master,
-			 const struct i2c_dev_boardinfo *boardinfo)
+			 u16 addr, u8 lvr)
 {
 	struct i2c_dev_desc *dev;
 
@@ -618,9 +645,8 @@ i3c_master_alloc_i2c_dev(struct i3c_master_controller *master,
 		return ERR_PTR(-ENOMEM);
 
 	dev->common.master = master;
-	dev->boardinfo = boardinfo;
-	dev->addr = boardinfo->base.addr;
-	dev->lvr = boardinfo->lvr;
+	dev->addr = addr;
+	dev->lvr = lvr;
 
 	return dev;
 }
@@ -645,13 +671,15 @@ static void i3c_ccc_cmd_dest_cleanup(struct i3c_ccc_cmd_dest *dest)
 
 static void i3c_ccc_cmd_init(struct i3c_ccc_cmd *cmd, bool rnw, u8 id,
 			     struct i3c_ccc_cmd_dest *dests,
-			     unsigned int ndests)
+			     unsigned int ndests, bool dbp, u8 db)
 {
 	cmd->rnw = rnw ? 1 : 0;
 	cmd->id = id;
 	cmd->dests = dests;
 	cmd->ndests = ndests;
 	cmd->err = I3C_ERROR_UNKNOWN;
+	cmd->dbp = dbp;
+	cmd->db = db;
 }
 
 static int i3c_master_send_ccc_cmd_locked(struct i3c_master_controller *master,
@@ -694,7 +722,7 @@ i3c_master_find_i2c_dev_by_addr(const struct i3c_master_controller *master,
 	struct i2c_dev_desc *dev;
 
 	i3c_bus_for_each_i2cdev(&master->bus, dev) {
-		if (dev->boardinfo->base.addr == addr)
+		if (dev->addr == addr)
 			return dev;
 	}
 
@@ -750,7 +778,7 @@ i3c_master_alloc_i3c_dev(struct i3c_master_controller *master,
 	return dev;
 }
 
-static int i3c_master_rstdaa_locked(struct i3c_master_controller *master,
+int i3c_master_rstdaa_locked(struct i3c_master_controller *master,
 				    u8 addr)
 {
 	enum i3c_addr_slot_status addrstat;
@@ -768,26 +796,13 @@ static int i3c_master_rstdaa_locked(struct i3c_master_controller *master,
 	i3c_ccc_cmd_dest_init(&dest, addr, 0);
 	i3c_ccc_cmd_init(&cmd, false,
 			 I3C_CCC_RSTDAA(addr == I3C_BROADCAST_ADDR),
-			 &dest, 1);
-	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
-	i3c_ccc_cmd_dest_cleanup(&dest);
-
-	return ret;
-}
-
-static int i3c_master_setaasa_locked(struct i3c_master_controller *master)
-{
-	struct i3c_ccc_cmd_dest dest;
-	struct i3c_ccc_cmd cmd;
-	int ret;
-
-	i3c_ccc_cmd_dest_init(&dest, I3C_BROADCAST_ADDR, 0);
-	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETAASA, &dest, 1);
+			 &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(i3c_master_rstdaa_locked);
 
 /**
  * i3c_master_entdaa_locked() - start a DAA (Dynamic Address Assignment)
@@ -812,7 +827,7 @@ int i3c_master_entdaa_locked(struct i3c_master_controller *master)
 	int ret;
 
 	i3c_ccc_cmd_dest_init(&dest, I3C_BROADCAST_ADDR, 0);
-	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_ENTDAA, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_ENTDAA, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
 
@@ -837,7 +852,7 @@ static int i3c_master_enec_disec_locked(struct i3c_master_controller *master,
 			 enable ?
 			 I3C_CCC_ENEC(addr == I3C_BROADCAST_ADDR) :
 			 I3C_CCC_DISEC(addr == I3C_BROADCAST_ADDR),
-			 &dest, 1);
+			 &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
 
@@ -970,7 +985,7 @@ int i3c_master_defslvs_locked(struct i3c_master_controller *master)
 		desc++;
 	}
 
-	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_DEFSLVS, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_DEFSLVS, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
 
@@ -996,7 +1011,22 @@ static int i3c_master_setda_locked(struct i3c_master_controller *master,
 	setda->addr = newaddr << 1;
 	i3c_ccc_cmd_init(&cmd, false,
 			 setdasa ? I3C_CCC_SETDASA : I3C_CCC_SETNEWDA,
-			 &dest, 1);
+			 &dest, 1, false, 0);
+	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
+	i3c_ccc_cmd_dest_cleanup(&dest);
+
+	return ret;
+}
+
+static int i3c_master_setaasa_locked(struct i3c_master_controller *master)
+{
+	struct i3c_ccc_cmd_dest dest;
+	struct i3c_ccc_cmd cmd;
+	int ret;
+
+	i3c_ccc_cmd_dest_init(&dest, I3C_BROADCAST_ADDR, 0);
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETAASA, &dest, 1, false, 0);
+
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
 
@@ -1027,7 +1057,7 @@ static int i3c_master_sethid_locked(struct i3c_master_controller *master)
 		return -ENOMEM;
 
 	sethid->hid = 0;
-	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETHID, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETHID, &dest, 1, false, 0);
 
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	i3c_ccc_cmd_dest_cleanup(&dest);
@@ -1035,8 +1065,7 @@ static int i3c_master_sethid_locked(struct i3c_master_controller *master)
 	return ret;
 }
 
-static int i3c_master_getmrl_locked(struct i3c_master_controller *master,
-				    struct i3c_device_info *info)
+int i3c_master_getmrl_locked(struct i3c_master_controller *master, struct i3c_device_info *info)
 {
 	struct i3c_ccc_cmd_dest dest;
 	struct i3c_ccc_mrl *mrl;
@@ -1054,7 +1083,7 @@ static int i3c_master_getmrl_locked(struct i3c_master_controller *master,
 	if (!(info->bcr & I3C_BCR_IBI_PAYLOAD))
 		dest.payload.len -= 1;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMRL, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMRL, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1077,8 +1106,7 @@ static int i3c_master_getmrl_locked(struct i3c_master_controller *master,
 	return ret;
 }
 
-static int i3c_master_getmwl_locked(struct i3c_master_controller *master,
-				    struct i3c_device_info *info)
+int i3c_master_getmwl_locked(struct i3c_master_controller *master, struct i3c_device_info *info)
 {
 	struct i3c_ccc_cmd_dest dest;
 	struct i3c_ccc_mwl *mwl;
@@ -1089,7 +1117,7 @@ static int i3c_master_getmwl_locked(struct i3c_master_controller *master,
 	if (!mwl)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMWL, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMWL, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1107,6 +1135,54 @@ static int i3c_master_getmwl_locked(struct i3c_master_controller *master,
 	return ret;
 }
 
+int i3c_master_setmrl_locked(struct i3c_master_controller *master,
+			     struct i3c_device_info *info, u16 read_len, u8 ibi_len)
+{
+	struct i3c_ccc_cmd_dest dest;
+	struct i3c_ccc_cmd cmd;
+	struct i3c_ccc_mrl *mrl;
+	int ret;
+
+	mrl = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*mrl));
+	if (!mrl)
+		return -ENOMEM;
+
+	mrl->read_len = cpu_to_be16(read_len);
+	mrl->ibi_len = ibi_len;
+	info->max_read_len = read_len;
+	info->max_ibi_len = mrl->ibi_len;
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETMRL(false), &dest, 1, false,
+			 0);
+
+	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
+	i3c_ccc_cmd_dest_cleanup(&dest);
+
+	return ret;
+}
+
+int i3c_master_setmwl_locked(struct i3c_master_controller *master,
+			     struct i3c_device_info *info, u16 write_len)
+{
+	struct i3c_ccc_cmd_dest dest;
+	struct i3c_ccc_cmd cmd;
+	struct i3c_ccc_mwl *mwl;
+	int ret;
+
+	mwl = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*mwl));
+	if (!mwl)
+		return -ENOMEM;
+
+	mwl->len = cpu_to_be16(write_len);
+	info->max_write_len = write_len;
+	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETMWL(false), &dest, 1, false,
+			 0);
+
+	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
+	i3c_ccc_cmd_dest_cleanup(&dest);
+
+	return ret;
+}
+
 static int i3c_master_getmxds_locked(struct i3c_master_controller *master,
 				     struct i3c_device_info *info)
 {
@@ -1120,7 +1196,7 @@ static int i3c_master_getmxds_locked(struct i3c_master_controller *master,
 	if (!getmaxds)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMXDS, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMXDS, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1156,7 +1232,7 @@ static int i3c_master_gethdrcap_locked(struct i3c_master_controller *master,
 	if (!gethdrcap)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETHDRCAP, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETHDRCAP, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1186,7 +1262,7 @@ static int i3c_master_getpid_locked(struct i3c_master_controller *master,
 	if (!getpid)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETPID, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETPID, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1216,7 +1292,7 @@ static int i3c_master_getbcr_locked(struct i3c_master_controller *master,
 	if (!getbcr)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETBCR, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETBCR, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1241,7 +1317,7 @@ static int i3c_master_getdcr_locked(struct i3c_master_controller *master,
 	if (!getdcr)
 		return -ENOMEM;
 
-	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETDCR, &dest, 1);
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETDCR, &dest, 1, false, 0);
 	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
 	if (ret)
 		goto out;
@@ -1254,6 +1330,32 @@ static int i3c_master_getdcr_locked(struct i3c_master_controller *master,
 	return ret;
 }
 
+int i3c_dev_getstatus_locked(struct i3c_dev_desc *dev,
+			     struct i3c_device_info *info)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev);
+	struct i3c_ccc_getstatus *getsts;
+	struct i3c_ccc_cmd_dest dest;
+	struct i3c_ccc_cmd cmd;
+	int ret;
+
+	getsts = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*getsts));
+	if (!getsts)
+		return -ENOMEM;
+
+	i3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETSTATUS, &dest, 1, false, 0);
+	ret = i3c_master_send_ccc_cmd_locked(master, &cmd);
+	if (ret)
+		goto out;
+
+	info->status = getsts->status;
+
+out:
+	i3c_ccc_cmd_dest_cleanup(&dest);
+
+	return ret;
+}
+
 static int i3c_master_retrieve_dev_info(struct i3c_dev_desc *dev)
 {
 	struct i3c_master_controller *master = i3c_dev_get_master(dev);
@@ -1269,6 +1371,13 @@ static int i3c_master_retrieve_dev_info(struct i3c_dev_desc *dev)
 	    slot_status == I3C_ADDR_SLOT_I2C_DEV)
 		return -EINVAL;
 
+	if (master->jdec_spd && dev->boardinfo) {
+		dev->info.pid = dev->boardinfo->pid;
+		dev->info.dcr = dev->boardinfo->dcr;
+		dev->info.bcr = dev->boardinfo->bcr;
+		return 0;
+	}
+
 	ret = i3c_master_getpid_locked(master, &dev->info);
 	if (ret)
 		return ret;
@@ -1414,6 +1523,9 @@ static int i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,
 		i3c_bus_set_addr_slot_status(&master->bus,
 					     dev->info.dyn_addr,
 					     I3C_ADDR_SLOT_I3C_DEV);
+		if (old_dyn_addr)
+			i3c_bus_set_addr_slot_status(&master->bus, old_dyn_addr,
+						     I3C_ADDR_SLOT_FREE);
 	}
 
 	if (master->ops->reattach_i3c_dev) {
@@ -1465,36 +1577,6 @@ static void i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)
 		master->ops->detach_i2c_dev(dev);
 }
 
-static int i3c_master_add_static_i3c_dev(struct i3c_master_controller *master,
-					  struct i3c_dev_boardinfo *boardinfo)
-{
-	struct i3c_device_info info = {
-		.static_addr = boardinfo->static_addr,
-	};
-	struct i3c_dev_desc *i3cdev;
-	int ret;
-
-	i3cdev = i3c_master_alloc_i3c_dev(master, &info);
-	if (IS_ERR(i3cdev))
-		return -ENOMEM;
-
-	i3cdev->boardinfo = boardinfo;
-	i3cdev->info.static_addr = boardinfo->static_addr;
-	i3cdev->info.pid = boardinfo->pid;
-	i3cdev->info.dyn_addr = boardinfo->static_addr;
-
-	ret = i3c_master_attach_i3c_dev(master, i3cdev);
-	if (ret)
-		goto err_free_dev;
-
-	return 0;
-
-err_free_dev:
-	i3c_master_free_i3c_dev(i3cdev);
-
-	return ret;
-}
-
 static int i3c_master_early_i3c_dev_add(struct i3c_master_controller *master,
 					  struct i3c_dev_boardinfo *boardinfo)
 {
@@ -1514,10 +1596,17 @@ static int i3c_master_early_i3c_dev_add(struct i3c_master_controller *master,
 	if (ret)
 		goto err_free_dev;
 
-	ret = i3c_master_setdasa_locked(master, i3cdev->info.static_addr,
-					i3cdev->boardinfo->init_dyn_addr);
-	if (ret)
-		goto err_detach_dev;
+	/*
+	 * JESD403-1 devices only support SETAASA (will be called in do_daa)
+	 * Here we use SETDASA for non-JESD403-1 devices
+	 */
+	if (!I3C_DCR_IS_JESD403_COMPLIANT(i3cdev->boardinfo->dcr)) {
+		ret = i3c_master_setdasa_locked(
+			master, i3cdev->info.static_addr,
+			i3cdev->boardinfo->init_dyn_addr);
+		if (ret)
+			goto err_detach_dev;
+	}
 
 	i3cdev->info.dyn_addr = i3cdev->boardinfo->init_dyn_addr;
 	ret = i3c_master_reattach_i3c_dev(i3cdev, 0);
@@ -1596,7 +1685,11 @@ int i3c_master_do_daa(struct i3c_master_controller *master)
 	int ret;
 
 	i3c_bus_maintenance_lock(&master->bus);
-	ret = master->ops->do_daa(master);
+	if (master->jdec_spd) {
+		i3c_master_sethid_locked(master);
+		i3c_master_setaasa_locked(master);
+	} else
+		ret = master->ops->do_daa(master);
 	i3c_bus_maintenance_unlock(&master->bus);
 
 	if (ret)
@@ -1610,6 +1703,29 @@ int i3c_master_do_daa(struct i3c_master_controller *master)
 }
 EXPORT_SYMBOL_GPL(i3c_master_do_daa);
 
+/**
+ * i3c_master_enable_hj() - enable hot-join
+ * @master: master broadcast the enec ccc to enable hot-join.
+ *
+ * This function must be called after the master init done to satisfy
+ * the description "Hot-Join does not allow Targets to join the I3C
+ * Bus before the I3C Bus has been configured." in i3c specification.
+ *
+ * Return: a 0 in case of success, an negative error code otherwise.
+ */
+int i3c_master_enable_hj(struct i3c_master_controller *master)
+{
+	if (!master->init_done)
+		return -ENOPROTOOPT;
+
+	i3c_bus_maintenance_lock(&master->bus);
+	i3c_master_enec_locked(master, I3C_BROADCAST_ADDR, I3C_CCC_EVENT_HJ);
+	i3c_bus_maintenance_unlock(&master->bus);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i3c_master_enable_hj);
+
 /**
  * i3c_master_set_info() - set master device information
  * @master: master used to send frames on the bus
@@ -1643,10 +1759,6 @@ int i3c_master_set_info(struct i3c_master_controller *master,
 	if (!i3c_bus_dev_addr_is_avail(&master->bus, info->dyn_addr))
 		return -EINVAL;
 
-	if (I3C_BCR_DEVICE_ROLE(info->bcr) == I3C_BCR_I3C_MASTER &&
-	    master->secondary)
-		return -EINVAL;
-
 	if (master->this)
 		return -EINVAL;
 
@@ -1655,7 +1767,10 @@ int i3c_master_set_info(struct i3c_master_controller *master,
 		return PTR_ERR(i3cdev);
 
 	master->this = i3cdev;
-	master->bus.cur_master = master->this;
+	if (master->secondary)
+		master->bus.cur_master = NULL;
+	else
+		master->bus.cur_master = master->this;
 
 	ret = i3c_master_attach_i3c_dev(master, i3cdev);
 	if (ret)
@@ -1753,7 +1868,9 @@ static int i3c_master_bus_init(struct i3c_master_controller *master)
 					     i2cboardinfo->base.addr,
 					     I3C_ADDR_SLOT_I2C_DEV);
 
-		i2cdev = i3c_master_alloc_i2c_dev(master, i2cboardinfo);
+		i2cdev = i3c_master_alloc_i2c_dev(master,
+						  i2cboardinfo->base.addr,
+						  i2cboardinfo->lvr);
 		if (IS_ERR(i2cdev)) {
 			ret = PTR_ERR(i2cdev);
 			goto err_detach_devs;
@@ -1785,6 +1902,9 @@ static int i3c_master_bus_init(struct i3c_master_controller *master)
 		goto err_bus_cleanup;
 	}
 
+	if (master->secondary)
+		return 0;
+
 	/*
 	 * Reset all dynamic address that may have been assigned before
 	 * (assigned by the bootloader for example).
@@ -1809,19 +1929,6 @@ static int i3c_master_bus_init(struct i3c_master_controller *master)
 	 */
 	list_for_each_entry(i3cboardinfo, &master->boardinfo.i3c, node) {
 
-		if (!i3cboardinfo->init_dyn_addr && master->bus.jesd403) {
-			/* JESD403 devices only support setaasa */
-			ret = i3c_bus_get_addr_slot_status(&master->bus,
-					i3cboardinfo->static_addr);
-			if (ret != I3C_ADDR_SLOT_FREE) {
-				ret = -EBUSY;
-				goto err_rstdaa;
-			}
-			i3cboardinfo->init_dyn_addr = i3cboardinfo->static_addr;
-			i3c_master_add_static_i3c_dev(master, i3cboardinfo);
-			continue;
-		}
-
 		/*
 		 * We don't reserve a dynamic address for devices that
 		 * don't explicitly request one.
@@ -1836,9 +1943,15 @@ static int i3c_master_bus_init(struct i3c_master_controller *master)
 			goto err_rstdaa;
 		}
 
-		i3c_bus_set_addr_slot_status(&master->bus,
-					     i3cboardinfo->init_dyn_addr,
-					     I3C_ADDR_SLOT_I3C_DEV);
+		/*
+		 * If the static address equals to the assigned dynamic address,
+		 * don't reserve the address slot here, it will be set after the
+		 * DA has been assigned.
+		 */
+		if (i3cboardinfo->static_addr != i3cboardinfo->init_dyn_addr)
+			i3c_bus_set_addr_slot_status(
+				&master->bus, i3cboardinfo->init_dyn_addr,
+				I3C_ADDR_SLOT_I3C_DEV);
 
 		/*
 		 * Only try to create/attach devices that have a static
@@ -1852,19 +1965,18 @@ static int i3c_master_bus_init(struct i3c_master_controller *master)
 			i3c_master_early_i3c_dev_add(master, i3cboardinfo);
 	}
 
-	if (master->bus.jesd403) {
-		i3c_master_sethid_locked(master);
-		i3c_master_setaasa_locked(master);
-
-		i3c_bus_normaluse_lock(&master->bus);
-		i3c_master_register_new_i3c_devs(master);
-		i3c_bus_normaluse_unlock(&master->bus);
+	/*
+	 * Not support mix mode on JEDEC bus context. Here We only handle
+	 * the I2C part so simply return with success code.
+	 */
+	if (master->jdec_spd && master->bus.mode != I3C_BUS_MODE_PURE)
 		return 0;
-	}
 
 	ret = i3c_master_do_daa(master);
 	if (ret)
-		goto err_rstdaa;
+		dev_dbg(&master->dev,
+			"Failed to do DAA: %d. However, devices with static address can still be accessed\n",
+			ret);
 
 	return 0;
 
@@ -1987,6 +2099,16 @@ int i3c_master_add_i3c_dev_locked(struct i3c_master_controller *master,
 			i3c_dev_free_ibi_locked(olddev);
 		}
 		mutex_unlock(&olddev->ibi_lock);
+		if (olddev->info.max_ibi_len != newdev->info.max_ibi_len ||
+		    olddev->info.max_read_len != newdev->info.max_read_len)
+			i3c_master_setmrl_locked(master, &newdev->info,
+					      olddev->info.max_read_len,
+					      olddev->info.max_ibi_len);
+		if (olddev->info.max_write_len != newdev->info.max_write_len)
+			i3c_master_setmwl_locked(master, &newdev->info,
+					      olddev->info.max_write_len);
+		if (olddev->info.pec != newdev->info.pec)
+			i3c_device_control_pec(newdev->dev, olddev->info.pec);
 
 		old_dyn_addr = olddev->info.dyn_addr;
 
@@ -1994,10 +2116,6 @@ int i3c_master_add_i3c_dev_locked(struct i3c_master_controller *master,
 		i3c_master_free_i3c_dev(olddev);
 	}
 
-	ret = i3c_master_reattach_i3c_dev(newdev, old_dyn_addr);
-	if (ret)
-		goto err_detach_dev;
-
 	/*
 	 * Depending on our previous state, the expected dynamic address might
 	 * differ:
@@ -2118,6 +2236,8 @@ of_i3c_master_add_i3c_boardinfo(struct i3c_master_controller *master,
 	struct device *dev = &master->dev;
 	enum i3c_addr_slot_status addrstatus;
 	u32 init_dyn_addr = 0;
+	u32 bcr = 0;
+	u32 dcr = 0;
 
 	boardinfo = devm_kzalloc(dev, sizeof(*boardinfo), GFP_KERNEL);
 	if (!boardinfo)
@@ -2151,6 +2271,16 @@ of_i3c_master_add_i3c_boardinfo(struct i3c_master_controller *master,
 	    I3C_PID_RND_LOWER_32BITS(boardinfo->pid))
 		return -EINVAL;
 
+	if (!of_property_read_u32(node, "dcr", &dcr)) {
+		if (dcr > I3C_DCR_MAX)
+			return -EINVAL;
+
+		boardinfo->dcr = dcr;
+	}
+
+	if (!of_property_read_u32(node, "bcr", &bcr))
+		boardinfo->bcr = bcr;
+
 	boardinfo->init_dyn_addr = init_dyn_addr;
 	boardinfo->of_node = of_node_get(node);
 	list_add_tail(&boardinfo->node, &master->boardinfo.i3c);
@@ -2188,17 +2318,30 @@ static int of_populate_i3c_bus(struct i3c_master_controller *master)
 	struct device *dev = &master->dev;
 	struct device_node *i3cbus_np = dev->of_node;
 	struct device_node *node;
-	int ret;
+	int ret, i;
 	u32 val;
 
 	if (!i3cbus_np)
 		return 0;
 
+	if (of_get_property(i3cbus_np, "jdec-spd", NULL)) {
+		master->jdec_spd = 1;
+	}
+
+	/* For SPD bus, undo unnecessary address reservations. */
+	if (master->jdec_spd) {
+		for (i = 0; i < 7; i++)
+			i3c_bus_set_addr_slot_status(&master->bus, I3C_BROADCAST_ADDR ^ BIT(i),
+						     I3C_ADDR_SLOT_FREE);
+	}
+
 	for_each_available_child_of_node(i3cbus_np, node) {
-		ret = of_i3c_master_add_dev(master, node);
-		if (ret) {
-			of_node_put(node);
-			return ret;
+		if (node->name && of_node_cmp(node->name, "hub")) {
+			ret = of_i3c_master_add_dev(master, node);
+			if (ret) {
+				of_node_put(node);
+				return ret;
+			}
 		}
 	}
 
@@ -2213,9 +2356,6 @@ static int of_populate_i3c_bus(struct i3c_master_controller *master)
 	if (!of_property_read_u32(i3cbus_np, "i3c-scl-hz", &val))
 		master->bus.scl_rate.i3c = val;
 
-	if (of_property_read_bool(i3cbus_np, "jedec,jesd403"))
-		master->bus.jesd403 = true;
-
 	return 0;
 }
 
@@ -2256,15 +2396,127 @@ static u32 i3c_master_i2c_funcs(struct i2c_adapter *adapter)
 	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
 }
 
+static u8 i3c_master_i2c_get_lvr(struct i2c_client *client)
+{
+	/* Fall back to no spike filters and FM bus mode. */
+	u8 lvr = I3C_LVR_I2C_INDEX(2) | I3C_LVR_I2C_FM_MODE;
+
+	if (client->dev.of_node) {
+		u32 reg[3];
+
+		if (!of_property_read_u32_array(client->dev.of_node, "reg",
+						reg, ARRAY_SIZE(reg)))
+			lvr = reg[2];
+	}
+
+	return lvr;
+}
+
+static int i3c_master_i2c_attach(struct i2c_adapter *adap, struct i2c_client *client)
+{
+	struct i3c_master_controller *master = i2c_adapter_to_i3c_master(adap);
+	enum i3c_addr_slot_status status;
+	struct i2c_dev_desc *i2cdev;
+	int ret;
+
+	/* Already added by board info? */
+	if (i3c_master_find_i2c_dev_by_addr(master, client->addr))
+		return 0;
+
+	status = i3c_bus_get_addr_slot_status(&master->bus, client->addr);
+	if (status != I3C_ADDR_SLOT_FREE)
+		return -EBUSY;
+
+	i3c_bus_set_addr_slot_status(&master->bus, client->addr,
+				     I3C_ADDR_SLOT_I2C_DEV);
+
+	i2cdev = i3c_master_alloc_i2c_dev(master, client->addr,
+					  i3c_master_i2c_get_lvr(client));
+	if (IS_ERR(i2cdev)) {
+		ret = PTR_ERR(i2cdev);
+		goto out_clear_status;
+	}
+
+	ret = i3c_master_attach_i2c_dev(master, i2cdev);
+	if (ret)
+		goto out_free_dev;
+
+	return 0;
+
+out_free_dev:
+	i3c_master_free_i2c_dev(i2cdev);
+out_clear_status:
+	i3c_bus_set_addr_slot_status(&master->bus, client->addr,
+				     I3C_ADDR_SLOT_FREE);
+
+	return ret;
+}
+
+static int i3c_master_i2c_detach(struct i2c_adapter *adap, struct i2c_client *client)
+{
+	struct i3c_master_controller *master = i2c_adapter_to_i3c_master(adap);
+	struct i2c_dev_desc *dev;
+
+	dev = i3c_master_find_i2c_dev_by_addr(master, client->addr);
+	if (!dev)
+		return -ENODEV;
+
+	i3c_master_detach_i2c_dev(dev);
+	i3c_bus_set_addr_slot_status(&master->bus, dev->addr,
+				     I3C_ADDR_SLOT_FREE);
+	i3c_master_free_i2c_dev(dev);
+
+	return 0;
+}
+
 static const struct i2c_algorithm i3c_master_i2c_algo = {
 	.master_xfer = i3c_master_i2c_adapter_xfer,
 	.functionality = i3c_master_i2c_funcs,
 };
 
+static int i3c_i2c_notifier_call(struct notifier_block *nb, unsigned long action,
+				 void *data)
+{
+	struct i2c_adapter *adap;
+	struct i2c_client *client;
+	struct device *dev = data;
+	struct i3c_master_controller *master;
+	int ret;
+
+	if (dev->type != &i2c_client_type)
+		return 0;
+
+	client = to_i2c_client(dev);
+	adap = client->adapter;
+
+	if (adap->algo != &i3c_master_i2c_algo)
+		return 0;
+
+	master = i2c_adapter_to_i3c_master(adap);
+
+	i3c_bus_maintenance_lock(&master->bus);
+	switch (action) {
+	case BUS_NOTIFY_ADD_DEVICE:
+		ret = i3c_master_i2c_attach(adap, client);
+		break;
+	case BUS_NOTIFY_DEL_DEVICE:
+		ret = i3c_master_i2c_detach(adap, client);
+		break;
+	}
+	i3c_bus_maintenance_unlock(&master->bus);
+
+	return ret;
+}
+
+static struct notifier_block i2cdev_notifier = {
+	.notifier_call = i3c_i2c_notifier_call,
+};
+
 static int i3c_master_i2c_adapter_init(struct i3c_master_controller *master)
 {
 	struct i2c_adapter *adap = i3c_master_to_i2c_adapter(master);
 	struct i2c_dev_desc *i2cdev;
+	struct i2c_dev_boardinfo *i2cboardinfo;
 	int ret;
 
 	adap->dev.parent = master->dev.parent;
@@ -2284,8 +2536,13 @@ static int i3c_master_i2c_adapter_init(struct i3c_master_controller *master)
 	 * We silently ignore failures here. The bus should keep working
 	 * correctly even if one or more i2c devices are not registered.
 	 */
-	i3c_bus_for_each_i2cdev(&master->bus, i2cdev)
-		i2cdev->dev = i2c_new_client_device(adap, &i2cdev->boardinfo->base);
+	list_for_each_entry(i2cboardinfo, &master->boardinfo.i2c, node) {
+		i2cdev = i3c_master_find_i2c_dev_by_addr(master,
+							 i2cboardinfo->base.addr);
+		if (WARN_ON(!i2cdev))
+			continue;
+		i2cdev->dev = i2c_new_client_device(adap, &i2cboardinfo->base);
+	}
 
 	return 0;
 }
@@ -2560,9 +2817,6 @@ int i3c_master_register(struct i3c_master_controller *master,
 	struct i2c_dev_boardinfo *i2cbi;
 	int ret;
 
-	/* We do not support secondary masters yet. */
-	if (secondary)
-		return -ENOTSUPP;
 
 	ret = i3c_master_check_ops(ops);
 	if (ret)
@@ -2645,6 +2899,15 @@ int i3c_master_register(struct i3c_master_controller *master,
 	master->init_done = true;
 	i3c_bus_normaluse_lock(&master->bus);
 	i3c_master_register_new_i3c_devs(master);
+#ifdef CONFIG_I3C_SLAVE_MQUEUE
+	if (master->secondary)
+		i3c_slave_mqueue_probe(master);
+#endif
+
+#ifdef CONFIG_I3C_SLAVE_EEPROM
+	if (master->secondary)
+		i3c_slave_eeprom_probe(master);
+#endif
 	i3c_bus_normaluse_unlock(&master->bus);
 
 	return 0;
@@ -2681,6 +2944,211 @@ int i3c_master_unregister(struct i3c_master_controller *master)
 }
 EXPORT_SYMBOL_GPL(i3c_master_unregister);
 
+static int i3c_target_bus_init(struct i3c_master_controller *master)
+{
+	return master->target_ops->bus_init(master);
+}
+
+static void i3c_target_bus_cleanup(struct i3c_master_controller *master)
+{
+	if (master->target_ops->bus_cleanup)
+		master->target_ops->bus_cleanup(master);
+}
+
+static void i3c_targetdev_release(struct device *dev)
+{
+	struct i3c_master_controller *master = container_of(dev, struct i3c_master_controller, dev);
+	struct i3c_bus *bus = &master->bus;
+
+	mutex_lock(&i3c_core_lock);
+	idr_remove(&i3c_bus_idr, bus->id);
+	mutex_unlock(&i3c_core_lock);
+
+	of_node_put(dev->of_node);
+}
+
+static void i3c_target_device_release(struct device *dev)
+{
+	struct i3c_device *i3cdev = dev_to_i3cdev(dev);
+	struct i3c_dev_desc *desc = i3cdev->desc;
+
+	kfree(i3cdev);
+	kfree(desc);
+}
+
+static void
+i3c_target_register_new_i3c_dev(struct i3c_master_controller *master, struct i3c_device_info info)
+{
+	struct i3c_dev_desc *desc;
+	int ret;
+
+	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+	if (!desc)
+		return;
+
+	desc->dev = kzalloc(sizeof(*desc->dev), GFP_KERNEL);
+	if (!desc->dev) {
+		kfree(desc);
+		return;
+	}
+
+	desc->dev->bus = &master->bus;
+	desc->dev->desc = desc;
+	desc->dev->dev.parent = &master->dev;
+	desc->dev->dev.type = &i3c_target_device_type;
+	desc->dev->dev.bus = &i3c_bus_type;
+	desc->dev->dev.release = i3c_target_device_release;
+	desc->info = info;
+	desc->common.master = master;
+	dev_set_name(&desc->dev->dev, "%d-target", master->bus.id);
+
+	ret = device_register(&desc->dev->dev);
+	if (ret)
+		dev_err(&master->dev, "Failed to add I3C target device (err = %d)\n", ret);
+
+	master->this = desc;
+}
+
+static void i3c_target_unregister_i3c_dev(struct i3c_master_controller *master)
+{
+	struct i3c_dev_desc *i3cdev = master->this;
+
+	if (device_is_registered(&i3cdev->dev->dev))
+		device_unregister(&i3cdev->dev->dev);
+	else
+		put_device(&i3cdev->dev->dev);
+}
+
+static void i3c_target_read_device_info(struct device_node *np, struct i3c_device_info *info)
+{
+	u64 pid;
+	u32 dcr;
+	int ret;
+
+	ret = of_property_read_u64(np, "pid", &pid);
+	if (ret)
+		info->pid = 0;
+	else
+		info->pid = pid;
+
+	ret = of_property_read_u32(np, "dcr", &dcr);
+	if (ret)
+		info->pid = 0;
+	else
+		info->dcr = dcr;
+}
+
+static int i3c_target_check_ops(const struct i3c_target_ops *ops)
+{
+	if (!ops || !ops->bus_init)
+		return -EINVAL;
+
+	return 0;
+}
+
+int i3c_target_register(struct i3c_master_controller *master, struct device *parent,
+			const struct i3c_target_ops *ops)
+{
+	struct i3c_bus *i3cbus = i3c_master_get_bus(master);
+	struct i3c_device_info info;
+	int ret;
+
+	ret = i3c_target_check_ops(ops);
+	if (ret)
+		return ret;
+
+	master->dev.parent = parent;
+	master->dev.of_node = of_node_get(parent->of_node);
+	master->dev.bus = &i3c_bus_type;
+	master->dev.release = i3c_targetdev_release;
+	master->target_ops = ops;
+	i3cbus->mode = I3C_BUS_MODE_PURE;
+
+	init_rwsem(&i3cbus->lock);
+	mutex_lock(&i3c_core_lock);
+	ret = idr_alloc(&i3c_bus_idr, i3cbus, 0, 0, GFP_KERNEL);
+	mutex_unlock(&i3c_core_lock);
+	if (ret < 0)
+		return ret;
+	i3cbus->id = ret;
+
+	device_initialize(&master->dev);
+	dev_set_name(&master->dev, "i3c-%d", i3cbus->id);
+
+	ret = device_add(&master->dev);
+	if (ret)
+		goto err_put_device;
+
+	i3c_target_read_device_info(master->dev.of_node, &info);
+
+	i3c_target_register_new_i3c_dev(master, info);
+
+	ret = i3c_target_bus_init(master);
+	if (ret)
+		goto err_cleanup_bus;
+
+	return 0;
+
+err_cleanup_bus:
+	i3c_target_bus_cleanup(master);
+
+err_put_device:
+	put_device(&master->dev);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_target_register);
+
+int i3c_target_unregister(struct i3c_master_controller *master)
+{
+	i3c_target_unregister_i3c_dev(master);
+	i3c_target_bus_cleanup(master);
+	device_unregister(&master->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i3c_target_unregister);
+
+int i3c_target_read_register(struct i3c_device *dev, const struct i3c_target_read_setup *setup)
+{
+	dev->desc->target_info.read_handler = setup->handler;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i3c_target_read_register);
+
+int i3c_register(struct i3c_master_controller *master,
+		 struct device *parent,
+		 const struct i3c_master_controller_ops *master_ops,
+		 const struct i3c_target_ops *target_ops,
+		 bool secondary)
+{
+	const char *role;
+	int ret;
+
+	ret = of_property_read_string(parent->of_node, "initial-role", &role);
+	if (ret || !strcmp("primary", role)) {
+		return i3c_master_register(master, parent, master_ops, secondary);
+	} else if (!strcmp("target", role)) {
+		master->target = true;
+		return i3c_target_register(master, parent, target_ops);
+	} else {
+		return -EOPNOTSUPP;
+	}
+}
+EXPORT_SYMBOL_GPL(i3c_register);
+
+int i3c_unregister(struct i3c_master_controller *master)
+{
+	if (master->target)
+		i3c_target_unregister(master);
+	else
+		i3c_master_unregister(master);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i3c_unregister);
+
 int i3c_dev_do_priv_xfers_locked(struct i3c_dev_desc *dev,
 				 struct i3c_priv_xfer *xfers,
 				 int nxfers)
@@ -2694,10 +3162,38 @@ int i3c_dev_do_priv_xfers_locked(struct i3c_dev_desc *dev,
 	if (!master || !xfers)
 		return -EINVAL;
 
-	if (!master->ops->priv_xfers)
-		return -ENOTSUPP;
+	if (!master->target) {
+		if (!master->ops->priv_xfers)
+			return -EOPNOTSUPP;
 
-	return master->ops->priv_xfers(dev, xfers, nxfers);
+		return master->ops->priv_xfers(dev, xfers, nxfers);
+	}
+
+	if (!master->target_ops->priv_xfers)
+		return -EOPNOTSUPP;
+
+	return master->target_ops->priv_xfers(dev, xfers, nxfers);
+}
+
+int i3c_dev_generate_ibi_locked(struct i3c_dev_desc *dev, const u8 *data, int len)
+
+{
+	struct i3c_master_controller *master;
+
+	if (!dev)
+		return -ENOENT;
+
+	master = i3c_dev_get_master(dev);
+	if (!master)
+		return -EINVAL;
+
+	if (!master->target)
+		return -EINVAL;
+
+	if (!master->target_ops->generate_ibi)
+		return -EOPNOTSUPP;
+
+	return master->target_ops->generate_ibi(dev, data, len);
 }
 
 int i3c_dev_disable_ibi_locked(struct i3c_dev_desc *dev)
@@ -2785,6 +3281,81 @@ void i3c_dev_free_ibi_locked(struct i3c_dev_desc *dev)
 	dev->ibi = NULL;
 }
 
+int i3c_dev_send_ccc_cmd_locked(struct i3c_dev_desc *dev, u8 ccc_id)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev);
+	int ret;
+
+	switch (ccc_id) {
+	case I3C_CCC_SETAASA:
+		ret = i3c_master_setaasa_locked(master);
+		break;
+	case I3C_CCC_SETHID:
+		ret = i3c_master_sethid_locked(master);
+		break;
+	case I3C_CCC_RSTDAA(false):
+		ret = i3c_master_rstdaa_locked(master, dev->info.dyn_addr);
+		break;
+	case I3C_CCC_RSTDAA(true):
+		ret = i3c_master_rstdaa_locked(master, I3C_BROADCAST_ADDR);
+		break;
+	default:
+		dev_err(&master->dev, "Unpermitted ccc: %x\n", ccc_id);
+		return -ENOTSUPP;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_dev_send_ccc_cmd_locked);
+
+int i3c_master_register_slave(struct i3c_master_controller *master,
+			      const struct i3c_slave_setup *req)
+{
+	if (!master->ops->register_slave)
+		return -ENOTSUPP;
+
+	return master->ops->register_slave(master, req);
+}
+
+int i3c_master_unregister_slave(struct i3c_master_controller *master)
+{
+	if (!master->ops->unregister_slave)
+		return -ENOTSUPP;
+
+	return master->ops->unregister_slave(master);
+}
+
+int i3c_master_send_sir(struct i3c_master_controller *master,
+			struct i3c_slave_payload *payload)
+{
+	int ret;
+
+	if (!master->ops->send_sir)
+		return -ENOTSUPP;
+
+	i3c_bus_normaluse_lock(&master->bus);
+	ret = master->ops->send_sir(master, payload);
+	i3c_bus_normaluse_unlock(&master->bus);
+
+	return ret;
+}
+
+int i3c_master_put_read_data(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify)
+{
+	int ret;
+
+	if (!master->ops->put_read_data)
+		return -ENOTSUPP;
+
+	i3c_bus_normaluse_lock(&master->bus);
+	ret = master->ops->put_read_data(master, data, ibi_notify);
+	i3c_bus_normaluse_unlock(&master->bus);
+
+	return ret;
+}
+
 int i3c_for_each_dev(void *data, int (*fn)(struct device *, void *))
 {
 	int res;
@@ -2797,14 +3368,49 @@ int i3c_for_each_dev(void *data, int (*fn)(struct device *, void *))
 }
 EXPORT_SYMBOL_GPL(i3c_for_each_dev);
 
+int i3c_dev_control_pec(struct i3c_dev_desc *dev, bool pec)
+{
+	struct i3c_master_controller *master = i3c_dev_get_master(dev);
+
+	if (!master->pec_supported)
+		return -EOPNOTSUPP;
+
+	dev->info.pec = pec;
+
+	/*
+	 * TODO: There are two cases which shall be covered
+	 * 1. Controller doesn't support PEC.
+	 *    In this case we could just fallback to SW implementation.
+	 * 2. Device doesn't support PEC.
+	 *    Then we really can't use PEC - and should error-out.
+	 */
+
+	return 0;
+}
+
 static int __init i3c_init(void)
 {
-	return bus_register(&i3c_bus_type);
+	int res = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);
+
+	if (res)
+		return res;
+
+	res = bus_register(&i3c_bus_type);
+	if (res)
+		goto out_unreg_notifier;
+
+	return 0;
+
+out_unreg_notifier:
+	bus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);
+
+	return res;
 }
 subsys_initcall(i3c_init);
 
 static void __exit i3c_exit(void)
 {
+	bus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);
 	idr_destroy(&i3c_bus_idr);
 	bus_unregister(&i3c_bus_type);
 }
diff --git a/drivers/i3c/master/Kconfig b/drivers/i3c/master/Kconfig
index 3b8f95916f46..4cb8ea236eb6 100644
--- a/drivers/i3c/master/Kconfig
+++ b/drivers/i3c/master/Kconfig
@@ -22,6 +22,34 @@ config DW_I3C_MASTER
 	  This driver can also be built as a module.  If so, the module
 	  will be called dw-i3c-master.
 
+config AST2600_I3C_MASTER
+	tristate "Aspeed AST2600 I3C master driver"
+	depends on I3C
+	depends on HAS_IOMEM
+	depends on MACH_ASPEED_G6
+	help
+	  Support for Aspeed AST2600 MIPI I3C Controller.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called ast2600-i3c-master.
+
+if AST2600_I3C_MASTER
+config AST2600_I3C_IBI_MAX_PAYLOAD
+	int "Max IBI payload size"
+	default 255
+
+config AST2600_I3C_MRL
+	int "Max read length"
+	default 256
+
+config AST2600_I3C_CCC_WORKAROUND
+	bool "Workaround for AST2600A1 errata item#30"
+	default n
+	help
+	  Say y to enable the workaround for AST2600A1 errata item#30.  No need
+	  to enable this option if you are using AST2600A2 or later versions.
+endif
+
 config SVC_I3C_MASTER
 	tristate "Silvaco I3C Dual-Role Master driver"
 	depends on I3C
diff --git a/drivers/i3c/master/Makefile b/drivers/i3c/master/Makefile
index b3fee0f690b2..77e9c5b4bdaf 100644
--- a/drivers/i3c/master/Makefile
+++ b/drivers/i3c/master/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_CDNS_I3C_MASTER)		+= i3c-master-cdns.o
 obj-$(CONFIG_DW_I3C_MASTER)		+= dw-i3c-master.o
+obj-$(CONFIG_AST2600_I3C_MASTER)	+= ast2600-i3c-global.o ast2600-i3c-master.o
 obj-$(CONFIG_SVC_I3C_MASTER)		+= svc-i3c-master.o
 obj-$(CONFIG_MIPI_I3C_HCI)		+= mipi-i3c-hci/
diff --git a/drivers/i3c/master/ast2600-i3c-global.c b/drivers/i3c/master/ast2600-i3c-global.c
new file mode 100644
index 000000000000..3536849dbe5f
--- /dev/null
+++ b/drivers/i3c/master/ast2600-i3c-global.c
@@ -0,0 +1,141 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 ASPEED Technology Inc.
+ *
+ * Author: Dylan Hung <dylan_hung@aspeedtech.com>
+ * Based on a work from: Ryan Chen <ryan_chen@aspeedtech.com>
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/reset.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#define I3CG_REG0(x)			((x * 0x10) + 0x10)
+#define I3CG_REG0_SDA_PULLUP_EN_MASK	GENMASK(29, 28)
+#define I3CG_REG0_SDA_PULLUP_EN_2K	(0x1 << 28)
+#define I3CG_REG0_SDA_PULLUP_EN_750	(0x2 << 28)
+#define I3CG_REG0_SDA_PULLUP_EN_545	(0x3 << 28)
+
+#define I3CG_REG1(x)			((x * 0x10) + 0x14)
+#define I3CG_REG1_I2C_MODE		BIT(0)
+#define I3CG_REG1_TEST_MODE		BIT(1)
+#define I3CG_REG1_ACT_MODE_MASK		GENMASK(3, 2)
+#define I3CG_REG1_ACT_MODE(x)		(((x) << 2) & I3CG_REG1_ACT_MODE_MASK)
+#define I3CG_REG1_PENDING_INT_MASK	GENMASK(7, 4)
+#define I3CG_REG1_PENDING_INT(x)	(((x) << 4) & I3CG_REG1_PENDING_INT_MASK)
+#define I3CG_REG1_SA_MASK		GENMASK(14, 8)
+#define I3CG_REG1_SA(x)			(((x) << 8) & I3CG_REG1_SA_MASK)
+#define I3CG_REG1_SA_EN			BIT(15)
+#define I3CG_REG1_INST_ID_MASK		GENMASK(19, 16)
+#define I3CG_REG1_INST_ID(x)		(((x) << 16) & I3CG_REG1_INST_ID_MASK)
+
+struct aspeed_i3c_global {
+	void __iomem *regs;
+	struct reset_control *rst;
+};
+
+static const struct of_device_id aspeed_i3c_of_match[] = {
+	{ .compatible = "aspeed,ast2600-i3c-global", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, aspeed_i3c_of_match);
+
+static u32 pullup_resistor_ohm_to_reg(u32 ohm)
+{
+	switch (ohm) {
+	case 545:
+		return I3CG_REG0_SDA_PULLUP_EN_545;
+	case 750:
+		return I3CG_REG0_SDA_PULLUP_EN_750;
+	case 2000:
+	default:
+		return I3CG_REG0_SDA_PULLUP_EN_2K;
+	}
+}
+
+static int aspeed_i3c_global_probe(struct platform_device *pdev)
+{
+	struct aspeed_i3c_global *i3cg;
+	u32 reg0, reg1, num_i3cs;
+	u32 *pullup_resistors;
+	int i, ret;
+
+	i3cg = devm_kzalloc(&pdev->dev, sizeof(*i3cg), GFP_KERNEL);
+	if (!i3cg)
+		return -ENOMEM;
+
+	i3cg->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(i3cg->regs))
+		return -ENOMEM;
+
+	i3cg->rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(i3cg->rst)) {
+		dev_err(&pdev->dev,
+			"missing or invalid reset controller device tree entry");
+		return PTR_ERR(i3cg->rst);
+	}
+
+	reset_control_assert(i3cg->rst);
+	udelay(3);
+	reset_control_deassert(i3cg->rst);
+
+	ret = of_property_read_u32(pdev->dev.of_node, "num-i3cs", &num_i3cs);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to get number of i3c controllers");
+		return -ENOMEM;
+	}
+
+	pullup_resistors = kcalloc(num_i3cs, sizeof(u32), GFP_KERNEL);
+	if (!pullup_resistors)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(pdev->dev.of_node, "pull-up-resistors",
+					 pullup_resistors, num_i3cs);
+	if (ret < 0) {
+		dev_warn(&pdev->dev,
+			 "use 2K Ohm SDA pull up resistor by default");
+	}
+
+	reg1 = I3CG_REG1_ACT_MODE(1) | I3CG_REG1_PENDING_INT(0xc) |
+	       I3CG_REG1_SA(0x74);
+
+	for (i = 0; i < num_i3cs; i++) {
+		reg0 = readl(i3cg->regs + I3CG_REG0(i));
+		reg0 &= ~I3CG_REG0_SDA_PULLUP_EN_MASK;
+		reg0 |= pullup_resistor_ohm_to_reg(pullup_resistors[i]);
+		writel(reg0, i3cg->regs + I3CG_REG0(i));
+
+		reg1 &= ~I3CG_REG1_INST_ID_MASK;
+		reg1 |= I3CG_REG1_INST_ID(i);
+		writel(reg1, i3cg->regs + I3CG_REG1(i));
+	}
+
+	kfree(pullup_resistors);
+
+	return 0;
+}
+
+static struct platform_driver aspeed_i3c_driver = {
+	.probe  = aspeed_i3c_global_probe,
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.of_match_table = of_match_ptr(aspeed_i3c_of_match),
+	},
+};
+
+//static int __init aspeed_i3c_global_init(void)
+//{
+//	return platform_driver_register(&aspeed_i3c_driver);
+//}
+//postcore_initcall(aspeed_i3c_global_init);
+module_platform_driver(aspeed_i3c_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_AUTHOR("Dylan Hung <dylan_hung@aspeedtech.com>");
+MODULE_DESCRIPTION("ASPEED I3C Global Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i3c/master/ast2600-i3c-master.c b/drivers/i3c/master/ast2600-i3c-master.c
new file mode 100644
index 000000000000..eeefd1970f6f
--- /dev/null
+++ b/drivers/i3c/master/ast2600-i3c-master.c
@@ -0,0 +1,2496 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2021 ASPEED Technology Inc.
+ *
+ * Derived from dw-i3c-master.c by Vitor Soares <vitor.soares@synopsys.com>
+ */
+
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/i3c/master.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/iopoll.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define DEVICE_CTRL			0x0
+#define DEV_CTRL_ENABLE			BIT(31)
+#define DEV_CTRL_RESUME			BIT(30)
+#define DEV_CTRL_AUTO_HJ_DISABLE	BIT(27)
+#define DEV_CTRL_SLAVE_MDB		GENMASK(23, 16)
+#define DEV_CTRL_SLAVE_PEC_EN		BIT(10)
+#define DEV_CRTL_IBI_PAYLOAD_EN		BIT(9)
+#define DEV_CTRL_HOT_JOIN_NACK		BIT(8)
+#define DEV_CTRL_I2C_SLAVE_PRESENT	BIT(7)
+#define DEV_CTRL_IBA_INCLUDE		BIT(0)
+
+#define DEVICE_ADDR			0x4
+#define DEV_ADDR_DYNAMIC_ADDR_VALID	BIT(31)
+#define DEV_ADDR_DYNAMIC(x)		(((x) << 16) & GENMASK(22, 16))
+#define DEV_ADDR_STATIC_ADDR_VALID	BIT(15)
+#define DEV_ADDR_STATIC(x)		(((x) << 0) & GENMASK(6, 0))
+
+#define HW_CAPABILITY			0x8
+#define COMMAND_QUEUE_PORT		0xc
+#define COMMAND_PORT_PEC		BIT(31)
+#define COMMAND_PORT_TOC		BIT(30)
+#define COMMAND_PORT_READ_TRANSFER	BIT(28)
+#define COMMAND_PORT_SDAP		BIT(27)
+#define COMMAND_PORT_ROC		BIT(26)
+#define COMMAND_PORT_DBP(x)		((x) << 25)
+#define COMMAND_PORT_SPEED(x)		(((x) << 21) & GENMASK(23, 21))
+#define COMMAND_PORT_DEV_INDEX(x)	(((x) << 16) & GENMASK(20, 16))
+#define COMMAND_PORT_CP			BIT(15)
+#define COMMAND_PORT_CMD(x)		(((x) << 7) & GENMASK(14, 7))
+#define COMMAND_PORT_TID(x)		(((x) << 3) & GENMASK(6, 3))
+
+#define COMMAND_PORT_ARG_DBP(x)		(((x) << 8) & GENMASK(15, 8))
+#define COMMAND_PORT_ARG_DATA_LEN(x)	(((x) << 16) & GENMASK(31, 16))
+#define COMMAND_PORT_ARG_DATA_LEN_MAX	65536
+#define COMMAND_PORT_TRANSFER_ARG	0x01
+
+#define COMMAND_ATTR_SLAVE_DATA		0x0
+#define COMMAND_PORT_SLAVE_DATA_LEN	GENMASK(31, 16)
+
+#define COMMAND_PORT_SDA_DATA_BYTE_3(x)	(((x) << 24) & GENMASK(31, 24))
+#define COMMAND_PORT_SDA_DATA_BYTE_2(x)	(((x) << 16) & GENMASK(23, 16))
+#define COMMAND_PORT_SDA_DATA_BYTE_1(x)	(((x) << 8) & GENMASK(15, 8))
+#define COMMAND_PORT_SDA_BYTE_STRB_3	BIT(5)
+#define COMMAND_PORT_SDA_BYTE_STRB_2	BIT(4)
+#define COMMAND_PORT_SDA_BYTE_STRB_1	BIT(3)
+#define COMMAND_PORT_SHORT_DATA_ARG	0x02
+
+#define COMMAND_PORT_DEV_COUNT(x)	(((x) << 21) & GENMASK(25, 21))
+#define COMMAND_PORT_ADDR_ASSGN_CMD	0x03
+
+#define RESPONSE_QUEUE_PORT		0x10
+#define RESPONSE_PORT_ERR_STATUS(x)	(((x) & GENMASK(31, 28)) >> 28)
+#define RESPONSE_NO_ERROR		0
+#define RESPONSE_ERROR_CRC		1
+#define RESPONSE_ERROR_PARITY		2
+#define RESPONSE_ERROR_FRAME		3
+#define RESPONSE_ERROR_IBA_NACK		4
+#define RESPONSE_ERROR_ADDRESS_NACK	5
+#define RESPONSE_ERROR_OVER_UNDER_FLOW	6
+#define RESPONSE_ERROR_TRANSF_ABORT	8
+#define RESPONSE_ERROR_I2C_W_NACK_ERR	9
+#define RESPONSE_ERROR_EARLY_TERMINATE	10
+#define RESPONSE_ERROR_PEC_ERR		12
+#define RESPONSE_PORT_TID(x)		(((x) & GENMASK(27, 24)) >> 24)
+#define   TID_MASTER_WRITE_DATA		0b1000
+#define   TID_CCC_WRITE_DATA		0b1111
+#define RESPONSE_PORT_DATA_LEN(x)	((x) & GENMASK(15, 0))
+
+#define RX_TX_DATA_PORT			0x14
+#define IBI_QUEUE_STATUS		0x18
+#define IBI_QUEUE_STATUS_RSP_NACK	BIT(31)
+#define IBI_QUEUE_STATUS_PEC_ERR	BIT(30)
+#define IBI_QUEUE_STATUS_LAST_FRAG	BIT(24)
+#define IBI_QUEUE_STATUS_IBI_ID(x)	(((x) & GENMASK(15, 8)) >> 8)
+#define IBI_QUEUE_STATUS_DATA_LEN(x)	((x) & GENMASK(7, 0))
+
+#define IBI_QUEUE_IBI_ADDR(x)		(IBI_QUEUE_STATUS_IBI_ID(x) >> 1)
+#define IBI_QUEUE_IBI_RNW(x)		(IBI_QUEUE_STATUS_IBI_ID(x) & BIT(0))
+#define IBI_TYPE_MR(x)                                                         \
+	((IBI_QUEUE_IBI_ADDR(x) != I3C_HOT_JOIN_ADDR) && !IBI_QUEUE_IBI_RNW(x))
+#define IBI_TYPE_HJ(x)                                                         \
+	((IBI_QUEUE_IBI_ADDR(x) == I3C_HOT_JOIN_ADDR) && !IBI_QUEUE_IBI_RNW(x))
+#define IBI_TYPE_SIR(x)                                                        \
+	((IBI_QUEUE_IBI_ADDR(x) != I3C_HOT_JOIN_ADDR) && IBI_QUEUE_IBI_RNW(x))
+
+#define IBI_QUEUE_DATA			0x18
+#define QUEUE_THLD_CTRL			0x1c
+#define QUEUE_THLD_CTRL_IBI_STA_MASK	GENMASK(31, 24)
+#define QUEUE_THLD_CTRL_IBI_STA(x)	(((x) - 1) << 24)
+#define QUEUE_THLD_CTRL_IBI_DAT_MASK	GENMASK(23, 16)
+#define QUEUE_THLD_CTRL_IBI_DAT(x)	((x) << 16)
+#define QUEUE_THLD_CTRL_RESP_BUF_MASK	GENMASK(15, 8)
+#define QUEUE_THLD_CTRL_RESP_BUF(x)	(((x) - 1) << 8)
+
+#define DATA_BUFFER_THLD_CTRL		0x20
+#define DATA_BUFFER_THLD_CTRL_RX_BUF	GENMASK(11, 8)
+
+#define IBI_QUEUE_CTRL			0x24
+#define IBI_MR_REQ_REJECT		0x2C
+#define IBI_SIR_REQ_REJECT		0x30
+#define IBI_REQ_REJECT_ALL		GENMASK(31, 0)
+
+#define RESET_CTRL			0x34
+#define RESET_CTRL_BUS			BIT(31)
+#define RESET_CTRL_BUS_RESET_TYPE	GENMASK(30, 29)
+#define   BUS_RESET_TYPE_EXIT		0b00
+#define   BUS_RESET_TYPE_SCL_LOW	0b11
+#define RESET_CTRL_IBI_QUEUE		BIT(5)
+#define RESET_CTRL_RX_FIFO		BIT(4)
+#define RESET_CTRL_TX_FIFO		BIT(3)
+#define RESET_CTRL_RESP_QUEUE		BIT(2)
+#define RESET_CTRL_CMD_QUEUE		BIT(1)
+#define RESET_CTRL_SOFT			BIT(0)
+#define RESET_CTRL_ALL                  (RESET_CTRL_IBI_QUEUE	              |\
+					 RESET_CTRL_RX_FIFO	              |\
+					 RESET_CTRL_TX_FIFO	              |\
+					 RESET_CTRL_RESP_QUEUE	              |\
+					 RESET_CTRL_CMD_QUEUE	              |\
+					 RESET_CTRL_SOFT)
+#define RESET_CTRL_QUEUES		(RESET_CTRL_IBI_QUEUE	              |\
+					 RESET_CTRL_RX_FIFO	              |\
+					 RESET_CTRL_TX_FIFO	              |\
+					 RESET_CTRL_RESP_QUEUE	              |\
+					 RESET_CTRL_CMD_QUEUE)
+
+#define SLV_EVENT_CTRL			0x38
+#define SLV_EVENT_CTRL_MWL_UPD		BIT(7)
+#define SLV_EVENT_CTRL_MRL_UPD		BIT(6)
+#define SLV_EVENT_CTRL_SIR_EN		BIT(0)
+#define SLV_EVETN_CTRL_W1C_MASK		(SLV_EVENT_CTRL_MWL_UPD |\
+					 SLV_EVENT_CTRL_MRL_UPD)
+
+#define INTR_STATUS			0x3c
+#define INTR_STATUS_EN			0x40
+#define INTR_SIGNAL_EN			0x44
+#define INTR_FORCE			0x48
+#define INTR_BUSOWNER_UPDATE_STAT	BIT(13)
+#define INTR_IBI_UPDATED_STAT		BIT(12)
+#define INTR_READ_REQ_RECV_STAT		BIT(11)
+#define INTR_DEFSLV_STAT		BIT(10)
+#define INTR_TRANSFER_ERR_STAT		BIT(9)
+#define INTR_DYN_ADDR_ASSGN_STAT	BIT(8)
+#define INTR_CCC_UPDATED_STAT		BIT(6)
+#define INTR_TRANSFER_ABORT_STAT	BIT(5)
+#define INTR_RESP_READY_STAT		BIT(4)
+#define INTR_CMD_QUEUE_READY_STAT	BIT(3)
+#define INTR_IBI_THLD_STAT		BIT(2)
+#define INTR_RX_THLD_STAT		BIT(1)
+#define INTR_TX_THLD_STAT		BIT(0)
+#define INTR_ALL			(INTR_BUSOWNER_UPDATE_STAT |	\
+					INTR_IBI_UPDATED_STAT |		\
+					INTR_READ_REQ_RECV_STAT |	\
+					INTR_DEFSLV_STAT |		\
+					INTR_TRANSFER_ERR_STAT |	\
+					INTR_DYN_ADDR_ASSGN_STAT |	\
+					INTR_CCC_UPDATED_STAT |		\
+					INTR_TRANSFER_ABORT_STAT |	\
+					INTR_RESP_READY_STAT |		\
+					INTR_CMD_QUEUE_READY_STAT |	\
+					INTR_IBI_THLD_STAT |		\
+					INTR_TX_THLD_STAT |		\
+					INTR_RX_THLD_STAT)
+#define INTR_MASTER_MASK		(INTR_TRANSFER_ERR_STAT |	\
+					 INTR_RESP_READY_STAT)
+#define INTR_2ND_MASTER_MASK		(INTR_TRANSFER_ERR_STAT |	\
+					 INTR_RESP_READY_STAT	|	\
+					 INTR_IBI_UPDATED_STAT  |	\
+					 INTR_CCC_UPDATED_STAT)
+#define QUEUE_STATUS_LEVEL		0x4c
+#define QUEUE_STATUS_IBI_STATUS_CNT(x)	(((x) & GENMASK(28, 24)) >> 24)
+#define QUEUE_STATUS_IBI_BUF_BLR(x)	(((x) & GENMASK(23, 16)) >> 16)
+#define QUEUE_STATUS_LEVEL_RESP(x)	(((x) & GENMASK(15, 8)) >> 8)
+#define QUEUE_STATUS_LEVEL_CMD(x)	((x) & GENMASK(7, 0))
+
+#define DATA_BUFFER_STATUS_LEVEL	0x50
+#define DATA_BUFFER_STATUS_LEVEL_TX(x)	((x) & GENMASK(7, 0))
+
+#define PRESENT_STATE			0x54
+#define PRESENT_STATE_CM_ST_STS(x)	(((x) & GENMASK(13, 8)) >> 8)
+#define CM_ST_STS_HALT			0x6
+
+#define CCC_DEVICE_STATUS		0x58
+#define DEVICE_ADDR_TABLE_POINTER	0x5c
+#define DEVICE_ADDR_TABLE_DEPTH(x)	(((x) & GENMASK(31, 16)) >> 16)
+#define DEVICE_ADDR_TABLE_ADDR(x)	((x) & GENMASK(7, 0))
+
+#define DEV_CHAR_TABLE_POINTER		0x60
+#define VENDOR_SPECIFIC_REG_POINTER	0x6c
+#define SLV_MIPI_PID_VALUE		0x70
+#define PID_MANUF_ID_ASPEED		0x03f6
+
+#define SLV_PID_VALUE			0x74
+#define SLV_PID_PART_ID(x)		(((x) << 16) & GENMASK(31, 16))
+#define SLV_PID_INST_ID(x)		(((x) << 12) & GENMASK(15, 12))
+#define SLV_PID_DCR(x)			((x) & GENMASK(11, 0))
+
+#define PID_PART_ID_AST2600_SERIES	0x0500
+#define PID_PART_ID_AST1030_A0		0x8000
+
+#define SLV_CHAR_CTRL			0x78
+#define SLV_CHAR_GET_DCR(x)		(((x) & GENMASK(15, 8)) >> 8)
+#define SLV_CHAR_GET_BCR(x)		(((x) & GENMASK(7, 0)) >> 0)
+#define SLV_MAX_LEN			0x7c
+#define MAX_READ_TURNAROUND		0x80
+#define MAX_DATA_SPEED			0x84
+#define SLV_DEBUG_STATUS		0x88
+#define SLV_INTR_REQ			0x8c
+#define SLV_INTR_REQ_IBI_STS(x)		((x) & GENMASK(9, 8) >> 8)
+#define SLV_IBI_STS_OK			0x1
+
+#define DEVICE_CTRL_EXTENDED		0xb0
+#define DEVICE_CTRL_ROLE_MASK		GENMASK(1, 0)
+#define DEVICE_CTRL_ROLE_MASTER		0
+#define DEVICE_CTRL_ROLE_SLAVE		1
+#define SCL_I3C_OD_TIMING		0xb4
+#define SCL_I3C_PP_TIMING		0xb8
+#define SCL_I3C_TIMING_HCNT		GENMASK(23, 16)
+#define SCL_I3C_TIMING_LCNT		GENMASK(7, 0)
+#define SCL_I3C_TIMING_CNT_MIN		5
+
+#define SCL_I2C_FM_TIMING		0xbc
+#define SCL_I2C_FM_TIMING_HCNT		GENMASK(31, 16)
+#define SCL_I2C_FM_TIMING_LCNT		GENMASK(15, 0)
+
+#define SCL_I2C_FMP_TIMING		0xc0
+#define SCL_I2C_FMP_TIMING_HCNT		GENMASK(23, 16)
+#define SCL_I2C_FMP_TIMING_LCNT		GENMASK(15, 0)
+
+#define SCL_EXT_LCNT_TIMING		0xc8
+#define SCL_EXT_LCNT_4(x)		(((x) << 24) & GENMASK(31, 24))
+#define SCL_EXT_LCNT_3(x)		(((x) << 16) & GENMASK(23, 16))
+#define SCL_EXT_LCNT_2(x)		(((x) << 8) & GENMASK(15, 8))
+#define SCL_EXT_LCNT_1(x)		((x) & GENMASK(7, 0))
+
+#define SCL_EXT_TERMN_LCNT_TIMING	0xcc
+#define SDA_HOLD_SWITCH_DLY_TIMING	0xd0
+#define SDA_TX_HOLD			GENMASK(18, 16)
+#define   SDA_TX_HOLD_MIN		0b001
+#define   SDA_TX_HOLD_MAX		0b111
+#define SDA_PP_OD_SWITCH_DLY		GENMASK(10, 8)
+#define SDA_OD_PP_SWITCH_DLY		GENMASK(2, 0)
+#define BUS_FREE_TIMING			0xd4
+#define BUS_I3C_AVAILABLE_TIME(x)	(((x) << 16) & GENMASK(31, 16))
+#define BUS_I3C_MST_FREE(x)		((x) & GENMASK(15, 0))
+
+#define BUS_IDLE_TIMING			0xd8
+#define SCL_LOW_MST_EXT_TIMEOUT		0xdc
+#define I3C_VER_ID			0xe0
+#define I3C_VER_TYPE			0xe4
+#define EXTENDED_CAPABILITY		0xe8
+#define SLAVE_CONFIG			0xec
+
+#define DEV_ADDR_TABLE_LEGACY_I2C_DEV	BIT(31)
+#define DEV_ADDR_TABLE_DEV_NACK_RETRY(x) (((x) << 29) & GENMASK(30, 29))
+#define DEV_ADDR_TABLE_IBI_ADDR_MASK	GENMASK(25, 24)
+#define IBI_ADDR_MASK_LAST_3BITS	((1 << 24) & GENMASK(25, 24))
+#define IBI_ADDR_MASK_LAST_4BITS	((2 << 24) & GENMASK(25, 24))
+#define DEV_ADDR_TABLE_MR_REJECT	BIT(14)
+#define DEV_ADDR_TABLE_SIR_REJECT	BIT(13)
+#define DEV_ADDR_TABLE_IBI_WITH_DATA	BIT(12)
+#define DEV_ADDR_TABLE_IBI_PEC_EN	BIT(11)
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)	(((x) << 16) & GENMASK(23, 16))
+#define DEV_ADDR_TABLE_STATIC_ADDR(x)	((x) & GENMASK(6, 0))
+#define DEV_ADDR_TABLE_LOC(start, idx)	((start) + ((idx) << 2))
+#define GET_DYNAMIC_ADDR_FROM_DAT(x)	(((x)&GENMASK(22, 16)) >> 16)
+#define GET_DAT_FROM_POS(_master, _pos)                                        \
+	(readl(_master->regs + DEV_ADDR_TABLE_LOC(_master->datstartaddr, _pos)))
+
+#define MAX_DEVS			128
+#define MAX_IBI_FRAG_SIZE		124
+
+#define I3C_BUS_SDR1_SCL_RATE		8000000
+#define I3C_BUS_SDR2_SCL_RATE		6000000
+#define I3C_BUS_SDR3_SCL_RATE		4000000
+#define I3C_BUS_SDR4_SCL_RATE		2000000
+#define I3C_BUS_I2C_STD_TLOW_MIN_NS	4700
+#define I3C_BUS_I2C_STD_THIGH_MIN_NS	4000
+#define I3C_BUS_I2C_STD_TR_MAX_NS	1000
+#define I3C_BUS_I2C_STD_TF_MAX_NS	300
+#define I3C_BUS_I2C_FM_TLOW_MIN_NS	1300
+#define I3C_BUS_I2C_FM_THIGH_MIN_NS	600
+#define I3C_BUS_I2C_FM_TR_MAX_NS	300
+#define I3C_BUS_I2C_FM_TF_MAX_NS	300
+#define I3C_BUS_I2C_FMP_TLOW_MIN_NS	500
+#define I3C_BUS_I2C_FMP_THIGH_MIN_NS	260
+#define I3C_BUS_I2C_FMP_TR_MAX_NS	120
+#define I3C_BUS_I2C_FMP_TF_MAX_NS	120
+#define I3C_BUS_JESD403_PP_TLOW_MIN_NS	35
+#define I3C_BUS_JESD403_PP_THIGH_MIN_NS	35
+#define I3C_BUS_JESD403_PP_TR_MAX_NS	5
+#define I3C_BUS_JESD403_PP_TF_MAX_NS	5
+#define I3C_BUS_THIGH_MAX_NS		41
+
+#define I3C_BUS_EXT_TERMN_CNT		4
+#define JESD403_TIMED_RESET_NS_DEF	52428800
+
+#define XFER_TIMEOUT			(msecs_to_jiffies(1000))
+
+#define ast_setbits(x, set)		writel(readl(x) | (set), x)
+#define ast_clrbits(x, clr)		writel(readl(x) & ~(clr), x)
+#define ast_clrsetbits(x, clr, set)	writel((readl(x) & ~(clr)) | (set), x)
+
+#define MAX_GROUPS			(1 << 4)
+#define MAX_DEVS_IN_GROUP		(1 << 3)
+#define ALL_DEVS_IN_GROUP_ARE_FREE	((1 << MAX_DEVS_IN_GROUP) - 1)
+#define ADDR_GRP_MASK			GENMASK(6, 3)
+#define ADDR_GRP(x)			(((x) & ADDR_GRP_MASK) >> 3)
+#define ADDR_HID_MASK			GENMASK(2, 0)
+#define ADDR_HID(x)			((x) & ADDR_HID_MASK)
+
+struct aspeed_i3c_master_caps {
+	u8 cmdfifodepth;
+	u8 datafifodepth;
+};
+
+struct aspeed_i3c_cmd {
+	u32 cmd_lo;
+	u32 cmd_hi;
+	u16 tx_len;
+	const void *tx_buf;
+	u16 rx_len;
+	void *rx_buf;
+	u8 error;
+};
+
+struct aspeed_i3c_xfer {
+	struct list_head node;
+	struct completion comp;
+	int ret;
+	unsigned int ncmds;
+	struct aspeed_i3c_cmd cmds[];
+};
+
+struct aspeed_i3c_dev_group {
+	u32 dat[8];
+	u32 free_pos;
+	int hw_index;
+	struct {
+		u32 set;
+		u32 clr;
+	} mask;
+};
+
+struct aspeed_i3c_master {
+	struct device *dev;
+	struct i3c_master_controller base;
+	u16 maxdevs;
+	u16 datstartaddr;
+	u32 free_pos;
+	struct aspeed_i3c_dev_group dev_group[MAX_GROUPS];
+	struct {
+		struct list_head list;
+		struct aspeed_i3c_xfer *cur;
+		spinlock_t lock;
+	} xferqueue;
+	struct {
+		struct i3c_dev_desc *slots[MAX_DEVS];
+		spinlock_t lock;
+	} ibi;
+	struct aspeed_i3c_master_caps caps;
+	void __iomem *regs;
+	struct reset_control *core_rst;
+	struct clk *core_clk;
+	char version[5];
+	char type[5];
+	u8 addrs[MAX_DEVS];
+	bool secondary;
+	struct {
+		u32 *buf;
+		void (*callback)(struct i3c_master_controller *m,
+				 const struct i3c_slave_payload *payload);
+	} slave_data;
+	struct completion sir_complete;
+
+	struct {
+		unsigned long core_rate;
+		unsigned long core_period;
+		u32 i3c_od_scl_freq;
+		u32 i3c_od_scl_low;
+		u32 i3c_od_scl_high;
+		u32 i3c_pp_scl_freq;
+		u32 i3c_pp_scl_low;
+		u32 i3c_pp_scl_high;
+	} timing;
+	struct work_struct hj_work;
+};
+
+struct aspeed_i3c_i2c_dev_data {
+	struct i3c_generic_ibi_pool *ibi_pool;
+	u8 index;
+	s8 ibi;
+};
+
+static u8 even_parity(u8 p)
+{
+	p ^= p >> 4;
+	p &= 0xf;
+
+	return (0x9669 >> p) & 1;
+}
+
+static bool aspeed_i3c_master_supports_ccc_cmd(struct i3c_master_controller *m,
+					   const struct i3c_ccc_cmd *cmd)
+{
+	if (cmd->ndests > 1)
+		return false;
+
+	switch (cmd->id) {
+	case I3C_CCC_ENEC(true):
+	case I3C_CCC_ENEC(false):
+	case I3C_CCC_DISEC(true):
+	case I3C_CCC_DISEC(false):
+	case I3C_CCC_ENTAS(0, true):
+	case I3C_CCC_ENTAS(0, false):
+	case I3C_CCC_RSTDAA(true):
+	case I3C_CCC_RSTDAA(false):
+	case I3C_CCC_ENTDAA:
+	case I3C_CCC_SETMWL(true):
+	case I3C_CCC_SETMWL(false):
+	case I3C_CCC_SETMRL(true):
+	case I3C_CCC_SETMRL(false):
+	case I3C_CCC_ENTHDR(0):
+	case I3C_CCC_SETDASA:
+	case I3C_CCC_SETNEWDA:
+	case I3C_CCC_GETMWL:
+	case I3C_CCC_GETMRL:
+	case I3C_CCC_GETPID:
+	case I3C_CCC_GETBCR:
+	case I3C_CCC_GETDCR:
+	case I3C_CCC_GETSTATUS:
+	case I3C_CCC_GETMXDS:
+	case I3C_CCC_GETHDRCAP:
+	case I3C_CCC_SETAASA:
+	case I3C_CCC_SETHID:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline struct aspeed_i3c_master *
+to_aspeed_i3c_master(struct i3c_master_controller *master)
+{
+	return container_of(master, struct aspeed_i3c_master, base);
+}
+
+static void aspeed_i3c_master_disable(struct aspeed_i3c_master *master)
+{
+	writel(readl(master->regs + DEVICE_CTRL) & ~DEV_CTRL_ENABLE,
+	       master->regs + DEVICE_CTRL);
+}
+
+static void aspeed_i3c_master_enable(struct aspeed_i3c_master *master)
+{
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_ENABLE,
+	       master->regs + DEVICE_CTRL);
+}
+
+static void aspeed_i3c_master_resume(struct aspeed_i3c_master *master)
+{
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,
+	       master->regs + DEVICE_CTRL);
+}
+
+static void aspeed_i3c_master_set_role(struct aspeed_i3c_master *master)
+{
+	u32 reg;
+	u32 role = DEVICE_CTRL_ROLE_MASTER;
+
+	if (master->secondary)
+		role = DEVICE_CTRL_ROLE_SLAVE;
+
+	reg = readl(master->regs + DEVICE_CTRL_EXTENDED);
+	reg = (reg & ~DEVICE_CTRL_ROLE_MASK) | role;
+	writel(reg, master->regs + DEVICE_CTRL_EXTENDED);
+}
+
+static int aspeed_i3c_master_get_free_pos(struct aspeed_i3c_master *master)
+{
+	if (!(master->free_pos & GENMASK(master->maxdevs - 1, 0)))
+		return -ENOSPC;
+
+	return ffs(master->free_pos) - 1;
+}
+
+static void aspeed_i3c_master_init_group_dat(struct aspeed_i3c_master *master)
+{
+	struct aspeed_i3c_dev_group *dev_grp;
+	int i, j;
+	u32 def_set, def_clr;
+
+	def_clr = DEV_ADDR_TABLE_IBI_ADDR_MASK;
+
+	/* For now don't support Hot-Join */
+	def_set = DEV_ADDR_TABLE_MR_REJECT | DEV_ADDR_TABLE_SIR_REJECT |
+		  IBI_ADDR_MASK_LAST_3BITS;
+
+	for (i = 0; i < MAX_GROUPS; i++) {
+		dev_grp = &master->dev_group[i];
+		dev_grp->hw_index = -1;
+		dev_grp->free_pos = ALL_DEVS_IN_GROUP_ARE_FREE;
+		dev_grp->mask.set = def_set;
+		dev_grp->mask.clr = def_clr;
+		for (j = 0; j < MAX_DEVS_IN_GROUP; j++)
+			dev_grp->dat[j] = 0;
+	}
+
+	for (i = 0; i < master->maxdevs; i++)
+		writel(def_set,
+		       master->regs +
+			       DEV_ADDR_TABLE_LOC(master->datstartaddr, i));
+}
+
+static int aspeed_i3c_master_set_group_dat(struct aspeed_i3c_master *master, u8 addr,
+				       u32 val)
+{
+	struct aspeed_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+	u8 idx = ADDR_HID(addr);
+
+	dev_grp->dat[idx] = val;
+
+	if (val) {
+		dev_grp->free_pos &= ~BIT(idx);
+
+		/*
+		 * reserve the hw dat resource for the first member of the
+		 * group. all the members in the group share the same hw dat.
+		 */
+		if (dev_grp->hw_index == -1) {
+			dev_grp->hw_index = aspeed_i3c_master_get_free_pos(master);
+			if (dev_grp->hw_index < 0)
+				goto out;
+
+			master->free_pos &= ~BIT(dev_grp->hw_index);
+			writel(val, master->regs + DEV_ADDR_TABLE_LOC(
+							   master->datstartaddr,
+							   dev_grp->hw_index));
+		}
+	} else {
+		dev_grp->free_pos |= BIT(idx);
+
+		/*
+		 * release the hw dat resource if all the members in the group
+		 * are free.
+		 */
+		if (dev_grp->free_pos == ALL_DEVS_IN_GROUP_ARE_FREE) {
+			writel(0, master->regs + DEV_ADDR_TABLE_LOC(
+							 master->datstartaddr,
+							 dev_grp->hw_index));
+			master->free_pos |= BIT(dev_grp->hw_index);
+			dev_grp->hw_index = -1;
+		}
+	}
+out:
+	return dev_grp->hw_index;
+}
+
+static u32 aspeed_i3c_master_get_group_dat(struct aspeed_i3c_master *master, u8 addr)
+{
+	struct aspeed_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+
+	return dev_grp->dat[ADDR_HID(addr)];
+}
+
+static int aspeed_i3c_master_get_group_hw_index(struct aspeed_i3c_master *master,
+					    u8 addr)
+{
+	struct aspeed_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+
+	return dev_grp->hw_index;
+}
+
+static struct aspeed_i3c_dev_group *
+aspeed_i3c_master_get_group(struct aspeed_i3c_master *master, u8 addr)
+{
+	return &master->dev_group[ADDR_GRP(addr)];
+}
+
+static int aspeed_i3c_master_sync_hw_dat(struct aspeed_i3c_master *master, u8 addr)
+{
+	struct aspeed_i3c_dev_group *dev_grp = &master->dev_group[ADDR_GRP(addr)];
+	u32 dat = dev_grp->dat[ADDR_HID(addr)];
+	int hw_index = dev_grp->hw_index;
+
+	if (!dat || hw_index < 0)
+		return -1;
+
+	dat &= ~dev_grp->mask.clr;
+	dat |= dev_grp->mask.set;
+	writel(dat, master->regs +
+			    DEV_ADDR_TABLE_LOC(master->datstartaddr, hw_index));
+	return hw_index;
+}
+
+static void aspeed_i3c_master_wr_tx_fifo(struct aspeed_i3c_master *master,
+				     const u8 *bytes, int nbytes)
+{
+	/*
+	 * ensure all memory accesses are done before we move the data from
+	 * memory to the hardware FIFO
+	 */
+	wmb();
+
+	writesl(master->regs + RX_TX_DATA_PORT, bytes, nbytes / 4);
+	if (nbytes & 3) {
+		u32 tmp = 0;
+
+		memcpy(&tmp, bytes + (nbytes & ~3), nbytes & 3);
+		writesl(master->regs + RX_TX_DATA_PORT, &tmp, 1);
+		dev_dbg(master->dev, "TX data = %08x\n", tmp);
+	}
+}
+
+static void aspeed_i3c_master_read_fifo(struct aspeed_i3c_master *master, u32 fifo_reg,
+				    u8 *bytes, int nbytes)
+{
+	readsl(master->regs + fifo_reg, bytes, nbytes / 4);
+	if (nbytes & 3) {
+		u32 tmp;
+
+		readsl(master->regs + fifo_reg, &tmp, 1);
+		memcpy(bytes + (nbytes & ~3), &tmp, nbytes & 3);
+	}
+}
+
+static void aspeed_i3c_master_read_rx_fifo(struct aspeed_i3c_master *master,
+					      u8 *bytes, int nbytes)
+{
+	aspeed_i3c_master_read_fifo(master, RX_TX_DATA_PORT, bytes, nbytes);
+}
+
+static void aspeed_i3c_master_read_ibi_fifo(struct aspeed_i3c_master *master,
+					       u8 *bytes, int nbytes)
+{
+	aspeed_i3c_master_read_fifo(master, IBI_QUEUE_DATA, bytes, nbytes);
+}
+
+static struct aspeed_i3c_xfer *
+aspeed_i3c_master_alloc_xfer(struct aspeed_i3c_master *master, unsigned int ncmds)
+{
+	struct aspeed_i3c_xfer *xfer;
+
+	xfer = kzalloc(struct_size(xfer, cmds, ncmds), GFP_KERNEL);
+	if (!xfer)
+		return NULL;
+
+	INIT_LIST_HEAD(&xfer->node);
+	xfer->ncmds = ncmds;
+	xfer->ret = -ETIMEDOUT;
+
+	return xfer;
+}
+
+static void aspeed_i3c_master_free_xfer(struct aspeed_i3c_xfer *xfer)
+{
+	kfree(xfer);
+}
+
+static void aspeed_i3c_master_start_xfer_locked(struct aspeed_i3c_master *master)
+{
+	struct aspeed_i3c_xfer *xfer = master->xferqueue.cur;
+	unsigned int i;
+	u32 thld_ctrl;
+
+	if (!xfer)
+		return;
+
+	for (i = 0; i < xfer->ncmds; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		aspeed_i3c_master_wr_tx_fifo(master, cmd->tx_buf, cmd->tx_len);
+	}
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(xfer->ncmds);
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+
+	for (i = 0; i < xfer->ncmds; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		writel(cmd->cmd_hi, master->regs + COMMAND_QUEUE_PORT);
+		writel(cmd->cmd_lo, master->regs + COMMAND_QUEUE_PORT);
+	}
+}
+
+static void aspeed_i3c_master_enqueue_xfer(struct aspeed_i3c_master *master,
+				       struct aspeed_i3c_xfer *xfer)
+{
+	unsigned long flags;
+
+	init_completion(&xfer->comp);
+	spin_lock_irqsave(&master->xferqueue.lock, flags);
+	if (master->xferqueue.cur) {
+		list_add_tail(&xfer->node, &master->xferqueue.list);
+	} else {
+		master->xferqueue.cur = xfer;
+		aspeed_i3c_master_start_xfer_locked(master);
+	}
+	spin_unlock_irqrestore(&master->xferqueue.lock, flags);
+}
+
+static void aspeed_i3c_master_dequeue_xfer_locked(struct aspeed_i3c_master *master,
+					      struct aspeed_i3c_xfer *xfer)
+{
+	if (master->xferqueue.cur == xfer) {
+		u32 status;
+
+		master->xferqueue.cur = NULL;
+
+		writel(RESET_CTRL_RX_FIFO | RESET_CTRL_TX_FIFO |
+		       RESET_CTRL_RESP_QUEUE | RESET_CTRL_CMD_QUEUE,
+		       master->regs + RESET_CTRL);
+
+		readl_poll_timeout_atomic(master->regs + RESET_CTRL, status,
+					  !status, 10, 1000000);
+	} else {
+		list_del_init(&xfer->node);
+	}
+}
+
+static void aspeed_i3c_master_dequeue_xfer(struct aspeed_i3c_master *master,
+				       struct aspeed_i3c_xfer *xfer)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->xferqueue.lock, flags);
+	aspeed_i3c_master_dequeue_xfer_locked(master, xfer);
+	spin_unlock_irqrestore(&master->xferqueue.lock, flags);
+}
+
+static void aspeed_i3c_master_sir_handler(struct aspeed_i3c_master *master,
+				      u32 ibi_status)
+{
+	struct aspeed_i3c_i2c_dev_data *data;
+	struct i3c_dev_desc *dev;
+	struct i3c_ibi_slot *slot;
+	u8 addr = IBI_QUEUE_IBI_ADDR(ibi_status);
+	u8 length = IBI_QUEUE_STATUS_DATA_LEN(ibi_status);
+	u8 *buf;
+	bool data_consumed = false;
+
+	dev = master->ibi.slots[addr];
+	if (!dev) {
+		pr_warn("no matching dev\n");
+		goto out;
+	}
+
+	spin_lock(&master->ibi.lock);
+	data = i3c_dev_get_master_data(dev);
+	slot = i3c_generic_ibi_get_free_slot(data->ibi_pool);
+	if (!slot) {
+		pr_err("no free ibi slot\n");
+		goto out_unlock;
+	}
+	buf = slot->data;
+	/* prepend ibi status */
+	memcpy(buf, &ibi_status, sizeof(ibi_status));
+	buf += sizeof(ibi_status);
+
+	aspeed_i3c_master_read_ibi_fifo(master, buf, length);
+	slot->len = length + sizeof(ibi_status);
+	i3c_master_queue_ibi(dev, slot);
+	data_consumed = true;
+out_unlock:
+	spin_unlock(&master->ibi.lock);
+
+out:
+	/* Consume data from the FIFO if it's not been done already. */
+	if (!data_consumed) {
+		int nwords = (length + 3) >> 2;
+		int i;
+
+		for (i = 0; i < nwords; i++)
+			readl(master->regs + IBI_QUEUE_DATA);
+	}
+}
+
+static void aspeed_i3c_master_demux_ibis(struct aspeed_i3c_master *master)
+{
+	u32 nibi, status;
+	int i;
+	u8 addr;
+
+	nibi = readl(master->regs + QUEUE_STATUS_LEVEL);
+	nibi = QUEUE_STATUS_IBI_STATUS_CNT(nibi);
+	if (!nibi)
+		return;
+
+	for (i = 0; i < nibi; i++) {
+		status = readl(master->regs + IBI_QUEUE_STATUS);
+		addr = IBI_QUEUE_IBI_ADDR(status);
+
+		/* FIXME: how to handle the unrecognized slave? */
+		if (status & IBI_QUEUE_STATUS_RSP_NACK)
+			pr_warn_once("ibi from unrecognized slave %02x\n",
+				     addr);
+
+		if (status & IBI_QUEUE_STATUS_PEC_ERR)
+			pr_warn("ibi crc/pec error\n");
+
+		if (IBI_TYPE_SIR(status))
+			aspeed_i3c_master_sir_handler(master, status);
+
+		if (IBI_TYPE_HJ(status))
+			queue_work(master->base.wq, &master->hj_work);
+
+		if (IBI_TYPE_MR(status))
+			pr_info("get mr from %02x\n", addr);
+	}
+}
+
+static void aspeed_i3c_master_end_xfer_locked(struct aspeed_i3c_master *master, u32 isr)
+{
+	struct aspeed_i3c_xfer *xfer = master->xferqueue.cur;
+	int i, ret = 0;
+	u32 nresp;
+
+	if (!xfer)
+		return;
+
+	nresp = readl(master->regs + QUEUE_STATUS_LEVEL);
+	nresp = QUEUE_STATUS_LEVEL_RESP(nresp);
+
+	for (i = 0; i < nresp; i++) {
+		struct aspeed_i3c_cmd *cmd;
+		u32 resp;
+
+		resp = readl(master->regs + RESPONSE_QUEUE_PORT);
+
+		cmd = &xfer->cmds[RESPONSE_PORT_TID(resp)];
+		cmd->rx_len = RESPONSE_PORT_DATA_LEN(resp);
+		cmd->error = RESPONSE_PORT_ERR_STATUS(resp);
+		if (cmd->rx_len && !cmd->error)
+			aspeed_i3c_master_read_rx_fifo(master, cmd->rx_buf,
+						   cmd->rx_len);
+	}
+
+	for (i = 0; i < nresp; i++) {
+		switch (xfer->cmds[i].error) {
+		case RESPONSE_NO_ERROR:
+			break;
+		case RESPONSE_ERROR_PARITY:
+		case RESPONSE_ERROR_IBA_NACK:
+		case RESPONSE_ERROR_TRANSF_ABORT:
+		case RESPONSE_ERROR_CRC:
+		case RESPONSE_ERROR_FRAME:
+		case RESPONSE_ERROR_PEC_ERR:
+			ret = -EIO;
+			break;
+		case RESPONSE_ERROR_OVER_UNDER_FLOW:
+			ret = -ENOSPC;
+			break;
+		case RESPONSE_ERROR_I2C_W_NACK_ERR:
+		case RESPONSE_ERROR_ADDRESS_NACK:
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	xfer->ret = ret;
+	complete(&xfer->comp);
+
+	if (ret < 0) {
+		aspeed_i3c_master_dequeue_xfer_locked(master, xfer);
+		aspeed_i3c_master_resume(master);
+	}
+
+	xfer = list_first_entry_or_null(&master->xferqueue.list,
+					struct aspeed_i3c_xfer,
+					node);
+	if (xfer)
+		list_del_init(&xfer->node);
+
+	master->xferqueue.cur = xfer;
+	aspeed_i3c_master_start_xfer_locked(master);
+}
+
+struct i3c_scl_timing_cfg {
+	unsigned long fscl;
+	u16 period_hi;
+	u16 period_lo;
+};
+
+static struct i3c_scl_timing_cfg jesd403_timing_cfg[5] = {
+	{ .fscl = I3C_BUS_TYP_I3C_SCL_RATE, .period_hi = 40, .period_lo = 40 },
+	{ .fscl = I3C_BUS_SDR1_SCL_RATE, .period_hi = 50, .period_lo = 75 },
+	{ .fscl = I3C_BUS_SDR2_SCL_RATE, .period_hi = 65, .period_lo = 100 },
+	{ .fscl = I3C_BUS_SDR3_SCL_RATE, .period_hi = 100, .period_lo = 150 },
+	{ .fscl = I3C_BUS_SDR4_SCL_RATE, .period_hi = 200, .period_lo = 300 }
+};
+
+struct i3c_scl_timing_cfg *ast2600_i3c_jesd403_scl_search(unsigned long fscl)
+{
+	int i;
+
+	for (i = 0; i < 5; i++) {
+		if (fscl == jesd403_timing_cfg[i].fscl)
+			return &jesd403_timing_cfg[i];
+	}
+
+	/* use typical 12.5M SCL if not found */
+	return &jesd403_timing_cfg[0];
+}
+
+static int calc_i2c_clk(struct aspeed_i3c_master *master, unsigned long fscl,
+			u16 *hcnt, u16 *lcnt)
+{
+	unsigned long core_rate, core_period;
+	u32 period_cnt, margin;
+	u32 hcnt_min, lcnt_min;
+
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
+
+	if (fscl <= 100000) {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_STD_TLOW_MIN_NS +
+						I3C_BUS_I2C_STD_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_STD_THIGH_MIN_NS +
+						I3C_BUS_I2C_STD_TR_MAX_NS,
+					core_period);
+	} else if (fscl <= 400000) {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_NS +
+						I3C_BUS_I2C_FM_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FM_THIGH_MIN_NS +
+						I3C_BUS_I2C_FM_TR_MAX_NS,
+					core_period);
+	} else {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_NS +
+						I3C_BUS_I2C_FMP_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FMP_THIGH_MIN_NS +
+						I3C_BUS_I2C_FMP_TR_MAX_NS,
+					core_period);
+	}
+
+	period_cnt = DIV_ROUND_UP(core_rate, fscl);
+	margin = (period_cnt - hcnt_min - lcnt_min) >> 1;
+	*lcnt = lcnt_min + margin;
+	*hcnt = max(period_cnt - *lcnt, hcnt_min);
+
+	return 0;
+}
+
+static int aspeed_i3c_clk_cfg(struct aspeed_i3c_master *master)
+{
+	unsigned long core_rate, core_period;
+	u32 scl_timing;
+	u16 hcnt, lcnt;
+
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
+
+	/* I3C PP mode */
+	if (master->timing.i3c_pp_scl_high && master->timing.i3c_pp_scl_low) {
+		hcnt = DIV_ROUND_CLOSEST(master->timing.i3c_pp_scl_high,
+					 core_period);
+		lcnt = DIV_ROUND_CLOSEST(master->timing.i3c_pp_scl_low,
+					 core_period);
+	} else if (master->base.jdec_spd) {
+		struct i3c_scl_timing_cfg *pp_timing;
+
+		pp_timing = ast2600_i3c_jesd403_scl_search(
+			master->base.bus.scl_rate.i3c);
+		hcnt = DIV_ROUND_UP(pp_timing->period_hi, core_period);
+		lcnt = DIV_ROUND_UP(pp_timing->period_lo, core_period);
+	} else {
+		hcnt = DIV_ROUND_UP(I3C_BUS_THIGH_MAX_NS, core_period) - 1;
+		if (hcnt < SCL_I3C_TIMING_CNT_MIN)
+			hcnt = SCL_I3C_TIMING_CNT_MIN;
+
+		lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_TYP_I3C_SCL_RATE) - hcnt;
+		if (lcnt < SCL_I3C_TIMING_CNT_MIN)
+			lcnt = SCL_I3C_TIMING_CNT_MIN;
+	}
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I3C_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I3C_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I3C_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I3C_TIMING_LCNT, lcnt);
+	writel(scl_timing, master->regs + SCL_I3C_PP_TIMING);
+
+	/* I3C OD mode:
+	 * User defined
+	 *     check if hcnt/lcnt exceed the max value of the register
+	 *
+	 * JESD403 timing constrain for I2C/I3C OP mode
+	 *     tHIGH > 260, tLOW > 500 (same with MIPI 1.1 FMP constrain)
+	 *
+	 * MIPI 1.1 timing constrain for I3C OP mode
+	 *     tHIGH < 41, tLOW > 200
+	 */
+	if (master->timing.i3c_od_scl_high && master->timing.i3c_od_scl_low) {
+		hcnt = DIV_ROUND_CLOSEST(master->timing.i3c_od_scl_high,
+					 core_period);
+		lcnt = DIV_ROUND_CLOSEST(master->timing.i3c_od_scl_low,
+					 core_period);
+	} else if (master->base.jdec_spd) {
+		calc_i2c_clk(master, I3C_BUS_I2C_FM_PLUS_SCL_RATE, &hcnt, &lcnt);
+	} else {
+		lcnt = DIV_ROUND_UP(I3C_BUS_TLOW_OD_MIN_NS, core_period);
+		scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+		hcnt = FIELD_GET(SCL_I3C_TIMING_HCNT, scl_timing);
+	}
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I3C_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I3C_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I3C_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I3C_TIMING_LCNT, lcnt);
+	writel(scl_timing, master->regs + SCL_I3C_OD_TIMING);
+
+	/* I2C FM mode */
+	calc_i2c_clk(master, master->base.bus.scl_rate.i2c, &hcnt, &lcnt);
+	scl_timing = FIELD_PREP(SCL_I2C_FM_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FM_TIMING_LCNT, lcnt);
+	writel(scl_timing, master->regs + SCL_I2C_FM_TIMING);
+
+	/*
+	 * I3C register 0xd4[15:0] BUS_FREE_TIMING used to control several parameters:
+	 * - tCAS & tCASr (tHD_STA in JESD403)
+	 * - tCBP & tCBPr (tSU_STO in JESD403)
+	 * - bus free time between a STOP condition and a START condition
+	 *
+	 * The constraints of these two parameters are different in different bus contexts
+	 * - MIPI I3C, mixed bus: 0xd4[15:0] = I2C SCL low period (handled in aspeed_i2c_clk_cfg)
+	 * - MIPI I3C, pure bus : 0xd4[15:0] = I3C SCL PP low period
+	 * - JESD403            : 0xd4[15:0] = I3C SCL OD low period
+	 */
+	if (!(readl(master->regs + DEVICE_CTRL) & DEV_CTRL_I2C_SLAVE_PRESENT)) {
+		if (master->base.jdec_spd)
+			scl_timing = readl(master->regs + SCL_I3C_OD_TIMING);
+		else
+			scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+
+		lcnt = FIELD_GET(SCL_I3C_TIMING_LCNT, scl_timing);
+		scl_timing = BUS_I3C_AVAILABLE_TIME(0xffff);
+		scl_timing |= BUS_I3C_MST_FREE(lcnt);
+		writel(scl_timing, master->regs + BUS_FREE_TIMING);
+	}
+
+	/* Extend SDR: use PP mode hcnt */
+	scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+	hcnt = scl_timing >> 16;
+	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR1_SCL_RATE) - hcnt;
+	scl_timing = SCL_EXT_LCNT_1(lcnt);
+	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR2_SCL_RATE) - hcnt;
+	scl_timing |= SCL_EXT_LCNT_2(lcnt);
+	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR3_SCL_RATE) - hcnt;
+	scl_timing |= SCL_EXT_LCNT_3(lcnt);
+	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR4_SCL_RATE) - hcnt;
+	scl_timing |= SCL_EXT_LCNT_4(lcnt);
+	writel(scl_timing, master->regs + SCL_EXT_LCNT_TIMING);
+
+	ast_clrsetbits(master->regs + SCL_EXT_TERMN_LCNT_TIMING, GENMASK(3, 0),
+		      I3C_BUS_EXT_TERMN_CNT);
+
+	return 0;
+}
+
+static int aspeed_i2c_clk_cfg(struct aspeed_i3c_master *master)
+{
+	unsigned long core_rate, core_period;
+	u16 hcnt, lcnt;
+	u32 scl_timing;
+
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
+
+	calc_i2c_clk(master, I3C_BUS_I2C_FM_PLUS_SCL_RATE, &hcnt, &lcnt);
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I2C_FMP_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I2C_FMP_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I2C_FMP_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FMP_TIMING_LCNT, lcnt);
+	writel(scl_timing, master->regs + SCL_I2C_FMP_TIMING);
+
+	calc_i2c_clk(master, master->base.bus.scl_rate.i2c, &hcnt, &lcnt);
+	scl_timing = FIELD_PREP(SCL_I2C_FM_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FM_TIMING_LCNT, lcnt);
+	writel(scl_timing, master->regs + SCL_I2C_FM_TIMING);
+
+	scl_timing = BUS_I3C_AVAILABLE_TIME(0xffff);
+	scl_timing |= BUS_I3C_MST_FREE(lcnt);
+	writel(scl_timing, master->regs + BUS_FREE_TIMING);
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_I2C_SLAVE_PRESENT,
+	       master->regs + DEVICE_CTRL);
+
+	return 0;
+}
+
+static int aspeed_i3c_master_set_info(struct aspeed_i3c_master *master,
+				       struct i3c_device_info *info)
+{
+#define ASPEED_SCU_REV_ID_REG 0x14
+#define ASPEED_HW_REV(x) (((x)&GENMASK(31, 16)) >> 16)
+
+	struct regmap *scu;
+	unsigned int reg;
+	u32 part_id, inst_id;
+
+	writel(PID_MANUF_ID_ASPEED << 1, master->regs + SLV_MIPI_PID_VALUE);
+
+	scu = syscon_regmap_lookup_by_phandle(master->dev->of_node, "aspeed,scu");
+	if (IS_ERR(scu)) {
+		dev_err(master->dev, "cannot to find SCU regmap\n");
+		return -ENODEV;
+	}
+	regmap_read(scu, ASPEED_SCU_REV_ID_REG, &reg);
+	part_id = ASPEED_HW_REV(reg);
+	inst_id = master->base.bus.id;
+
+	reg = SLV_PID_PART_ID(part_id) | SLV_PID_INST_ID(inst_id) |
+	      SLV_PID_DCR(0);
+	writel(reg, master->regs + SLV_PID_VALUE);
+
+	reg = readl(master->regs + SLV_CHAR_CTRL);
+	info->dcr = SLV_CHAR_GET_DCR(reg);
+	info->bcr = SLV_CHAR_GET_BCR(reg);
+	info->pid = (u64)readl(master->regs + SLV_MIPI_PID_VALUE) << 32;
+	info->pid |= readl(master->regs + SLV_PID_VALUE);
+
+	return 0;
+};
+
+static int aspeed_i3c_master_bus_init(struct i3c_master_controller *m)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct i3c_bus *bus = i3c_master_get_bus(m);
+	struct i3c_device_info info = { };
+	u32 thld_ctrl;
+	int ret;
+
+	aspeed_i3c_master_set_role(master);
+
+	switch (bus->mode) {
+	case I3C_BUS_MODE_MIXED_FAST:
+	case I3C_BUS_MODE_MIXED_LIMITED:
+		ret = aspeed_i2c_clk_cfg(master);
+		if (ret)
+			return ret;
+		fallthrough;
+	case I3C_BUS_MODE_PURE:
+		ret = aspeed_i3c_clk_cfg(master);
+		if (ret)
+			return ret;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+
+	thld_ctrl = readl(master->regs + DATA_BUFFER_THLD_CTRL);
+	thld_ctrl &= ~DATA_BUFFER_THLD_CTRL_RX_BUF;
+	writel(thld_ctrl, master->regs + DATA_BUFFER_THLD_CTRL);
+
+	writel(INTR_ALL, master->regs + INTR_STATUS);
+	if (master->secondary) {
+		writel(INTR_2ND_MASTER_MASK, master->regs + INTR_STATUS_EN);
+		/*
+		 * No need for INTR_IBI_UPDATED_STAT signal, check this bit
+		 * when INTR_RESP_READY_STAT signal is up.  This can guarantee
+		 * the SIR payload is ACKed by the master.
+		 */
+		writel(INTR_2ND_MASTER_MASK & ~INTR_IBI_UPDATED_STAT,
+		       master->regs + INTR_SIGNAL_EN);
+	} else {
+		writel(INTR_MASTER_MASK, master->regs + INTR_STATUS_EN);
+		writel(INTR_MASTER_MASK, master->regs + INTR_SIGNAL_EN);
+	}
+
+	memset(&info, 0, sizeof(info));
+	ret = aspeed_i3c_master_set_info(master, &info);
+	if (ret < 0)
+		return ret;
+
+	ret = i3c_master_get_free_addr(m, 0);
+	if (ret < 0)
+		return ret;
+
+	if (master->secondary)
+		writel(DEV_ADDR_STATIC_ADDR_VALID | DEV_ADDR_STATIC(ret),
+		       master->regs + DEVICE_ADDR);
+	else
+		writel(DEV_ADDR_DYNAMIC_ADDR_VALID | DEV_ADDR_DYNAMIC(ret),
+		       master->regs + DEVICE_ADDR);
+
+	info.dyn_addr = ret;
+
+	ret = i3c_master_set_info(&master->base, &info);
+	if (ret)
+		return ret;
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &=
+		~(QUEUE_THLD_CTRL_IBI_STA_MASK | QUEUE_THLD_CTRL_IBI_DAT_MASK);
+	thld_ctrl |= QUEUE_THLD_CTRL_IBI_STA(1);
+	thld_ctrl |= QUEUE_THLD_CTRL_IBI_DAT(MAX_IBI_FRAG_SIZE >> 2);
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+
+	writel(IBI_REQ_REJECT_ALL, master->regs + IBI_SIR_REQ_REJECT);
+	writel(IBI_REQ_REJECT_ALL, master->regs + IBI_MR_REQ_REJECT);
+
+	/* For now don't support Hot-Join */
+	ast_setbits(master->regs + DEVICE_CTRL,
+		   DEV_CTRL_AUTO_HJ_DISABLE |
+		   DEV_CTRL_HOT_JOIN_NACK |
+		   DEV_CRTL_IBI_PAYLOAD_EN);
+
+	aspeed_i3c_master_enable(master);
+
+	/* workaround for aspeed slave devices.  The aspeed slave devices need
+	 * for a dummy ccc and resume before accessing. Hide this workarond here
+	 * and later the i3c subsystem code will do the rstdaa again.
+	 */
+	if (!master->secondary)
+		i3c_master_rstdaa_locked(m, I3C_BROADCAST_ADDR);
+
+	return 0;
+}
+
+static void aspeed_i3c_master_bus_cleanup(struct i3c_master_controller *m)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+
+	aspeed_i3c_master_disable(master);
+}
+
+static void aspeed_i3c_master_bus_reset(struct i3c_master_controller *m)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	u32 reset;
+
+	reset = RESET_CTRL_BUS |
+		FIELD_PREP(RESET_CTRL_BUS_RESET_TYPE, BUS_RESET_TYPE_SCL_LOW);
+
+	writel(reset, master->regs + RESET_CTRL);
+}
+
+static int aspeed_i3c_ccc_set(struct aspeed_i3c_master *master,
+			  struct i3c_ccc_cmd *ccc)
+{
+	struct aspeed_i3c_xfer *xfer;
+	struct aspeed_i3c_cmd *cmd;
+	int ret, pos = 0;
+
+	if (ccc->id & I3C_CCC_DIRECT) {
+		pos = aspeed_i3c_master_sync_hw_dat(master, ccc->dests[0].addr);
+		if (pos < 0)
+			return pos;
+	}
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, 1);
+	if (!xfer)
+		return -ENOMEM;
+
+	cmd = xfer->cmds;
+	cmd->tx_buf = ccc->dests[0].payload.data;
+	cmd->tx_len = ccc->dests[0].payload.len;
+
+	cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(ccc->dests[0].payload.len) |
+		      COMMAND_PORT_TRANSFER_ARG | COMMAND_PORT_ARG_DBP(ccc->db);
+
+	cmd->cmd_lo = COMMAND_PORT_CP |
+		      COMMAND_PORT_DEV_INDEX(pos) |
+		      COMMAND_PORT_CMD(ccc->id) |
+		      COMMAND_PORT_TOC |
+		      COMMAND_PORT_ROC |
+		      COMMAND_PORT_DBP(ccc->dbp);
+
+	dev_dbg(master->dev, "%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d id=%x\n",
+		__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len, ccc->id);
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	ret = xfer->ret;
+	if (ret)
+		dev_err(master->dev, "xfer error: %x\n", xfer->cmds[0].error);
+	if (xfer->cmds[0].error == RESPONSE_ERROR_IBA_NACK)
+		ccc->err = I3C_ERROR_M2;
+
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int aspeed_i3c_ccc_get(struct aspeed_i3c_master *master, struct i3c_ccc_cmd *ccc)
+{
+	struct aspeed_i3c_xfer *xfer;
+	struct aspeed_i3c_cmd *cmd;
+	int ret, pos;
+
+	pos = aspeed_i3c_master_sync_hw_dat(master, ccc->dests[0].addr);
+	if (pos < 0)
+		return pos;
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, 1);
+	if (!xfer)
+		return -ENOMEM;
+
+	cmd = xfer->cmds;
+	cmd->rx_buf = ccc->dests[0].payload.data;
+	cmd->rx_len = ccc->dests[0].payload.len;
+
+	cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(ccc->dests[0].payload.len) |
+		      COMMAND_PORT_TRANSFER_ARG | COMMAND_PORT_ARG_DBP(ccc->db);
+
+	cmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |
+		      COMMAND_PORT_CP |
+		      COMMAND_PORT_DEV_INDEX(pos) |
+		      COMMAND_PORT_CMD(ccc->id) |
+		      COMMAND_PORT_TOC |
+		      COMMAND_PORT_ROC |
+		      COMMAND_PORT_DBP(ccc->dbp);
+
+	dev_dbg(master->dev, "%s:cmd_hi=0x%08x cmd_lo=0x%08x rx_len=%d id=%x\n",
+		__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->rx_len, ccc->id);
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	ret = xfer->ret;
+	if (ret)
+		dev_err(master->dev, "xfer error: %x\n", xfer->cmds[0].error);
+	if (xfer->cmds[0].error == RESPONSE_ERROR_IBA_NACK)
+		ccc->err = I3C_ERROR_M2;
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int aspeed_i3c_master_send_ccc_cmd(struct i3c_master_controller *m,
+				      struct i3c_ccc_cmd *ccc)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	int ret = 0;
+	u32 i3c_pp_timing, i3c_od_timing;
+
+	if (ccc->id == I3C_CCC_ENTDAA)
+		return -EINVAL;
+
+	i3c_od_timing = readl(master->regs + SCL_I3C_OD_TIMING);
+	i3c_pp_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID) ||
+	    (ccc->id == I3C_CCC_DEVCTRL))
+		writel(i3c_od_timing, master->regs + SCL_I3C_PP_TIMING);
+
+	dev_dbg(master->dev, "ccc-id %02x rnw=%d\n", ccc->id, ccc->rnw);
+
+	if (ccc->rnw)
+		ret = aspeed_i3c_ccc_get(master, ccc);
+	else
+		ret = aspeed_i3c_ccc_set(master, ccc);
+
+	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID) ||
+	    (ccc->id == I3C_CCC_DEVCTRL))
+		writel(i3c_pp_timing, master->regs + SCL_I3C_PP_TIMING);
+
+	return ret;
+}
+
+#define IS_MANUF_ID_ASPEED(x) (I3C_PID_MANUF_ID(x) == PID_MANUF_ID_ASPEED)
+#define IS_PART_ID_AST2600_SERIES(x)                                           \
+	((I3C_PID_PART_ID(x) & PID_PART_ID_AST2600_SERIES) ==                  \
+	 PID_PART_ID_AST2600_SERIES)
+#define IS_PART_ID_AST1030_A0(x)                                               \
+	((I3C_PID_PART_ID(x) & PID_PART_ID_AST1030_A0) ==                      \
+	 PID_PART_ID_AST1030_A0)
+
+static int aspeed_i3c_master_daa(struct i3c_master_controller *m)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_xfer *xfer;
+	struct aspeed_i3c_cmd *cmd;
+	u32 olddevs, newdevs;
+	u8 p, last_addr = 0;
+	int ret, pos, ndevs;
+
+	olddevs = ~(master->free_pos);
+	ndevs = 0;
+
+	/* Prepare DAT before launching DAA. */
+	for (pos = 0; pos < master->maxdevs; pos++) {
+		if (olddevs & BIT(pos))
+			continue;
+
+		ret = i3c_master_get_free_addr(m, last_addr + 1);
+		if (ret < 0)
+			break;
+
+		ndevs++;
+
+		master->addrs[pos] = ret;
+		p = even_parity(ret);
+		last_addr = ret;
+		ret |= (p << 7);
+
+		writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(ret),
+		       master->regs +
+		       DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+	}
+
+	if (!ndevs)
+		return -ENOSPC;
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, 1);
+	if (!xfer)
+		return -ENOMEM;
+
+	pos = aspeed_i3c_master_get_free_pos(master);
+	cmd = &xfer->cmds[0];
+	cmd->cmd_hi = 0x1;
+	cmd->cmd_lo = COMMAND_PORT_DEV_COUNT(ndevs) |
+		      COMMAND_PORT_DEV_INDEX(pos) |
+		      COMMAND_PORT_CMD(I3C_CCC_ENTDAA) |
+		      COMMAND_PORT_ADDR_ASSGN_CMD |
+		      COMMAND_PORT_TOC |
+		      COMMAND_PORT_ROC;
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	newdevs = GENMASK(ndevs - cmd->rx_len - 1, 0) << pos;
+	for (pos = 0; pos < master->maxdevs; pos++) {
+		if (newdevs & BIT(pos)) {
+			u32 dat = GET_DAT_FROM_POS(master, pos);
+			u32 addr = GET_DYNAMIC_ADDR_FROM_DAT(dat);
+
+			aspeed_i3c_master_set_group_dat(master, addr, dat);
+			i3c_master_add_i3c_dev_locked(m, addr);
+		}
+
+		/* cleanup the free HW DATs */
+		if (master->free_pos & BIT(pos))
+			writel(0, master->regs +
+					  DEV_ADDR_TABLE_LOC(
+						  master->datstartaddr, pos));
+	}
+
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return 0;
+}
+#ifdef CONFIG_AST2600_I3C_CCC_WORKAROUND
+/*
+ * Provide an interface for sending CCC from userspace.  Especially for the
+ * transfers with PEC and direct CCC.
+ */
+static int aspeed_i3c_master_ccc_xfers(struct i3c_dev_desc *dev,
+				    struct i3c_priv_xfer *i3c_xfers,
+				    int i3c_nxfers)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_xfer *xfer;
+	int i, ret = 0;
+	struct aspeed_i3c_cmd *cmd_ccc;
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, i3c_nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	/* i3c_xfers[0] handles the CCC data */
+	cmd_ccc = &xfer->cmds[0];
+	cmd_ccc->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i3c_xfers[0].len - 1) |
+			  COMMAND_PORT_TRANSFER_ARG;
+	cmd_ccc->tx_buf = i3c_xfers[0].data.out + 1;
+	cmd_ccc->tx_len = i3c_xfers[0].len - 1;
+	cmd_ccc->cmd_lo = COMMAND_PORT_SPEED(dev->info.max_write_ds);
+	cmd_ccc->cmd_lo |= COMMAND_PORT_TID(0) |
+			   COMMAND_PORT_DEV_INDEX(master->maxdevs - 1) |
+			   COMMAND_PORT_ROC;
+	if (i3c_nxfers == 1)
+		cmd_ccc->cmd_lo |= COMMAND_PORT_TOC;
+
+	dev_dbg(master->dev,
+		"%s:cmd_ccc_hi=0x%08x cmd_ccc_lo=0x%08x tx_len=%d\n", __func__,
+		cmd_ccc->cmd_hi, cmd_ccc->cmd_lo, cmd_ccc->tx_len);
+
+	for (i = 1; i < i3c_nxfers; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i3c_xfers[i].len) |
+			COMMAND_PORT_TRANSFER_ARG;
+
+		if (i3c_xfers[i].rnw) {
+			cmd->rx_buf = i3c_xfers[i].data.in;
+			cmd->rx_len = i3c_xfers[i].len;
+			cmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |
+				      COMMAND_PORT_SPEED(dev->info.max_read_ds);
+
+		} else {
+			cmd->tx_buf = i3c_xfers[i].data.out;
+			cmd->tx_len = i3c_xfers[i].len;
+			cmd->cmd_lo =
+				COMMAND_PORT_SPEED(dev->info.max_write_ds);
+		}
+
+		cmd->cmd_lo |= COMMAND_PORT_TID(i) |
+			       COMMAND_PORT_DEV_INDEX(data->index) |
+			       COMMAND_PORT_ROC;
+
+		if (i == (i3c_nxfers - 1))
+			cmd->cmd_lo |= COMMAND_PORT_TOC;
+
+		dev_dbg(master->dev,
+			"%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d rx_len=%d\n",
+			__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len,
+			cmd->rx_len);
+	}
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	ret = xfer->ret;
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+#endif
+static int aspeed_i3c_master_priv_xfers(struct i3c_dev_desc *dev,
+				    struct i3c_priv_xfer *i3c_xfers,
+				    int i3c_nxfers)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	unsigned int nrxwords = 0, ntxwords = 0;
+	struct aspeed_i3c_xfer *xfer;
+	int i, ret = 0;
+
+	if (!i3c_nxfers)
+		return 0;
+
+	if (i3c_nxfers > master->caps.cmdfifodepth)
+		return -ENOTSUPP;
+
+	for (i = 0; i < i3c_nxfers; i++) {
+		if (i3c_xfers[i].rnw)
+			nrxwords += DIV_ROUND_UP(i3c_xfers[i].len, 4);
+		else
+			ntxwords += DIV_ROUND_UP(i3c_xfers[i].len, 4);
+	}
+
+	if (ntxwords > master->caps.datafifodepth ||
+	    nrxwords > master->caps.datafifodepth)
+		return -ENOTSUPP;
+
+#ifdef CONFIG_AST2600_I3C_CCC_WORKAROUND
+	if (i3c_xfers[0].rnw == 0) {
+		/* write command: check if hit special address */
+		u8 tmp;
+
+		memcpy(&tmp, i3c_xfers[0].data.out, 1);
+		if (tmp == 0xff)
+			return aspeed_i3c_master_ccc_xfers(dev, i3c_xfers, i3c_nxfers);
+	}
+#endif
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, i3c_nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	data->index = aspeed_i3c_master_sync_hw_dat(master, dev->info.dyn_addr);
+
+	for (i = 0; i < i3c_nxfers; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i3c_xfers[i].len) |
+			COMMAND_PORT_TRANSFER_ARG;
+
+		if (i3c_xfers[i].rnw) {
+			cmd->rx_buf = i3c_xfers[i].data.in;
+			cmd->rx_len = i3c_xfers[i].len;
+			cmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |
+				      COMMAND_PORT_SPEED(dev->info.max_read_ds);
+
+		} else {
+			cmd->tx_buf = i3c_xfers[i].data.out;
+			cmd->tx_len = i3c_xfers[i].len;
+			cmd->cmd_lo =
+				COMMAND_PORT_SPEED(dev->info.max_write_ds);
+		}
+
+		cmd->cmd_lo |= COMMAND_PORT_TID(i) |
+			       COMMAND_PORT_DEV_INDEX(data->index) |
+			       COMMAND_PORT_ROC;
+
+		if (i == (i3c_nxfers - 1))
+			cmd->cmd_lo |= COMMAND_PORT_TOC;
+
+		if (dev->info.pec)
+			cmd->cmd_lo |= COMMAND_PORT_PEC;
+
+		dev_dbg(master->dev,
+			"%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d rx_len=%d\n",
+			__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len,
+			cmd->rx_len);
+	}
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	for (i = 0; i < i3c_nxfers; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		if (i3c_xfers[i].rnw)
+			i3c_xfers[i].len = cmd->rx_len;
+	}
+
+	ret = xfer->ret;
+	if (ret)
+		dev_err(master->dev, "xfer error: %x\n", xfer->cmds[0].error);
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int aspeed_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,
+					  u8 old_dyn_addr)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+
+	aspeed_i3c_master_set_group_dat(
+		master, dev->info.dyn_addr,
+		DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr));
+
+	master->addrs[data->index] = dev->info.dyn_addr;
+
+	return 0;
+}
+
+static int aspeed_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data;
+	int pos;
+	u8 addr = dev->info.dyn_addr ? : dev->info.static_addr;
+
+	pos = aspeed_i3c_master_set_group_dat(master, addr,
+					  DEV_ADDR_TABLE_DYNAMIC_ADDR(addr));
+	if (pos < 0)
+		return pos;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->index = aspeed_i3c_master_get_group_hw_index(master, addr);
+	master->addrs[pos] = addr;
+	i3c_dev_set_master_data(dev, data);
+
+	if (master->base.jdec_spd)
+		dev->info.max_write_ds = dev->info.max_read_ds = 0;
+
+	return 0;
+}
+
+static void aspeed_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+
+	aspeed_i3c_master_set_group_dat(master, dev->info.dyn_addr, 0);
+
+	i3c_dev_set_master_data(dev, NULL);
+	master->addrs[data->index] = 0;
+	kfree(data);
+}
+
+static int aspeed_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,
+				   const struct i2c_msg *i2c_xfers,
+				   int i2c_nxfers)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i2c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	unsigned int nrxwords = 0, ntxwords = 0;
+	struct aspeed_i3c_xfer *xfer;
+	int i, ret = 0;
+
+	if (!i2c_nxfers)
+		return 0;
+
+	if (i2c_nxfers > master->caps.cmdfifodepth)
+		return -ENOTSUPP;
+
+	for (i = 0; i < i2c_nxfers; i++) {
+		if (i2c_xfers[i].flags & I2C_M_RD)
+			nrxwords += DIV_ROUND_UP(i2c_xfers[i].len, 4);
+		else
+			ntxwords += DIV_ROUND_UP(i2c_xfers[i].len, 4);
+	}
+
+	if (ntxwords > master->caps.datafifodepth ||
+	    nrxwords > master->caps.datafifodepth)
+		return -ENOTSUPP;
+
+	xfer = aspeed_i3c_master_alloc_xfer(master, i2c_nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	data->index = aspeed_i3c_master_sync_hw_dat(master, dev->addr);
+
+	for (i = 0; i < i2c_nxfers; i++) {
+		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
+
+		cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i2c_xfers[i].len) |
+			COMMAND_PORT_TRANSFER_ARG;
+
+		cmd->cmd_lo = COMMAND_PORT_TID(i) |
+			      COMMAND_PORT_DEV_INDEX(data->index) |
+			      COMMAND_PORT_ROC;
+
+		if (i2c_xfers[i].flags & I2C_M_RD) {
+			cmd->cmd_lo |= COMMAND_PORT_READ_TRANSFER;
+			cmd->rx_buf = i2c_xfers[i].buf;
+			cmd->rx_len = i2c_xfers[i].len;
+		} else {
+			cmd->tx_buf = i2c_xfers[i].buf;
+			cmd->tx_len = i2c_xfers[i].len;
+		}
+
+		if (i == (i2c_nxfers - 1))
+			cmd->cmd_lo |= COMMAND_PORT_TOC;
+
+		dev_dbg(master->dev,
+			"%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d rx_len=%d\n",
+			__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len,
+			cmd->rx_len);
+	}
+
+	aspeed_i3c_master_enqueue_xfer(master, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
+		aspeed_i3c_master_dequeue_xfer(master, xfer);
+
+	ret = xfer->ret;
+	if (ret)
+		dev_err(master->dev, "xfer error: %x\n", xfer->cmds[0].error);
+	aspeed_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int aspeed_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i2c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data;
+	int pos;
+
+	pos = aspeed_i3c_master_set_group_dat(
+		master, dev->addr,
+		DEV_ADDR_TABLE_LEGACY_I2C_DEV |
+			DEV_ADDR_TABLE_STATIC_ADDR(dev->addr));
+	if (pos < 0)
+		return pos;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->index = aspeed_i3c_master_get_group_hw_index(master, dev->addr);
+	master->addrs[data->index] = dev->addr;
+	i2c_dev_set_master_data(dev, data);
+
+
+	return 0;
+}
+
+static void aspeed_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i2c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+
+	aspeed_i3c_master_set_group_dat(master, dev->addr, 0);
+
+	i2c_dev_set_master_data(dev, NULL);
+	master->addrs[data->index] = 0;
+	kfree(data);
+}
+
+static void aspeed_i3c_slave_event_handler(struct aspeed_i3c_master *master)
+{
+	u32 event = readl(master->regs + SLV_EVENT_CTRL);
+	u32 cm_state =
+		PRESENT_STATE_CM_ST_STS(readl(master->regs + PRESENT_STATE));
+
+	if (cm_state == CM_ST_STS_HALT) {
+		dev_dbg(master->dev, "slave in halt state\n");
+		aspeed_i3c_master_resume(master);
+	}
+
+	dev_dbg(master->dev, "slave event=%08x\n", event);
+	if (event & SLV_EVENT_CTRL_MRL_UPD)
+		dev_dbg(master->dev, "isr: master set mrl=%d\n",
+			readl(master->regs + SLV_MAX_LEN) >> 16);
+
+	if (event & SLV_EVENT_CTRL_MWL_UPD)
+		dev_dbg(master->dev, "isr: master set mwl=%ld\n",
+			readl(master->regs + SLV_MAX_LEN) & GENMASK(15, 0));
+
+	writel(event, master->regs + SLV_EVENT_CTRL);
+}
+
+static void aspeed_i3c_slave_resp_handler(struct aspeed_i3c_master *master,
+					  u32 status)
+{
+	int i, has_error = 0;
+	u32 resp, nbytes, nresp;
+	u8 error, tid;
+	u32 *buf = master->slave_data.buf;
+	struct i3c_slave_payload payload;
+
+	nresp = readl(master->regs + QUEUE_STATUS_LEVEL);
+	nresp = QUEUE_STATUS_LEVEL_RESP(nresp);
+
+	for (i = 0; i < nresp; i++) {
+		resp = readl(master->regs + RESPONSE_QUEUE_PORT);
+		error = RESPONSE_PORT_ERR_STATUS(resp);
+		nbytes = RESPONSE_PORT_DATA_LEN(resp);
+		tid = RESPONSE_PORT_TID(resp);
+
+		if (error) {
+			has_error = 1;
+			if (error == RESPONSE_ERROR_EARLY_TERMINATE)
+				dev_dbg(master->dev,
+					"early termination, remain length %d\n",
+					nbytes);
+		}
+
+		if (!error && nbytes) {
+			aspeed_i3c_master_read_rx_fifo(master, (u8 *)buf, nbytes);
+
+			payload.len = nbytes;
+			payload.data = buf;
+			/* currently only support master write transfer */
+			if (master->slave_data.callback && (tid == TID_MASTER_WRITE_DATA))
+				master->slave_data.callback(&master->base, &payload);
+		}
+	}
+
+	if (status & INTR_IBI_UPDATED_STAT)
+		complete(&master->sir_complete);
+
+	if (has_error) {
+		writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		aspeed_i3c_master_resume(master);
+	}
+}
+
+static irqreturn_t aspeed_i3c_master_irq_handler(int irq, void *dev_id)
+{
+	struct aspeed_i3c_master *master = dev_id;
+	u32 status;
+
+	status = readl(master->regs + INTR_STATUS);
+
+	if (!(status & readl(master->regs + INTR_STATUS_EN))) {
+		writel(INTR_ALL, master->regs + INTR_STATUS);
+		return IRQ_NONE;
+	}
+
+	if (master->secondary) {
+		if (status & INTR_READ_REQ_RECV_STAT)
+			dev_dbg(master->dev, "read queue received\n");
+
+		if (status & INTR_RESP_READY_STAT)
+			aspeed_i3c_slave_resp_handler(master, status);
+
+		if (status & INTR_CCC_UPDATED_STAT)
+			aspeed_i3c_slave_event_handler(master);
+	} else {
+		spin_lock(&master->xferqueue.lock);
+		aspeed_i3c_master_end_xfer_locked(master, status);
+		if (status & INTR_TRANSFER_ERR_STAT)
+			writel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);
+		spin_unlock(&master->xferqueue.lock);
+
+		if (status & INTR_IBI_THLD_STAT)
+			aspeed_i3c_master_demux_ibis(master);
+	}
+
+	writel(status, master->regs + INTR_STATUS);
+
+	return IRQ_HANDLED;
+}
+
+static void aspeed_i3c_master_enable_ibi_irq(struct aspeed_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
+static void aspeed_i3c_master_disable_ibi_irq(struct aspeed_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
+static int aspeed_i3c_master_disable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct aspeed_i3c_dev_group *dev_grp =
+		aspeed_i3c_master_get_group(master, dev->info.dyn_addr);
+	unsigned long flags;
+	u32 sirmap, dat, hj_nack;
+	int ret, i;
+	bool ibi_enable = false;
+
+	ret = i3c_master_disec_locked(m, dev->info.dyn_addr,
+				      I3C_CCC_EVENT_SIR);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&master->ibi.lock, flags);
+	dat = aspeed_i3c_master_get_group_dat(master, dev->info.dyn_addr);
+	dat |= DEV_ADDR_TABLE_SIR_REJECT;
+	dat &= ~DEV_ADDR_TABLE_IBI_WITH_DATA;
+	aspeed_i3c_master_set_group_dat(master, dev->info.dyn_addr, dat);
+
+	/*
+	 * if any available device in this group still needs to enable ibi, then
+	 * just keep the hw setting until all of the devices agree to disable ibi
+	 */
+	for (i = 0; i < MAX_DEVS_IN_GROUP; i++) {
+		if ((!(dev_grp->free_pos & BIT(i))) &&
+		    (!(dev_grp->dat[i] & DEV_ADDR_TABLE_SIR_REJECT))) {
+			ibi_enable = true;
+			break;
+		}
+	}
+
+	if (!ibi_enable) {
+		sirmap = readl(master->regs + IBI_SIR_REQ_REJECT);
+		sirmap |= BIT(data->ibi);
+		writel(sirmap, master->regs + IBI_SIR_REQ_REJECT);
+
+		dev_grp->mask.clr |= DEV_ADDR_TABLE_IBI_WITH_DATA;
+		dev_grp->mask.set &= ~DEV_ADDR_TABLE_IBI_WITH_DATA;
+		dev_grp->mask.set |= DEV_ADDR_TABLE_SIR_REJECT;
+	}
+
+	sirmap = readl(master->regs + IBI_SIR_REQ_REJECT);
+	hj_nack = readl(master->regs + DEVICE_CTRL) & DEV_CTRL_HOT_JOIN_NACK;
+	if (sirmap == IBI_REQ_REJECT_ALL && hj_nack)
+		aspeed_i3c_master_disable_ibi_irq(master);
+	else
+		aspeed_i3c_master_enable_ibi_irq(master);
+
+	spin_unlock_irqrestore(&master->ibi.lock, flags);
+
+	return ret;
+}
+
+static int aspeed_i3c_master_enable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct aspeed_i3c_dev_group *dev_grp =
+		aspeed_i3c_master_get_group(master, dev->info.dyn_addr);
+	unsigned long flags;
+	u32 sirmap, hj_nack;
+	u32 sirmap_backup, mask_clr_backup, mask_set_backup;
+	int ret;
+
+	spin_lock_irqsave(&master->ibi.lock, flags);
+	sirmap_backup = readl(master->regs + IBI_SIR_REQ_REJECT);
+	sirmap = sirmap_backup & ~BIT(data->ibi);
+	writel(sirmap, master->regs + IBI_SIR_REQ_REJECT);
+
+	mask_clr_backup = dev_grp->mask.clr;
+	mask_set_backup = dev_grp->mask.set;
+	dev_grp->mask.clr |= DEV_ADDR_TABLE_SIR_REJECT;
+	dev_grp->mask.set &= ~DEV_ADDR_TABLE_SIR_REJECT;
+	if (IS_MANUF_ID_ASPEED(dev->info.pid))
+		dev_grp->mask.set |= DEV_ADDR_TABLE_IBI_PEC_EN;
+	if (dev->info.bcr & I3C_BCR_IBI_PAYLOAD)
+		dev_grp->mask.set |= DEV_ADDR_TABLE_IBI_WITH_DATA;
+
+	spin_unlock_irqrestore(&master->ibi.lock, flags);
+
+	dev_dbg(master->dev, "addr:%x, hw_index:%d, data->ibi:%d, mask: %08x %08x\n",
+		dev->info.dyn_addr, dev_grp->hw_index, data->ibi, dev_grp->mask.set,
+		dev_grp->mask.clr);
+
+	/* Dat will be synchronized before sending the CCC */
+	ret = i3c_master_enec_locked(m, dev->info.dyn_addr,
+				     I3C_CCC_EVENT_SIR);
+
+	if (ret) {
+		spin_lock_irqsave(&master->ibi.lock, flags);
+		writel(sirmap_backup, master->regs + IBI_SIR_REQ_REJECT);
+
+		dev_grp->mask.clr = mask_clr_backup;
+		dev_grp->mask.set = mask_set_backup;
+		aspeed_i3c_master_sync_hw_dat(master, dev->info.dyn_addr);
+		spin_unlock_irqrestore(&master->ibi.lock, flags);
+	}
+
+	sirmap = readl(master->regs + IBI_SIR_REQ_REJECT);
+	hj_nack = readl(master->regs + DEVICE_CTRL) & DEV_CTRL_HOT_JOIN_NACK;
+	if (sirmap == IBI_REQ_REJECT_ALL && hj_nack)
+		aspeed_i3c_master_disable_ibi_irq(master);
+	else
+		aspeed_i3c_master_enable_ibi_irq(master);
+
+	return ret;
+}
+
+static int aspeed_i3c_master_request_ibi(struct i3c_dev_desc *dev,
+				       const struct i3c_ibi_setup *req)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	unsigned long flags;
+	unsigned int i;
+
+	data->ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);
+	if (IS_ERR(data->ibi_pool))
+		return PTR_ERR(data->ibi_pool);
+
+	spin_lock_irqsave(&master->ibi.lock, flags);
+	master->ibi.slots[dev->info.dyn_addr & 0x7f] = dev;
+	data->ibi =
+		aspeed_i3c_master_get_group_hw_index(master, dev->info.dyn_addr);
+	spin_unlock_irqrestore(&master->ibi.lock, flags);
+
+	if (i < MAX_DEVS)
+		return 0;
+
+	i3c_generic_ibi_free_pool(data->ibi_pool);
+	data->ibi_pool = NULL;
+
+	return -ENOSPC;
+}
+
+static void aspeed_i3c_master_free_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->ibi.lock, flags);
+	master->ibi.slots[dev->info.dyn_addr] = NULL;
+	data->ibi = -1;
+	spin_unlock_irqrestore(&master->ibi.lock, flags);
+
+	i3c_generic_ibi_free_pool(data->ibi_pool);
+}
+
+static void aspeed_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev,
+					     struct i3c_ibi_slot *slot)
+{
+	struct aspeed_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+
+	i3c_generic_ibi_recycle_slot(data->ibi_pool, slot);
+}
+
+static int aspeed_i3c_master_register_slave(struct i3c_master_controller *m,
+			      const struct i3c_slave_setup *req)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	u32 *buf;
+
+	buf = kzalloc(req->max_payload_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	master->slave_data.callback = req->handler;
+	master->slave_data.buf = buf;
+
+	return 0;
+}
+
+static int aspeed_i3c_master_unregister_slave(struct i3c_master_controller *m)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+
+	master->slave_data.callback = NULL;
+	kfree(master->slave_data.buf);
+
+	return 0;
+}
+
+static int aspeed_i3c_master_send_sir(struct i3c_master_controller *m,
+				      struct i3c_slave_payload *payload)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	uint32_t slv_event, intr_req, reg, thld_ctrl;
+	uint8_t *data = (uint8_t *)payload->data;
+
+	slv_event = readl(master->regs + SLV_EVENT_CTRL);
+	if ((slv_event & SLV_EVENT_CTRL_SIR_EN) == 0)
+		return -EPERM;
+
+	if (!payload)
+		return -ENXIO;
+
+	if (payload->len > (CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD + 1)) {
+		dev_err(master->dev,
+			"input length %d exceeds max ibi payload size %d\n",
+			payload->len, CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD + 1);
+		return -E2BIG;
+	}
+
+	init_completion(&master->sir_complete);
+
+	reg = readl(master->regs + DEVICE_CTRL);
+	reg &= ~DEV_CTRL_SLAVE_MDB;
+	reg |= FIELD_PREP(DEV_CTRL_SLAVE_MDB, data[0]) |
+	       FIELD_PREP(DEV_CTRL_SLAVE_PEC_EN, 1);
+	writel(reg, master->regs + DEVICE_CTRL);
+
+	aspeed_i3c_master_wr_tx_fifo(master, data, payload->len);
+
+	reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, payload->len);
+	writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+
+	writel(1, master->regs + SLV_INTR_REQ);
+	if (!wait_for_completion_timeout(&master->sir_complete, XFER_TIMEOUT)) {
+		dev_err(master->dev, "send sir timeout\n");
+		writel(RESET_CTRL_RX_FIFO | RESET_CTRL_TX_FIFO |
+			       RESET_CTRL_RESP_QUEUE | RESET_CTRL_CMD_QUEUE,
+		       master->regs + RESET_CTRL);
+	}
+
+	reg = readl(master->regs + DEVICE_CTRL);
+	reg &= ~DEV_CTRL_SLAVE_PEC_EN;
+	writel(reg, master->regs + DEVICE_CTRL);
+
+	intr_req = readl(master->regs + SLV_INTR_REQ);
+	if (SLV_INTR_REQ_IBI_STS(intr_req) != SLV_IBI_STS_OK) {
+		slv_event = readl(master->regs + SLV_EVENT_CTRL);
+		if ((slv_event & SLV_EVENT_CTRL_SIR_EN) == 0)
+			pr_warn("sir is disabled by master\n");
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static int aspeed_i3c_master_put_read_data(struct i3c_master_controller *m,
+					   struct i3c_slave_payload *data,
+					   struct i3c_slave_payload *ibi_notify)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	u32 reg, thld_ctrl;
+	u8 *buf;
+
+	if (!data)
+		return -ENXIO;
+
+	if (ibi_notify) {
+		buf = (u8 *)ibi_notify->data;
+		init_completion(&master->sir_complete);
+
+		reg = readl(master->regs + DEVICE_CTRL);
+		reg &= ~DEV_CTRL_SLAVE_MDB;
+		reg |= FIELD_PREP(DEV_CTRL_SLAVE_MDB, buf[0]) |
+		       FIELD_PREP(DEV_CTRL_SLAVE_PEC_EN, 1);
+		writel(reg, master->regs + DEVICE_CTRL);
+
+		aspeed_i3c_master_wr_tx_fifo(master, buf, ibi_notify->len);
+
+		reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, ibi_notify->len);
+		writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+		thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+		thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+		thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+		writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+	}
+
+	buf = (u8 *)data->data;
+	aspeed_i3c_master_wr_tx_fifo(master, buf, data->len);
+
+	reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, data->len);
+	writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+	if (ibi_notify) {
+		writel(1, master->regs + SLV_INTR_REQ);
+		if (!wait_for_completion_timeout(&master->sir_complete,
+						 XFER_TIMEOUT)) {
+			dev_err(master->dev, "send sir timeout\n");
+			writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		}
+
+		reg = readl(master->regs + DEVICE_CTRL);
+		reg &= ~DEV_CTRL_SLAVE_PEC_EN;
+		writel(reg, master->regs + DEVICE_CTRL);
+	}
+
+	return 0;
+}
+
+static int aspeed_i3c_master_timing_config(struct aspeed_i3c_master *master,
+					   struct device_node *np)
+{
+	u32 val, reg;
+	u32 timed_reset_scl_low_ns;
+	u32 sda_tx_hold_ns;
+
+	master->timing.core_rate = clk_get_rate(master->core_clk);
+	if (!master->timing.core_rate) {
+		dev_err(master->dev, "core clock rate not found\n");
+		return -EINVAL;
+	}
+
+	/* core_period is in nanosecond */
+	master->timing.core_period =
+		DIV_ROUND_UP(1000000000, master->timing.core_rate);
+
+	/* setup default timing configuration */
+	sda_tx_hold_ns = SDA_TX_HOLD_MIN * master->timing.core_period;
+	timed_reset_scl_low_ns = JESD403_TIMED_RESET_NS_DEF;
+
+	/* parse configurations from DT */
+	if (!of_property_read_u32(np, "i3c-pp-scl-hi-period-ns", &val))
+		master->timing.i3c_pp_scl_high = val;
+
+	if (!of_property_read_u32(np, "i3c-pp-scl-lo-period-ns", &val))
+		master->timing.i3c_pp_scl_low = val;
+
+	if (!of_property_read_u32(np, "i3c-od-scl-hi-period-ns", &val))
+		master->timing.i3c_od_scl_high = val;
+
+	if (!of_property_read_u32(np, "i3c-od-scl-lo-period-ns", &val))
+		master->timing.i3c_od_scl_low = val;
+
+	if (!of_property_read_u32(np, "sda-tx-hold-ns", &val))
+		sda_tx_hold_ns = val;
+
+	if (!of_property_read_u32(np, "timed-reset-scl-low-ns", &val))
+		timed_reset_scl_low_ns = val;
+
+	val = clamp((u32)DIV_ROUND_CLOSEST(sda_tx_hold_ns,
+					   master->timing.core_period),
+		    (u32)SDA_TX_HOLD_MIN, (u32)SDA_TX_HOLD_MAX);
+	reg = readl(master->regs + SDA_HOLD_SWITCH_DLY_TIMING);
+	reg &= ~SDA_TX_HOLD;
+	reg |= FIELD_PREP(SDA_TX_HOLD, val);
+	writel(reg, master->regs + SDA_HOLD_SWITCH_DLY_TIMING);
+
+	val = DIV_ROUND_CLOSEST(timed_reset_scl_low_ns,
+				master->timing.core_period);
+	writel(val, master->regs + SCL_LOW_MST_EXT_TIMEOUT);
+
+	return 0;
+}
+
+static const struct i3c_master_controller_ops aspeed_i3c_ops = {
+	.bus_init = aspeed_i3c_master_bus_init,
+	.bus_cleanup = aspeed_i3c_master_bus_cleanup,
+	.bus_reset = aspeed_i3c_master_bus_reset,
+	.attach_i3c_dev = aspeed_i3c_master_attach_i3c_dev,
+	.reattach_i3c_dev = aspeed_i3c_master_reattach_i3c_dev,
+	.detach_i3c_dev = aspeed_i3c_master_detach_i3c_dev,
+	.do_daa = aspeed_i3c_master_daa,
+	.supports_ccc_cmd = aspeed_i3c_master_supports_ccc_cmd,
+	.send_ccc_cmd = aspeed_i3c_master_send_ccc_cmd,
+	.priv_xfers = aspeed_i3c_master_priv_xfers,
+	.attach_i2c_dev = aspeed_i3c_master_attach_i2c_dev,
+	.detach_i2c_dev = aspeed_i3c_master_detach_i2c_dev,
+	.i2c_xfers = aspeed_i3c_master_i2c_xfers,
+	.enable_ibi = aspeed_i3c_master_enable_ibi,
+	.disable_ibi = aspeed_i3c_master_disable_ibi,
+	.request_ibi = aspeed_i3c_master_request_ibi,
+	.free_ibi = aspeed_i3c_master_free_ibi,
+	.recycle_ibi_slot = aspeed_i3c_master_recycle_ibi_slot,
+	.register_slave = aspeed_i3c_master_register_slave,
+	.unregister_slave = aspeed_i3c_master_unregister_slave,
+	.send_sir = aspeed_i3c_master_send_sir,
+	.put_read_data = aspeed_i3c_master_put_read_data,
+};
+
+static void aspeed_i3c_master_hj(struct work_struct *work)
+{
+	struct aspeed_i3c_master *master =
+		container_of(work, typeof(*master), hj_work);
+
+	i3c_master_do_daa(&master->base);
+}
+
+static int aspeed_i3c_master_enable_hj(struct aspeed_i3c_master *master)
+{
+	int ret;
+
+	aspeed_i3c_master_enable_ibi_irq(master);
+	ast_clrbits(master->regs + DEVICE_CTRL, DEV_CTRL_HOT_JOIN_NACK);
+	ret = i3c_master_enable_hj(&master->base);
+
+	return ret;
+}
+
+static int aspeed_i3c_probe(struct platform_device *pdev)
+{
+	struct aspeed_i3c_master *master;
+	struct device_node *np;
+	int ret, irq;
+
+	master = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);
+	if (!master)
+		return -ENOMEM;
+
+	master->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(master->regs))
+		return PTR_ERR(master->regs);
+
+	master->core_clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(master->core_clk))
+		return PTR_ERR(master->core_clk);
+
+	master->core_rst = devm_reset_control_get_optional_exclusive(&pdev->dev,
+								    "core_rst");
+	if (IS_ERR(master->core_rst))
+		return PTR_ERR(master->core_rst);
+
+	ret = clk_prepare_enable(master->core_clk);
+	if (ret)
+		goto err_disable_core_clk;
+
+	reset_control_deassert(master->core_rst);
+
+	spin_lock_init(&master->ibi.lock);
+	spin_lock_init(&master->xferqueue.lock);
+	INIT_LIST_HEAD(&master->xferqueue.list);
+
+	writel(RESET_CTRL_ALL, master->regs + RESET_CTRL);
+	while (readl(master->regs + RESET_CTRL))
+		;
+
+	writel(INTR_ALL, master->regs + INTR_STATUS);
+	irq = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(&pdev->dev, irq,
+			       aspeed_i3c_master_irq_handler, 0,
+			       dev_name(&pdev->dev), master);
+	if (ret)
+		goto err_assert_rst;
+
+	platform_set_drvdata(pdev, master);
+
+	np = pdev->dev.of_node;
+	if (of_get_property(np, "secondary", NULL))
+		master->secondary = true;
+	else
+		master->secondary = false;
+
+	ret = aspeed_i3c_master_timing_config(master, np);
+	if (ret)
+		goto err_assert_rst;
+
+	/* Information regarding the FIFOs/QUEUEs depth */
+	ret = readl(master->regs + QUEUE_STATUS_LEVEL);
+	master->caps.cmdfifodepth = QUEUE_STATUS_LEVEL_CMD(ret);
+
+	ret = readl(master->regs + DATA_BUFFER_STATUS_LEVEL);
+	master->caps.datafifodepth = DATA_BUFFER_STATUS_LEVEL_TX(ret);
+
+	ret = readl(master->regs + DEVICE_ADDR_TABLE_POINTER);
+	master->datstartaddr = ret;
+	master->maxdevs = ret >> 16;
+	master->free_pos = GENMASK(master->maxdevs - 1, 0);
+	aspeed_i3c_master_init_group_dat(master);
+#ifdef CONFIG_AST2600_I3C_CCC_WORKAROUND
+	master->free_pos &= ~BIT(master->maxdevs - 1);
+	ret = (even_parity(I3C_BROADCAST_ADDR) << 7) | I3C_BROADCAST_ADDR;
+	master->addrs[master->maxdevs - 1] = ret;
+	writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(ret),
+	       master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, master->maxdevs - 1));
+#endif
+	master->dev = &pdev->dev;
+	master->base.pec_supported = true;
+	INIT_WORK(&master->hj_work, aspeed_i3c_master_hj);
+	ret = i3c_master_register(&master->base, &pdev->dev,
+				  &aspeed_i3c_ops, master->secondary);
+	if (ret)
+		goto err_assert_rst;
+
+	ret = aspeed_i3c_master_enable_hj(master);
+	if (ret)
+		goto err_master_register;
+
+	return 0;
+
+err_master_register:
+	i3c_master_unregister(&master->base);
+
+err_assert_rst:
+	reset_control_assert(master->core_rst);
+
+err_disable_core_clk:
+	clk_disable_unprepare(master->core_clk);
+
+	return ret;
+}
+
+static int aspeed_i3c_remove(struct platform_device *pdev)
+{
+	struct aspeed_i3c_master *master = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = i3c_master_unregister(&master->base);
+	if (ret)
+		return ret;
+
+	reset_control_assert(master->core_rst);
+
+	clk_disable_unprepare(master->core_clk);
+
+	return 0;
+}
+
+static const struct of_device_id aspeed_i3c_master_of_match[] = {
+	{ .compatible = "aspeed,ast2600-i3c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, aspeed_i3c_master_of_match);
+
+static struct platform_driver aspeed_i3c_driver = {
+	.probe = aspeed_i3c_probe,
+	.remove = aspeed_i3c_remove,
+	.driver = {
+		.name = "ast2600-i3c-master",
+		.of_match_table = of_match_ptr(aspeed_i3c_master_of_match),
+	},
+};
+module_platform_driver(aspeed_i3c_driver);
+
+MODULE_AUTHOR("Dylan Hung <dylan_hung@aspeedtech.com>");
+MODULE_DESCRIPTION("Aspeed MIPI I3C driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i3c/master/mipi-i3c-hci/core.c b/drivers/i3c/master/mipi-i3c-hci/core.c
index 1b73647cc3b1..6aef5ce43cc1 100644
--- a/drivers/i3c/master/mipi-i3c-hci/core.c
+++ b/drivers/i3c/master/mipi-i3c-hci/core.c
@@ -662,7 +662,7 @@ static int i3c_hci_init(struct i3c_hci *hci)
 
 	/* Make sure our data ordering fits the host's */
 	regval = reg_read(HC_CONTROL);
-	if (IS_ENABLED(CONFIG_BIG_ENDIAN)) {
+	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)) {
 		if (!(regval & HC_CONTROL_DATA_BIG_ENDIAN)) {
 			regval |= HC_CONTROL_DATA_BIG_ENDIAN;
 			reg_write(HC_CONTROL, regval);
@@ -768,13 +768,8 @@ static int i3c_hci_probe(struct platform_device *pdev)
 static int i3c_hci_remove(struct platform_device *pdev)
 {
 	struct i3c_hci *hci = platform_get_drvdata(pdev);
-	int ret;
 
-	ret = i3c_master_unregister(&hci->master);
-	if (ret)
-		return ret;
-
-	return 0;
+	return i3c_master_unregister(&hci->master);
 }
 
 static const __maybe_unused struct of_device_id i3c_hci_of_match[] = {
diff --git a/drivers/i3c/master/mipi-i3c-hci/dma.c b/drivers/i3c/master/mipi-i3c-hci/dma.c
index af873a9be050..2990ac9eaade 100644
--- a/drivers/i3c/master/mipi-i3c-hci/dma.c
+++ b/drivers/i3c/master/mipi-i3c-hci/dma.c
@@ -223,7 +223,7 @@ static int hci_dma_init(struct i3c_hci *hci)
 	}
 	if (nr_rings > XFER_RINGS)
 		nr_rings = XFER_RINGS;
-	rings = kzalloc(sizeof(*rings) + nr_rings * sizeof(*rh), GFP_KERNEL);
+	rings = kzalloc(struct_size(rings, headers, nr_rings), GFP_KERNEL);
 	if (!rings)
 		return -ENOMEM;
 	hci->io_data = rings;
diff --git a/drivers/i3c/master/mipi-i3c-hci/hci.h b/drivers/i3c/master/mipi-i3c-hci/hci.h
index 80beb1d5be8f..f109923f6c3f 100644
--- a/drivers/i3c/master/mipi-i3c-hci/hci.h
+++ b/drivers/i3c/master/mipi-i3c-hci/hci.h
@@ -98,7 +98,7 @@ struct hci_xfer {
 
 static inline struct hci_xfer *hci_alloc_xfer(unsigned int n)
 {
-	return kzalloc(sizeof(struct hci_xfer) * n, GFP_KERNEL);
+	return kcalloc(n, sizeof(struct hci_xfer), GFP_KERNEL);
 }
 
 static inline void hci_free_xfer(struct hci_xfer *xfer, unsigned int n)
diff --git a/drivers/i3c/mctp/Kconfig b/drivers/i3c/mctp/Kconfig
new file mode 100644
index 000000000000..fe635940138b
--- /dev/null
+++ b/drivers/i3c/mctp/Kconfig
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config I3C_MCTP
+    tristate "I3C Controller MCTP driver"
+    depends on I3C
+help
+    Say yes here to enable the I3C MCTP driver for I3C HW that is
+    configured as an I3C Controller Device on the I3C Bus.
+
+config I3C_TARGET_MCTP
+    tristate "I3C Target MCTP driver"
+    depends on I3C
+help
+    Say yes here to enable the I3C MCTP driver for I3C HW that is
+    configured as an I3C Target Device on the I3C Bus.
diff --git a/drivers/i3c/mctp/Makefile b/drivers/i3c/mctp/Makefile
new file mode 100644
index 000000000000..05eb78684843
--- /dev/null
+++ b/drivers/i3c/mctp/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_I3C_MCTP)		+= i3c-mctp.o
+obj-$(CONFIG_I3C_TARGET_MCTP)	+= i3c-target-mctp.o
diff --git a/drivers/i3c/mctp/i3c-mctp.c b/drivers/i3c/mctp/i3c-mctp.c
new file mode 100644
index 000000000000..9e368892da34
--- /dev/null
+++ b/drivers/i3c/mctp/i3c-mctp.c
@@ -0,0 +1,627 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2022 Intel Corporation.*/
+
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/preempt.h>
+#include <linux/ptr_ring.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+#include <linux/i3c/device.h>
+
+#include <linux/i3c/mctp/i3c-mctp.h>
+
+#define I3C_MCTP_MINORS				32
+#define CCC_DEVICE_STATUS_PENDING_INTR(x)	(((x) & GENMASK(3, 0)) >> 0)
+#define POLLING_TIMEOUT_MS			50
+#define MCTP_INTERRUPT_NUMBER			1
+#define RX_RING_COUNT				16
+#define I3C_MCTP_MIN_TRANSFER_SIZE		69
+#define I3C_MCTP_IBI_PAYLOAD_SIZE		2
+
+struct i3c_mctp {
+	struct i3c_device *i3c;
+	struct cdev cdev;
+	struct device *dev;
+	struct delayed_work polling_work;
+	struct platform_device *i3c_peci;
+	int id;
+	/*
+	 * Restrict an access to the /dev descriptor to one
+	 * user at a time.
+	 */
+	spinlock_t device_file_lock;
+	int device_open;
+	/* Currently only one userspace client is supported */
+	struct i3c_mctp_client *default_client;
+	struct i3c_mctp_client *peci_client;
+	u16 max_read_len;
+	u16 max_write_len;
+};
+
+struct i3c_mctp_client {
+	struct i3c_mctp *priv;
+	struct ptr_ring rx_queue;
+	wait_queue_head_t wait_queue;
+};
+
+static struct class *i3c_mctp_class;
+static dev_t i3c_mctp_devt;
+static DEFINE_IDA(i3c_mctp_ida);
+
+static struct kmem_cache *packet_cache;
+
+/**
+ * i3c_mctp_packet_alloc() - allocates i3c_mctp_packet
+ *
+ * @flags: the type of memory to allocate
+ *
+ * Allocates i3c_mctp_packet via slab allocation
+ * Return: pointer to the packet, NULL if some error occurred
+ */
+void *i3c_mctp_packet_alloc(gfp_t flags)
+{
+	return kmem_cache_alloc(packet_cache, flags);
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_packet_alloc);
+
+/**
+ * i3c_mctp_packet_free() - frees i3c_mctp_packet
+ *
+ * @packet: pointer to the packet which should be freed
+ *
+ * Frees i3c_mctp_packet previously allocated via slab allocation
+ */
+void i3c_mctp_packet_free(void *packet)
+{
+	kmem_cache_free(packet_cache, packet);
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_packet_free);
+
+static void i3c_mctp_client_free(struct i3c_mctp_client *client)
+{
+	ptr_ring_cleanup(&client->rx_queue, &i3c_mctp_packet_free);
+
+	kfree(client);
+}
+
+static struct i3c_mctp_client *i3c_mctp_client_alloc(struct i3c_mctp *priv)
+{
+	struct i3c_mctp_client *client;
+	int ret;
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		goto out;
+
+	client->priv = priv;
+	ret = ptr_ring_init(&client->rx_queue, RX_RING_COUNT, GFP_KERNEL);
+	if (ret)
+		return ERR_PTR(ret);
+	init_waitqueue_head(&client->wait_queue);
+out:
+	return client;
+}
+
+static struct i3c_mctp_client *i3c_mctp_find_client(struct i3c_mctp *priv,
+						    struct i3c_mctp_packet *packet)
+{
+	u8 *msg_hdr = (u8 *)packet->data.payload;
+	u8 mctp_type = msg_hdr[MCTP_MSG_HDR_MSG_TYPE_OFFSET];
+	u16 vendor = (msg_hdr[MCTP_MSG_HDR_VENDOR_OFFSET] << 8
+		      | msg_hdr[MCTP_MSG_HDR_VENDOR_OFFSET + 1]);
+	u8 intel_msg_op_code = msg_hdr[MCTP_MSG_HDR_OPCODE_OFFSET];
+
+	if (priv->peci_client && mctp_type == MCTP_MSG_TYPE_VDM_PCI &&
+	    vendor == MCTP_VDM_PCI_INTEL_VENDOR_ID && intel_msg_op_code == MCTP_VDM_PCI_INTEL_PECI)
+		return priv->peci_client;
+
+	return priv->default_client;
+}
+
+static struct i3c_mctp_packet *i3c_mctp_read_packet(struct i3c_device *i3c)
+{
+	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3c));
+	struct i3c_mctp_packet *rx_packet;
+	struct i3c_priv_xfer xfers = {
+		.rnw = true,
+	};
+	int ret;
+
+	rx_packet = i3c_mctp_packet_alloc(GFP_KERNEL);
+	if (!rx_packet)
+		return ERR_PTR(-ENOMEM);
+
+	rx_packet->size = I3C_MCTP_PACKET_SIZE;
+	xfers.len = rx_packet->size;
+	xfers.data.in = &rx_packet->data;
+
+	/* Check against packet size + PEC byte to make sure that we always try to read max */
+	if (priv->max_read_len != xfers.len + 1) {
+		dev_dbg(i3cdev_to_dev(i3c), "Length mismatch. MRL = %d, xfers.len = %d",
+			priv->max_read_len, xfers.len);
+		i3c_mctp_packet_free(rx_packet);
+		return ERR_PTR(-EINVAL);
+	}
+
+	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
+	if (ret) {
+		i3c_mctp_packet_free(rx_packet);
+		return ERR_PTR(ret);
+	}
+	rx_packet->size = xfers.len;
+
+	return rx_packet;
+}
+
+static void i3c_mctp_dispatch_packet(struct i3c_mctp *priv, struct i3c_mctp_packet *packet)
+{
+	struct i3c_mctp_client *client = i3c_mctp_find_client(priv, packet);
+	int ret;
+
+	ret = ptr_ring_produce(&client->rx_queue, packet);
+	if (ret)
+		i3c_mctp_packet_free(packet);
+	else
+		wake_up_all(&client->wait_queue);
+}
+
+static void i3c_mctp_polling_work(struct work_struct *work)
+{
+	struct i3c_mctp *priv = container_of(to_delayed_work(work), struct i3c_mctp, polling_work);
+	struct i3c_device *i3cdev = priv->i3c;
+	struct i3c_mctp_packet *rx_packet;
+	struct i3c_device_info info;
+	int ret;
+
+	i3c_device_get_info(i3cdev, &info);
+	ret = i3c_device_getstatus_ccc(i3cdev, &info);
+	if (ret)
+		return;
+
+	if (CCC_DEVICE_STATUS_PENDING_INTR(info.status) != MCTP_INTERRUPT_NUMBER)
+		return;
+
+	rx_packet = i3c_mctp_read_packet(i3cdev);
+	if (IS_ERR(rx_packet))
+		goto out;
+
+	i3c_mctp_dispatch_packet(priv, rx_packet);
+out:
+	schedule_delayed_work(&priv->polling_work, msecs_to_jiffies(POLLING_TIMEOUT_MS));
+}
+
+static ssize_t i3c_mctp_write(struct file *file, const char __user *buf, size_t count,
+			      loff_t *f_pos)
+{
+	struct i3c_mctp *priv = file->private_data;
+	struct i3c_device *i3c = priv->i3c;
+	struct i3c_priv_xfer xfers = {
+		.rnw = false,
+		.len = count,
+	};
+	u8 *data;
+	int ret;
+
+	/*
+	 * Check against packet size + PEC byte
+	 * to not send more data than it was set in the probe
+	 */
+	if (priv->max_write_len < xfers.len + 1) {
+		dev_dbg(i3cdev_to_dev(i3c), "Length mismatch. MWL = %d, xfers.len = %d",
+			priv->max_write_len, xfers.len);
+		return -EINVAL;
+	}
+
+	data = memdup_user(buf, count);
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	xfers.data.out = data;
+
+	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
+	kfree(data);
+	return ret ?: count;
+}
+
+static ssize_t i3c_mctp_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct i3c_mctp *priv = file->private_data;
+	struct i3c_mctp_client *client = priv->default_client;
+	struct i3c_mctp_packet *rx_packet;
+
+	if (count > sizeof(rx_packet->data))
+		count = sizeof(rx_packet->data);
+
+	rx_packet = ptr_ring_consume(&client->rx_queue);
+	if (!rx_packet)
+		return -EAGAIN;
+
+	if (count > rx_packet->size)
+		count = rx_packet->size;
+
+	if (copy_to_user(buf, &rx_packet->data, count))
+		return -EFAULT;
+
+	i3c_mctp_packet_free(rx_packet);
+
+	return count;
+}
+
+static int i3c_mctp_open(struct inode *inode, struct file *file)
+{
+	struct i3c_mctp *priv = container_of(inode->i_cdev, struct i3c_mctp, cdev);
+
+	spin_lock(&priv->device_file_lock);
+	if (priv->device_open) {
+		spin_unlock(&priv->device_file_lock);
+		return -EBUSY;
+	}
+	priv->device_open++;
+	spin_unlock(&priv->device_file_lock);
+
+	file->private_data = priv;
+
+	return 0;
+}
+
+static int i3c_mctp_release(struct inode *inode, struct file *file)
+{
+	struct i3c_mctp *priv = file->private_data;
+
+	spin_lock(&priv->device_file_lock);
+	priv->device_open--;
+	spin_unlock(&priv->device_file_lock);
+
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static __poll_t i3c_mctp_poll(struct file *file, struct poll_table_struct *pt)
+{
+	struct i3c_mctp *priv = file->private_data;
+	__poll_t ret = 0;
+
+	poll_wait(file, &priv->default_client->wait_queue, pt);
+
+	if (__ptr_ring_peek(&priv->default_client->rx_queue))
+		ret |= EPOLLIN;
+
+	return ret;
+}
+
+static const struct file_operations i3c_mctp_fops = {
+	.owner = THIS_MODULE,
+	.read = i3c_mctp_read,
+	.write = i3c_mctp_write,
+	.poll = i3c_mctp_poll,
+	.open = i3c_mctp_open,
+	.release = i3c_mctp_release,
+};
+
+/**
+ * i3c_mctp_add_peci_client() - registers PECI client
+ * @i3c: I3C device to get the PECI client for
+ *
+ * Return: pointer to PECI client, -ENOMEM - in case of client alloc fault
+ */
+struct i3c_mctp_client *i3c_mctp_add_peci_client(struct i3c_device *i3c)
+{
+	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3c));
+	struct i3c_mctp_client *client;
+
+	client = i3c_mctp_client_alloc(priv);
+	if (IS_ERR(client))
+		return ERR_PTR(-ENOMEM);
+
+	priv->peci_client = client;
+
+	return priv->peci_client;
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_add_peci_client);
+
+/**
+ * i3c_mctp_remove_peci_client() - un-registers PECI client
+ * @client: i3c_mctp_client to be freed
+ */
+void i3c_mctp_remove_peci_client(struct i3c_mctp_client *client)
+{
+	struct i3c_mctp *priv = client->priv;
+
+	i3c_mctp_client_free(priv->peci_client);
+
+	priv->peci_client = NULL;
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_remove_peci_client);
+
+static struct i3c_mctp *i3c_mctp_alloc(struct i3c_device *i3c)
+{
+	struct i3c_mctp *priv;
+	int id;
+
+	priv = devm_kzalloc(i3cdev_to_dev(i3c), sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return ERR_PTR(-ENOMEM);
+
+	id = ida_alloc(&i3c_mctp_ida, GFP_KERNEL);
+	if (id < 0) {
+		pr_err("i3c_mctp: no minor number available!\n");
+		return ERR_PTR(id);
+	}
+
+	priv->id = id;
+	priv->i3c = i3c;
+
+	spin_lock_init(&priv->device_file_lock);
+
+	return priv;
+}
+
+static void i3c_mctp_ibi_handler(struct i3c_device *dev, const struct i3c_ibi_payload *payload)
+{
+	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(dev));
+	struct i3c_mctp_packet *rx_packet;
+
+	rx_packet = i3c_mctp_read_packet(dev);
+	if (IS_ERR(rx_packet))
+		return;
+
+	i3c_mctp_dispatch_packet(priv, rx_packet);
+}
+
+static int i3c_mctp_init(struct i3c_driver *drv)
+{
+	int ret;
+
+	packet_cache = kmem_cache_create_usercopy("mctp-i3c-packet",
+						  sizeof(struct i3c_mctp_packet), 0, 0, 0,
+						  sizeof(struct i3c_mctp_packet), NULL);
+	if (IS_ERR(packet_cache)) {
+		ret = PTR_ERR(packet_cache);
+		goto out;
+	}
+
+	/* Dynamically request unused major number */
+	ret = alloc_chrdev_region(&i3c_mctp_devt, 0, I3C_MCTP_MINORS, "i3c-mctp");
+	if (ret)
+		goto out;
+
+	/* Create a class to populate sysfs entries*/
+	i3c_mctp_class = class_create(THIS_MODULE, "i3c-mctp");
+	if (IS_ERR(i3c_mctp_class)) {
+		ret = PTR_ERR(i3c_mctp_class);
+		goto out_unreg_chrdev;
+	}
+
+	i3c_driver_register(drv);
+
+	return 0;
+
+out_unreg_chrdev:
+	unregister_chrdev_region(i3c_mctp_devt, I3C_MCTP_MINORS);
+out:
+	pr_err("i3c_mctp: driver initialisation failed\n");
+	return ret;
+}
+
+static void i3c_mctp_free(struct i3c_driver *drv)
+{
+	i3c_driver_unregister(drv);
+	class_destroy(i3c_mctp_class);
+	unregister_chrdev_region(i3c_mctp_devt, I3C_MCTP_MINORS);
+	kmem_cache_destroy(packet_cache);
+}
+
+static int i3c_mctp_enable_ibi(struct i3c_device *i3cdev)
+{
+	struct i3c_ibi_setup ibireq = {
+		.handler = i3c_mctp_ibi_handler,
+		.max_payload_len = 2,
+		.num_slots = 10,
+	};
+	int ret;
+
+	ret = i3c_device_request_ibi(i3cdev, &ibireq);
+	if (ret)
+		return ret;
+	ret = i3c_device_enable_ibi(i3cdev);
+	if (ret)
+		i3c_device_free_ibi(i3cdev);
+
+	return ret;
+}
+
+/**
+ * i3c_mctp_get_eid() - receive MCTP EID assigned to the device
+ *
+ * @client: client for the device to get the EID for
+ * @domain_id: requested domain ID
+ * @eid: pointer to store EID value
+ *
+ * Receive MCTP endpoint ID dynamically assigned by the MCTP Bus Owner
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_mctp_get_eid(struct i3c_mctp_client *client, u8 domain_id, u8 *eid)
+{
+	/* TODO: Implement EID assignment basing on domain ID */
+	*eid = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_get_eid);
+
+/**
+ * i3c_mctp_send_packet() - send mctp packet
+ *
+ * @tx_packet: the allocated packet that needs to be send via I3C
+ * @i3c: i3c device to send the packet to
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_mctp_send_packet(struct i3c_device *i3c, struct i3c_mctp_packet *tx_packet)
+{
+	struct i3c_priv_xfer xfers = {
+		.rnw = false,
+		.len = tx_packet->size,
+		.data.out = &tx_packet->data,
+	};
+
+	return i3c_device_do_priv_xfers(i3c, &xfers, 1);
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_send_packet);
+
+/**
+ * i3c_mctp_receive_packet() - receive mctp packet
+ *
+ * @client: i3c_mctp_client to receive the packet from
+ * @timeout: timeout, in jiffies
+ *
+ * The function will sleep for up to @timeout if no packet is ready to read.
+ *
+ * Returns struct i3c_mctp_packet from or ERR_PTR in case of error or the
+ * timeout elapsed.
+ */
+struct i3c_mctp_packet *i3c_mctp_receive_packet(struct i3c_mctp_client *client,
+						unsigned long timeout)
+{
+	struct i3c_mctp_packet *rx_packet;
+	int ret;
+
+	ret = wait_event_interruptible_timeout(client->wait_queue,
+					       __ptr_ring_peek(&client->rx_queue), timeout);
+	if (ret < 0)
+		return ERR_PTR(ret);
+	else if (ret == 0)
+		return ERR_PTR(-ETIME);
+
+	rx_packet = ptr_ring_consume(&client->rx_queue);
+	if (!rx_packet)
+		return ERR_PTR(-EAGAIN);
+
+	return rx_packet;
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_receive_packet);
+
+static int i3c_mctp_probe(struct i3c_device *i3cdev)
+{
+	int ibi_payload_size = I3C_MCTP_IBI_PAYLOAD_SIZE;
+	struct device *dev = i3cdev_to_dev(i3cdev);
+	struct i3c_device_info info;
+	struct i3c_mctp *priv;
+	int ret;
+
+	priv = i3c_mctp_alloc(i3cdev);
+	if (IS_ERR(priv))
+		return PTR_ERR(priv);
+
+	cdev_init(&priv->cdev, &i3c_mctp_fops);
+
+	priv->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&priv->cdev, MKDEV(MAJOR(i3c_mctp_devt), priv->id), 1);
+	if (ret)
+		goto error_cdev;
+
+	/* register this i3c device with the driver core */
+	priv->dev = device_create(i3c_mctp_class, dev,
+				  MKDEV(MAJOR(i3c_mctp_devt), priv->id),
+				  NULL, "i3c-mctp-%d", priv->id);
+	if (IS_ERR(priv->dev)) {
+		ret = PTR_ERR(priv->dev);
+		goto error;
+	}
+
+	ret = i3c_device_control_pec(i3cdev, true);
+	if (ret)
+		goto error;
+
+	priv->default_client = i3c_mctp_client_alloc(priv);
+	if (IS_ERR(priv->default_client))
+		goto error;
+
+	dev_set_drvdata(i3cdev_to_dev(i3cdev), priv);
+
+	priv->i3c_peci = platform_device_register_data(i3cdev_to_dev(i3cdev), "peci-i3c", priv->id,
+						       NULL, 0);
+	if (IS_ERR(priv->i3c_peci))
+		dev_warn(priv->dev, "failed to register peci-i3c device\n");
+
+	if (i3c_mctp_enable_ibi(i3cdev)) {
+		INIT_DELAYED_WORK(&priv->polling_work, i3c_mctp_polling_work);
+		schedule_delayed_work(&priv->polling_work, msecs_to_jiffies(POLLING_TIMEOUT_MS));
+		ibi_payload_size = 0;
+	}
+
+	i3c_device_get_info(i3cdev, &info);
+
+	ret = i3c_device_getmrl_ccc(i3cdev, &info);
+	if (ret || info.max_read_len != I3C_MCTP_MIN_TRANSFER_SIZE)
+		ret = i3c_device_setmrl_ccc(i3cdev, &info, I3C_MCTP_MIN_TRANSFER_SIZE,
+					    ibi_payload_size);
+	if (ret && info.max_read_len != I3C_MCTP_MIN_TRANSFER_SIZE) {
+		dev_err(dev, "Failed to set MRL!, ret = %d\n", ret);
+		goto error_peci;
+	}
+	priv->max_read_len = info.max_read_len;
+
+	ret = i3c_device_getmwl_ccc(i3cdev, &info);
+	if (ret || info.max_write_len != I3C_MCTP_MIN_TRANSFER_SIZE)
+		ret = i3c_device_setmwl_ccc(i3cdev, &info, I3C_MCTP_MIN_TRANSFER_SIZE);
+	if (ret && info.max_write_len != I3C_MCTP_MIN_TRANSFER_SIZE) {
+		dev_err(dev, "Failed to set MWL!, ret = %d\n", ret);
+		goto error_peci;
+	}
+	priv->max_write_len = info.max_write_len;
+
+	return 0;
+
+error_peci:
+	platform_device_unregister(priv->i3c_peci);
+	i3c_device_disable_ibi(i3cdev);
+	i3c_device_free_ibi(i3cdev);
+error:
+	cdev_del(&priv->cdev);
+error_cdev:
+	put_device(dev);
+	return ret;
+}
+
+static void i3c_mctp_remove(struct i3c_device *i3cdev)
+{
+	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+
+	i3c_device_disable_ibi(i3cdev);
+	i3c_device_free_ibi(i3cdev);
+	i3c_mctp_client_free(priv->default_client);
+	priv->default_client = NULL;
+	platform_device_unregister(priv->i3c_peci);
+
+	device_destroy(i3c_mctp_class, MKDEV(MAJOR(i3c_mctp_devt), priv->id));
+	cdev_del(&priv->cdev);
+	ida_free(&i3c_mctp_ida, priv->id);
+}
+
+static const struct i3c_device_id i3c_mctp_ids[] = {
+	I3C_CLASS(0xCC, 0x0),
+	I3C_DEVICE(0x3f6, 0x8000, (void *)0),
+	I3C_DEVICE(0x3f6, 0x8001, (void *)0),
+	I3C_DEVICE(0x3f6, 0xA001, (void *)0),
+	{ },
+};
+
+static struct i3c_driver i3c_mctp_drv = {
+	.driver.name = "i3c-mctp",
+	.id_table = i3c_mctp_ids,
+	.probe = i3c_mctp_probe,
+	.remove = i3c_mctp_remove,
+};
+
+module_driver(i3c_mctp_drv, i3c_mctp_init, i3c_mctp_free);
+MODULE_AUTHOR("Oleksandr Shulzhenko <oleksandr.shulzhenko.viktorovych@intel.com>");
+MODULE_DESCRIPTION("I3C MCTP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i3c/mctp/i3c-target-mctp.c b/drivers/i3c/mctp/i3c-target-mctp.c
new file mode 100644
index 000000000000..d8c767f967fe
--- /dev/null
+++ b/drivers/i3c/mctp/i3c-target-mctp.c
@@ -0,0 +1,389 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2022 Intel Corporation.*/
+
+#include <linux/cdev.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/ptr_ring.h>
+#include <linux/workqueue.h>
+
+#include <linux/i3c/device.h>
+
+#define I3C_TARGET_MCTP_MINORS	32
+#define RX_RING_COUNT		16
+
+static struct class *i3c_target_mctp_class;
+static dev_t i3c_target_mctp_devt;
+static DEFINE_IDA(i3c_target_mctp_ida);
+
+struct mctp_client;
+
+struct i3c_target_mctp {
+	struct i3c_device *i3cdev;
+	struct cdev cdev;
+	int id;
+	struct mctp_client *client;
+	spinlock_t client_lock; /* to protect client access */
+};
+
+struct mctp_client {
+	struct kref ref;
+	struct i3c_target_mctp *priv;
+	struct ptr_ring rx_queue;
+	wait_queue_head_t wait_queue;
+};
+
+struct mctp_packet {
+	u8 *data;
+	u16 count;
+};
+
+static void *i3c_target_mctp_packet_alloc(u16 count)
+{
+	struct mctp_packet *packet;
+	u8 *data;
+
+	packet = kzalloc(sizeof(*packet), GFP_ATOMIC);
+	if (!packet)
+		return NULL;
+
+	data = kzalloc(count, GFP_ATOMIC);
+	if (!data) {
+		kfree(packet);
+		return NULL;
+	}
+
+	packet->data = data;
+	packet->count = count;
+
+	return packet;
+}
+
+static void i3c_target_mctp_packet_free(void *data)
+{
+	struct mctp_packet *packet = data;
+
+	kfree(packet->data);
+	kfree(packet);
+}
+
+static struct mctp_client *i3c_target_mctp_client_alloc(struct i3c_target_mctp *priv)
+{
+	struct mctp_client *client;
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		goto out;
+
+	kref_init(&client->ref);
+	client->priv = priv;
+	ptr_ring_init(&client->rx_queue, RX_RING_COUNT, GFP_KERNEL);
+out:
+	return client;
+}
+
+static void i3c_target_mctp_client_free(struct kref *ref)
+{
+	struct mctp_client *client = container_of(ref, typeof(*client), ref);
+
+	ptr_ring_cleanup(&client->rx_queue, &i3c_target_mctp_packet_free);
+
+	kfree(client);
+}
+
+static void i3c_target_mctp_client_get(struct mctp_client *client)
+{
+	kref_get(&client->ref);
+}
+
+static void i3c_target_mctp_client_put(struct mctp_client *client)
+{
+	kref_put(&client->ref, &i3c_target_mctp_client_free);
+}
+
+static void
+i3c_target_mctp_rx_packet_enqueue(struct i3c_device *i3cdev, const u8 *data, size_t count)
+{
+	struct i3c_target_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+	struct mctp_client *client;
+	struct mctp_packet *packet;
+	int ret;
+
+	spin_lock(&priv->client_lock);
+	client = priv->client;
+	if (client)
+		i3c_target_mctp_client_get(client);
+	spin_unlock(&priv->client_lock);
+
+	if (!client)
+		return;
+
+	packet = i3c_target_mctp_packet_alloc(count);
+	if (!packet)
+		goto err;
+
+	memcpy(packet->data, data, count);
+
+	ret = ptr_ring_produce(&client->rx_queue, packet);
+	if (ret)
+		i3c_target_mctp_packet_free(packet);
+	else
+		wake_up_all(&client->wait_queue);
+err:
+	i3c_target_mctp_client_put(client);
+}
+
+static struct mctp_client *i3c_target_mctp_create_client(struct i3c_target_mctp *priv)
+{
+	struct mctp_client *client;
+	int ret;
+
+	/* Currently, we support just one client. */
+	spin_lock_irq(&priv->client_lock);
+	ret = priv->client ? -EBUSY : 0;
+	spin_unlock_irq(&priv->client_lock);
+
+	if (ret)
+		return ERR_PTR(ret);
+
+	client = i3c_target_mctp_client_alloc(priv);
+	if (!client)
+		return ERR_PTR(-ENOMEM);
+
+	init_waitqueue_head(&client->wait_queue);
+
+	spin_lock_irq(&priv->client_lock);
+	priv->client = client;
+	spin_unlock_irq(&priv->client_lock);
+
+	return client;
+}
+
+static void i3c_target_mctp_delete_client(struct mctp_client *client)
+{
+	struct i3c_target_mctp *priv = client->priv;
+
+	spin_lock_irq(&priv->client_lock);
+	priv->client = NULL;
+	spin_unlock_irq(&priv->client_lock);
+
+	i3c_target_mctp_client_put(client);
+}
+
+static int i3c_target_mctp_open(struct inode *inode, struct file *file)
+{
+	struct i3c_target_mctp *priv = container_of(inode->i_cdev, struct i3c_target_mctp, cdev);
+	struct mctp_client *client;
+
+	client = i3c_target_mctp_create_client(priv);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	file->private_data = client;
+
+	return 0;
+}
+
+static int i3c_target_mctp_release(struct inode *inode, struct file *file)
+{
+	struct mctp_client *client = file->private_data;
+
+	i3c_target_mctp_delete_client(client);
+
+	return 0;
+}
+
+static ssize_t i3c_target_mctp_read(struct file *file, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	struct mctp_client *client = file->private_data;
+	struct mctp_packet *rx_packet;
+
+	rx_packet = ptr_ring_consume_irq(&client->rx_queue);
+	if (!rx_packet)
+		return -EAGAIN;
+
+	if (count < rx_packet->count) {
+		count = -EINVAL;
+		goto err_free;
+	}
+	if (count > rx_packet->count)
+		count = rx_packet->count;
+
+	if (copy_to_user(buf, rx_packet->data, count))
+		count = -EFAULT;
+err_free:
+	i3c_target_mctp_packet_free(rx_packet);
+
+	return count;
+}
+
+static ssize_t i3c_target_mctp_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	struct mctp_client *client = file->private_data;
+	struct i3c_target_mctp *priv = client->priv;
+	struct i3c_priv_xfer xfers[1] = {};
+	u8 *tx_data;
+	int ret;
+
+	tx_data = kzalloc(count, GFP_KERNEL);
+	if (!tx_data)
+		return -ENOMEM;
+
+	if (copy_from_user(tx_data, buf, count)) {
+		ret = -EFAULT;
+		goto out_packet;
+	}
+
+	xfers[0].data.out = tx_data;
+	xfers[0].len = count;
+
+	ret = i3c_device_do_priv_xfers(priv->i3cdev, xfers, ARRAY_SIZE(xfers));
+	if (ret)
+		goto out_packet;
+	ret = count;
+
+	/*
+	 * TODO: Add support for IBI generation - it should be done only if IBI
+	 * are enabled (the Active Controller may disabled them using CCC for
+	 * that). Otherwise (if IBIs are disabled), we should make sure that when
+	 * Active Controller issues GETSTATUS CCC the return value indicates
+	 * that data is ready.
+	 */
+out_packet:
+	kfree(tx_data);
+	return ret;
+}
+
+static __poll_t i3c_target_mctp_poll(struct file *file, struct poll_table_struct *pt)
+{
+	struct mctp_client *client = file->private_data;
+	__poll_t ret = 0;
+
+	poll_wait(file, &client->wait_queue, pt);
+
+	if (__ptr_ring_peek(&client->rx_queue))
+		ret |= EPOLLIN;
+
+	/*
+	 * TODO: Add support for "write" readiness.
+	 * DW-I3C has a hardware queue that has finite number of entries.
+	 * If we try to issue more writes that space in this queue allows for,
+	 * we're in trouble. This should be handled by error from write() and
+	 * poll() blocking for write events.
+	 */
+	return ret;
+}
+
+static const struct file_operations i3c_target_mctp_fops = {
+	.owner = THIS_MODULE,
+	.open = i3c_target_mctp_open,
+	.release = i3c_target_mctp_release,
+	.read = i3c_target_mctp_read,
+	.write = i3c_target_mctp_write,
+	.poll = i3c_target_mctp_poll,
+};
+
+static struct i3c_target_read_setup i3c_target_mctp_rx_packet_setup = {
+	.handler = i3c_target_mctp_rx_packet_enqueue,
+};
+
+static int i3c_target_mctp_probe(struct i3c_device *i3cdev)
+{
+	struct device *parent = i3cdev_to_dev(i3cdev);
+	struct i3c_target_mctp *priv;
+	struct device *dev;
+	int ret;
+
+	priv = devm_kzalloc(parent, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ret = ida_alloc(&i3c_target_mctp_ida, GFP_KERNEL);
+	if (ret < 0)
+		return ret;
+	priv->id = ret;
+
+	priv->i3cdev = i3cdev;
+	spin_lock_init(&priv->client_lock);
+
+	cdev_init(&priv->cdev, &i3c_target_mctp_fops);
+	priv->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&priv->cdev, i3c_target_mctp_devt, 1);
+	if (ret) {
+		ida_free(&i3c_target_mctp_ida, priv->id);
+		return ret;
+	}
+
+	dev = device_create(i3c_target_mctp_class, parent, i3c_target_mctp_devt,
+			    NULL, "i3c-mctp-target-%d", priv->id);
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		goto err;
+	}
+
+	i3cdev_set_drvdata(i3cdev, priv);
+
+	i3c_target_read_register(i3cdev, &i3c_target_mctp_rx_packet_setup);
+
+	return 0;
+err:
+	cdev_del(&priv->cdev);
+	ida_free(&i3c_target_mctp_ida, priv->id);
+
+	return ret;
+}
+
+static void i3c_target_mctp_remove(struct i3c_device *i3cdev)
+{
+	struct i3c_target_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+
+	device_destroy(i3c_target_mctp_class, i3c_target_mctp_devt);
+	cdev_del(&priv->cdev);
+	ida_free(&i3c_target_mctp_ida, priv->id);
+}
+
+static const struct i3c_device_id i3c_target_mctp_ids[] = {
+	I3C_CLASS(0xcc, 0x0),
+	{ },
+};
+
+static struct i3c_driver i3c_target_mctp_drv = {
+	.driver.name = "i3c-target-mctp",
+	.id_table = i3c_target_mctp_ids,
+	.probe = i3c_target_mctp_probe,
+	.remove = i3c_target_mctp_remove,
+	.target = true,
+};
+
+static int i3c_target_mctp_init(struct i3c_driver *drv)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&i3c_target_mctp_devt, 0,
+				  I3C_TARGET_MCTP_MINORS, "i3c-target-mctp");
+	if (ret)
+		return ret;
+
+	i3c_target_mctp_class = class_create(THIS_MODULE, "i3c-target-mctp");
+	if (IS_ERR(i3c_target_mctp_class)) {
+		unregister_chrdev_region(i3c_target_mctp_devt, I3C_TARGET_MCTP_MINORS);
+		return PTR_ERR(i3c_target_mctp_class);
+	}
+
+	return i3c_driver_register(drv);
+}
+
+static void i3c_target_mctp_fini(struct i3c_driver *drv)
+{
+	i3c_driver_unregister(drv);
+	class_destroy(i3c_target_mctp_class);
+	unregister_chrdev_region(i3c_target_mctp_devt, I3C_TARGET_MCTP_MINORS);
+}
+
+module_driver(i3c_target_mctp_drv, i3c_target_mctp_init, i3c_target_mctp_fini);
+MODULE_AUTHOR("Iwona Winiarska <iwona.winiarska@intel.com>");
+MODULE_DESCRIPTION("I3C Target MCTP driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i3c/ccc.h b/include/linux/i3c/ccc.h
index c531bae59380..0e078d2fd1ca 100644
--- a/include/linux/i3c/ccc.h
+++ b/include/linux/i3c/ccc.h
@@ -34,6 +34,7 @@
 #define I3C_CCC_ENTHDR(x)		I3C_CCC_ID(0x20 + (x), true)
 #define I3C_CCC_SETAASA			I3C_CCC_ID(0x29, true)
 #define I3C_CCC_SETHID			I3C_CCC_ID(0x61, true)
+#define I3C_CCC_DEVCTRL			I3C_CCC_ID(0x62, true)
 
 /* Unicast-only commands */
 #define I3C_CCC_SETDASA			I3C_CCC_ID(0x7, false)
@@ -380,6 +381,8 @@ struct i3c_ccc_cmd_dest {
  * @rnw: true if the CCC should retrieve data from the device. Only valid for
  *	 unicast commands
  * @id: CCC command id
+ * @dbp: true if the defining byte present
+ * @db: the defining byte
  * @ndests: number of destinations. Should always be one for broadcast commands
  * @dests: array of destinations and associated payload for this CCC. Most of
  *	   the time, only one destination is provided
@@ -388,6 +391,8 @@ struct i3c_ccc_cmd_dest {
 struct i3c_ccc_cmd {
 	u8 rnw;
 	u8 id;
+	u8 dbp;
+	u8 db;
 	unsigned int ndests;
 	struct i3c_ccc_cmd_dest *dests;
 	enum i3c_error_code err;
diff --git a/include/linux/i3c/device.h b/include/linux/i3c/device.h
index 8242e13e7b0b..c966b97caf1c 100644
--- a/include/linux/i3c/device.h
+++ b/include/linux/i3c/device.h
@@ -71,11 +71,26 @@ struct i3c_priv_xfer {
 /**
  * enum i3c_dcr - I3C DCR values
  * @I3C_DCR_GENERIC_DEVICE: generic I3C device
+ * @I3C_DCR_HUB: I3C HUB device
  */
 enum i3c_dcr {
 	I3C_DCR_GENERIC_DEVICE = 0,
+	I3C_DCR_HUB = 194,
+	I3C_DCR_JESD403_BEGIN = 208,
+	I3C_DCR_THERMAL_SENSOR_FIRST = 210,
+	I3C_DCR_THERMAL_SENSOR_SECOND = 214,
+	I3C_DCR_PMIC_SECOND = 216,
+	I3C_DCR_PMIC_FIRST = 217,
+	I3C_DCR_SPD_HUB = 218,
+	I3C_DCR_RCD = 219,
+	I3C_DCR_PMIC_THIRD = 220,
+	I3C_DCR_JESD403_END = 223,
+	I3C_DCR_MAX = 228,
 };
 
+#define I3C_DCR_IS_JESD403_COMPLIANT(dcr)                                      \
+	(dcr >= I3C_DCR_JESD403_BEGIN && dcr <= I3C_DCR_JESD403_END)
+
 #define I3C_PID_MANUF_ID(pid)		(((pid) & GENMASK_ULL(47, 33)) >> 33)
 #define I3C_PID_RND_LOWER_32BITS(pid)	(!!((pid) & BIT_ULL(32)))
 #define I3C_PID_RND_VAL(pid)		((pid) & GENMASK_ULL(31, 0))
@@ -93,6 +108,22 @@ enum i3c_dcr {
 #define I3C_BCR_IBI_REQ_CAP		BIT(1)
 #define I3C_BCR_MAX_DATA_SPEED_LIM	BIT(0)
 
+/*
+ * MIPI I3C MDB definition
+ * see https://www.mipi.org/MIPI_I3C_mandatory_data_byte_values_public
+ */
+#define IBI_MDB_ID(grp, id)                                                    \
+	((((grp) << 5) & GENMASK(7, 5)) | ((id)&GENMASK(4, 0)))
+#define IBI_MDB_GET_GRP(m) (((m)&GENMASK(7, 5)) >> 5)
+#define IBI_MDB_GET_ID(m) ((m)&GENMASK(4, 0))
+
+#define IBI_MDB_GRP_PENDING_READ_NOTIF 0x5
+#define IS_MDB_PENDING_READ_NOTIFY(m)                                          \
+	(IBI_MDB_GET_GRP(m) == IBI_MDB_GRP_PENDING_READ_NOTIF)
+#define IBI_MDB_MIPI_DBGDATAREADY                                              \
+	IBI_MDB_ID(IBI_MDB_GRP_PENDING_READ_NOTIF, 0xd)
+#define IBI_MDB_MCTP IBI_MDB_ID(IBI_MDB_GRP_PENDING_READ_NOTIF, 0xe)
+
 /**
  * struct i3c_device_info - I3C device information
  * @pid: Provisional ID
@@ -107,6 +138,8 @@ enum i3c_dcr {
  * @max_read_turnaround: max read turn-around time in micro-seconds
  * @max_read_len: max private SDR read length in bytes
  * @max_write_len: max private SDR write length in bytes
+ * @pec: flag telling whether PEC (Packet Error Check) generation and verification for read
+ *       and write transaction is enabled
  *
  * These are all basic information that should be advertised by an I3C device.
  * Some of them are optional depending on the device type and device
@@ -128,6 +161,8 @@ struct i3c_device_info {
 	u32 max_read_turnaround;
 	u16 max_read_len;
 	u16 max_write_len;
+	u8 pec;
+	__be16 status;
 };
 
 /*
@@ -178,6 +213,7 @@ struct i3c_driver {
 	int (*probe)(struct i3c_device *dev);
 	void (*remove)(struct i3c_device *dev);
 	const struct i3c_device_id *id_table;
+	bool target;
 };
 
 static inline struct i3c_driver *drv_to_i3cdrv(struct device_driver *drv)
@@ -293,6 +329,8 @@ int i3c_device_do_priv_xfers(struct i3c_device *dev,
 			     struct i3c_priv_xfer *xfers,
 			     int nxfers);
 
+int i3c_device_generate_ibi(struct i3c_device *dev, const u8 *data, int len);
+
 void i3c_device_get_info(struct i3c_device *dev, struct i3c_device_info *info);
 
 struct i3c_ibi_payload {
@@ -331,5 +369,21 @@ int i3c_device_request_ibi(struct i3c_device *dev,
 void i3c_device_free_ibi(struct i3c_device *dev);
 int i3c_device_enable_ibi(struct i3c_device *dev);
 int i3c_device_disable_ibi(struct i3c_device *dev);
+int i3c_device_send_ccc_cmd(struct i3c_device *dev, u8 ccc_id);
+
+int i3c_device_getstatus_ccc(struct i3c_device *dev, struct i3c_device_info *info);
+int i3c_device_setmrl_ccc(struct i3c_device *dev, struct i3c_device_info *info, u16 read_len,
+			  u8 ibi_len);
+int i3c_device_setmwl_ccc(struct i3c_device *dev, struct i3c_device_info *info, u16 write_len);
+int i3c_device_getmrl_ccc(struct i3c_device *dev, struct i3c_device_info *info);
+int i3c_device_getmwl_ccc(struct i3c_device *dev, struct i3c_device_info *info);
+
+struct i3c_target_read_setup {
+	void (*handler)(struct i3c_device *dev, const u8 *data, size_t len);
+};
+
+int i3c_target_read_register(struct i3c_device *dev, const struct i3c_target_read_setup *setup);
+
+int i3c_device_control_pec(struct i3c_device *dev, bool pec);
 
 #endif /* I3C_DEV_H */
diff --git a/include/linux/i3c/master.h b/include/linux/i3c/master.h
index d335dea3798c..e378e83a77e1 100644
--- a/include/linux/i3c/master.h
+++ b/include/linux/i3c/master.h
@@ -22,10 +22,13 @@
 #define I3C_BROADCAST_ADDR		0x7e
 #define I3C_MAX_ADDR			GENMASK(6, 0)
 
+struct i3c_target_ops;
 struct i3c_master_controller;
 struct i3c_bus;
 struct i2c_device;
 struct i3c_device;
+struct i3c_slave_setup;
+struct i3c_slave_payload;
 
 /**
  * struct i3c_i2c_dev_desc - Common part of the I3C/I2C device descriptor
@@ -85,7 +88,6 @@ struct i2c_dev_boardinfo {
  */
 struct i2c_dev_desc {
 	struct i3c_i2c_dev_desc common;
-	const struct i2c_dev_boardinfo *boardinfo;
 	struct i2c_client *dev;
 	u16 addr;
 	u8 lvr;
@@ -181,14 +183,26 @@ struct i3c_dev_boardinfo {
 	u8 init_dyn_addr;
 	u8 static_addr;
 	u64 pid;
+	u8 bcr;
+	u8 dcr;
 	struct device_node *of_node;
 };
 
+/**
+ * struct i3c_target_info - target information attached to a specific device
+ * @read handler: handler specified at i3c_target_read_register() call time.
+ */
+
+struct i3c_target_info {
+	void (*read_handler)(struct i3c_device *dev, const u8 *data, size_t len);
+};
+
 /**
  * struct i3c_dev_desc - I3C device descriptor
  * @common: common part of the I3C device descriptor
  * @info: I3C device information. Will be automatically filled when you create
  *	  your device with i3c_master_add_i3c_dev_locked()
+ * @target_info: I3C target information.
  * @ibi_lock: lock used to protect the &struct_i3c_device->ibi
  * @ibi: IBI info attached to a device. Should be NULL until
  *	 i3c_device_request_ibi() is called
@@ -207,6 +221,7 @@ struct i3c_dev_boardinfo {
 struct i3c_dev_desc {
 	struct i3c_i2c_dev_desc common;
 	struct i3c_device_info info;
+	struct i3c_target_info target_info;
 	struct mutex ibi_lock;
 	struct i3c_device_ibi_info *ibi;
 	struct i3c_device *dev;
@@ -323,7 +338,6 @@ enum i3c_addr_slot_status {
  *	  the same master in parallel. This is the responsibility of the
  *	  master to guarantee that frames are actually sent sequentially and
  *	  not interlaced
- * @jesd403: true if the bus is JESD403 compliant.
  *
  * The I3C bus is represented with its own object and not implicitly described
  * by the I3C master to cope with the multi-master functionality, where one bus
@@ -344,7 +358,6 @@ struct i3c_bus {
 		struct list_head i2c;
 	} devs;
 	struct rw_semaphore lock;
-	bool jesd403;
 };
 
 /**
@@ -432,6 +445,7 @@ struct i3c_bus {
 struct i3c_master_controller_ops {
 	int (*bus_init)(struct i3c_master_controller *master);
 	void (*bus_cleanup)(struct i3c_master_controller *master);
+	void (*bus_reset)(struct i3c_master_controller *master);
 	int (*attach_i3c_dev)(struct i3c_dev_desc *dev);
 	int (*reattach_i3c_dev)(struct i3c_dev_desc *dev, u8 old_dyn_addr);
 	void (*detach_i3c_dev)(struct i3c_dev_desc *dev);
@@ -454,6 +468,14 @@ struct i3c_master_controller_ops {
 	int (*disable_ibi)(struct i3c_dev_desc *dev);
 	void (*recycle_ibi_slot)(struct i3c_dev_desc *dev,
 				 struct i3c_ibi_slot *slot);
+	int (*register_slave)(struct i3c_master_controller *master,
+			      const struct i3c_slave_setup *req);
+	int (*unregister_slave)(struct i3c_master_controller *master);
+	int (*send_sir)(struct i3c_master_controller *master,
+			struct i3c_slave_payload *payload);
+	int (*put_read_data)(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify);
 };
 
 /**
@@ -465,6 +487,8 @@ struct i3c_master_controller_ops {
  *	 registered to the I2C subsystem to be as transparent as possible to
  *	 existing I2C drivers
  * @ops: master operations. See &struct i3c_master_controller_ops
+ * @target_ops: target operations. See &struct i3c_target_ops
+ * @target: true if the underlying I3C device acts as a target on I3C bus
  * @secondary: true if the master is a secondary master
  * @init_done: true when the bus initialization is done
  * @boardinfo.i3c: list of I3C  boardinfo objects
@@ -487,8 +511,12 @@ struct i3c_master_controller {
 	struct i3c_dev_desc *this;
 	struct i2c_adapter i2c;
 	const struct i3c_master_controller_ops *ops;
+	const struct i3c_target_ops *target_ops;
+	unsigned int pec_supported : 1;
+	unsigned int target : 1;
 	unsigned int secondary : 1;
 	unsigned int init_done : 1;
+	unsigned int jdec_spd : 1;
 	struct {
 		struct list_head i3c;
 		struct list_head i2c;
@@ -527,15 +555,20 @@ int i3c_master_disec_locked(struct i3c_master_controller *master, u8 addr,
 			    u8 evts);
 int i3c_master_enec_locked(struct i3c_master_controller *master, u8 addr,
 			   u8 evts);
+int i3c_master_setmrl_locked(struct i3c_master_controller *master,
+			     struct i3c_device_info *info, u16 read_len,
+			     u8 ibi_len);
 int i3c_master_entdaa_locked(struct i3c_master_controller *master);
 int i3c_master_defslvs_locked(struct i3c_master_controller *master);
-
+int i3c_master_rstdaa_locked(struct i3c_master_controller *master,
+				    u8 addr);
 int i3c_master_get_free_addr(struct i3c_master_controller *master,
 			     u8 start_addr);
 
 int i3c_master_add_i3c_dev_locked(struct i3c_master_controller *master,
 				  u8 addr);
 int i3c_master_do_daa(struct i3c_master_controller *master);
+int i3c_master_enable_hj(struct i3c_master_controller *master);
 
 int i3c_master_set_info(struct i3c_master_controller *master,
 			const struct i3c_device_info *info);
@@ -546,6 +579,13 @@ int i3c_master_register(struct i3c_master_controller *master,
 			bool secondary);
 int i3c_master_unregister(struct i3c_master_controller *master);
 
+int i3c_register(struct i3c_master_controller *master,
+		 struct device *parent,
+		 const struct i3c_master_controller_ops *master_ops,
+		 const struct i3c_target_ops *target_ops,
+		 bool secondary);
+int i3c_unregister(struct i3c_master_controller *master);
+
 /**
  * i3c_dev_get_master_data() - get master private data attached to an I3C
  *			       device descriptor
@@ -638,6 +678,18 @@ i3c_master_get_bus(struct i3c_master_controller *master)
 	return &master->bus;
 }
 
+struct i3c_slave_payload {
+	unsigned int len;
+	const void *data;
+};
+
+struct i3c_slave_setup {
+	unsigned int max_payload_len;
+	unsigned int num_slots;
+	void (*handler)(struct i3c_master_controller *m,
+			const struct i3c_slave_payload *payload);
+};
+
 struct i3c_generic_ibi_pool;
 
 struct i3c_generic_ibi_pool *
@@ -654,4 +706,30 @@ void i3c_master_queue_ibi(struct i3c_dev_desc *dev, struct i3c_ibi_slot *slot);
 
 struct i3c_ibi_slot *i3c_master_get_free_ibi_slot(struct i3c_dev_desc *dev);
 
+int i3c_master_register_slave(struct i3c_master_controller *master,
+			      const struct i3c_slave_setup *req);
+int i3c_master_unregister_slave(struct i3c_master_controller *master);
+int i3c_master_send_sir(struct i3c_master_controller *master,
+			struct i3c_slave_payload *payload);
+/**
+ * i3c_master_put_read_data() - put read data and optionally notify primary master
+ * @master: master object in slave mode
+ * @data: data structure to be read
+ * @ibi_notify: IBI data (including MDB) to notify primary master device
+ */
+int i3c_master_put_read_data(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify);
+/*
+ * Slave message queue driver API
+ */
+#ifdef CONFIG_I3C_SLAVE_MQUEUE
+int i3c_slave_mqueue_probe(struct i3c_master_controller *master);
+int i3c_slave_mqueue_remove(struct i3c_master_controller *master);
+#endif
+
+#ifdef CONFIG_I3C_SLAVE_EEPROM
+int i3c_slave_eeprom_probe(struct i3c_master_controller *master);
+int i3c_slave_eeprom_remove(struct i3c_master_controller *master);
+#endif
 #endif /* I3C_MASTER_H */
diff --git a/include/linux/i3c/mctp/i3c-mctp.h b/include/linux/i3c/mctp/i3c-mctp.h
new file mode 100644
index 000000000000..dd20750d79d8
--- /dev/null
+++ b/include/linux/i3c/mctp/i3c-mctp.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation.*/
+
+#ifndef I3C_MCTP_H
+#define I3C_MCTP_H
+
+#define I3C_MCTP_PACKET_SIZE	68
+#define I3C_MCTP_PAYLOAD_SIZE	64
+#define I3C_MCTP_HDR_SIZE	4
+
+/* PECI MCTP Intel VDM definitions */
+#define MCTP_MSG_TYPE_VDM_PCI		0x7E
+#define MCTP_VDM_PCI_INTEL_VENDOR_ID	0x8086
+#define MCTP_VDM_PCI_INTEL_PECI		0x2
+
+/* MCTP message header offsets */
+#define MCTP_MSG_HDR_MSG_TYPE_OFFSET	0
+#define MCTP_MSG_HDR_VENDOR_OFFSET	1
+#define MCTP_MSG_HDR_OPCODE_OFFSET	4
+
+struct i3c_mctp_client;
+
+struct mctp_protocol_hdr {
+	u8 ver;
+	u8 dest;
+	u8 src;
+	u8 flags_seq_tag;
+} __packed;
+
+struct i3c_mctp_packet_data {
+	u8 protocol_hdr[I3C_MCTP_HDR_SIZE];
+	u8 payload[I3C_MCTP_PAYLOAD_SIZE];
+};
+
+struct i3c_mctp_packet {
+	struct i3c_mctp_packet_data data;
+	u32 size;
+};
+
+void *i3c_mctp_packet_alloc(gfp_t flags);
+void i3c_mctp_packet_free(void *packet);
+
+int i3c_mctp_get_eid(struct i3c_mctp_client *client, u8 domain_id, u8 *eid);
+int i3c_mctp_send_packet(struct i3c_device *i3c, struct i3c_mctp_packet *tx_packet);
+struct i3c_mctp_packet *i3c_mctp_receive_packet(struct i3c_mctp_client *client,
+						unsigned long timeout);
+struct i3c_mctp_client *i3c_mctp_add_peci_client(struct i3c_device *i3c);
+void i3c_mctp_remove_peci_client(struct i3c_mctp_client *client);
+
+#endif /* I3C_MCTP_H */
diff --git a/include/linux/i3c/target.h b/include/linux/i3c/target.h
new file mode 100644
index 000000000000..9e71124b5325
--- /dev/null
+++ b/include/linux/i3c/target.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022, Intel Corporation */
+
+#ifndef I3C_TARGET_H
+#define I3C_TARGET_H
+
+#include <linux/device.h>
+#include <linux/i3c/device.h>
+
+struct i3c_master_controller;
+
+struct i3c_target_ops {
+	int (*bus_init)(struct i3c_master_controller *master);
+	void (*bus_cleanup)(struct i3c_master_controller *master);
+	int (*priv_xfers)(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers, int nxfers);
+	int (*generate_ibi)(struct i3c_dev_desc *dev, const u8 *data, int len);
+};
+
+int i3c_target_register(struct i3c_master_controller *master, struct device *parent,
+			const struct i3c_target_ops *ops);
+int i3c_target_unregister(struct i3c_master_controller *master);
+
+#endif
-- 
2.34.1

